# -*- mode:org; -*-

#+title:The Universe Known as LISP
#+subtitle:{{{version}}} {{{date}}}
#+author:LOLH
#+date:2020-12-09 08:59
#+macro:version Version 0.0.97
#+macro:upload-date (eval (current-time-string))
#+bucket:pinecone-forest.com

{{{version}}} {{{date}}}

#+texinfo:@insertcopying

#+texinfo: @heading From the Creators of Lisp and Scheme

#+begin_quote
No amount of language design can force a programmer to write clear programs.
--- Guy Steele & Gerald Sussman
#+end_quote

#+texinfo: @heading And now to Lisp

#+attr_texinfo: :author Richard P. Gabriel, The Art of Lisp & Writing, 2003
#+begin_quote
Lisp is the language of loveliness.
#+end_quote
- https://www.dreamsongs.com/ArtOfLisp.html


#+texinfo:@ifnothtml
[[./resources/images/lisp-universe.jpg]]
#+texinfo:@end ifnothtml
#+texinfo:@ifhtml
[[../resources/images/lisp-universe.jpg]]
#+texinfo:@end ifhtml

- https://xkcd.com/224/
- A testimonial from Chris Crawford in
  - /Perl is Dead. Python is the New Java/
  - published in https://medium.com/netdef/perl-is-dead-python-is-the-new-java-5c11af86c17a
  - on Nov 6, 2020


#+attr_texinfo: :author Chris Crawford
#+begin_quote
What has been, for me, the most mind-expanding programming language? LISP.

To quote Eric Steven Raymond from his manifesto “How To Become A Hacker”:

"LISP is  worth learning  for a  different reason  — the  profound enlightenment
experience you will have when you finally get it. That experience will make you
a better programmer for  the rest of your days, even if  you never actually use
LISP itself a lot."

He’s not wrong! I’ve had that exact type of experience with LISP.
#+end_quote


"There’s also a special place in my  heart for Emacs Lisp, a venerable goofball
language that’s so much fun to discuss."
- Chris Wellons, https://nullprogram.com/about/


"Lisp programmers  are of  the opinion that  =[]= and ={}=  are just  =()= with
delusions of grandeur."
- Joe Marshall — Apropos of Nothing @2020-10-15 22:18 http://planet.lisp.org


"47. The first  Lisp interpreter was a  result of a programmer  ignoring his boss's
advice." [[http://norvig.com][Peter Norvig]], [[http://norvig.com/Lisp-retro.html][A Retrospective on Paradigms of AI Programming]]

"48. Abelson and  Sussman (1985) is probably the best  introduction to computer
science ever written. Id.

"CommonLisp, the  mud ball of strength,  [is] the acting patriarch  of the Lisp
family." (https://wiki.c2.com/?CommonLisp)

#+texinfo: @ifnothtml
[[./resources/images/MfcSJ3gl.jpg]]
#+texinfo: @end ifnothtml
#+texinfo: @ifhtml
[[../resources/images/MfcSJ3gl.jpg]]
#+texinfo: @end ifhtml
(https://wiki.c2.com/?SmugLispWeenie)


#+texinfo: @heading Creator of Organisms
#+attr_texinfo: :author Alan Perlis
#+begin_quote
"Pascal is for building pyramids  -- imposing, breathtaking structures built by
armies pushing heavy blocks into place. Lisp is for building organisms..."
#+end_quote
- https://www.cons.org/cmucl/


#+begin_quote
Alan Jay  Perlis (April 1,  1922 – February 7,  1990) was an  American computer
scientist and  professor at Purdue  University, Carnegie Mellon  University and
Yale  University. He  is  best known  for his  pioneering  work in  programming
languages   and    was   the   first    recipient   of   the    Turing   Award.
[fn::https://amturing.acm.org/award_winners/perlis_0132439.cfm]
#+end_quote

- [[https://web.archive.org/web/19990117034445/http://www-pu.informatik.uni-tuebingen.de/users/klaeren/epigrams.html][Alan Perlis' Epigrams]]


#+texinfo: @heading Local Optimum
#+attr_texinfo: :author John McCarthy, 1980
#+begin_quote
"LISP  has survived  for 21  years [61  years  as of  2020!] because  it is  an
approximate local optimum in the space of programming languages."
#+end_quote



- http://jmc.stanford.edu/articles/lisp20th.html
- [[http://jmc.stanford.edu/articles/index.html][Articles by John McCarthy]]


#+texinfo: @heading LISP: A Point of High Ground

#+attr_texinfo: :author Paul Graham in "The Roots of Lisp", May 2001
#+begin_quote
"It seems  to me that  there have been two  really clean, consistent  models of
programming so far:  the C model and  the Lisp model. These two  seem points of
high ground,  with swampy lowlands between  them. As computers have  grown more
powerful, the  new languages being  developed have been moving  steadily toward
the Lisp model. A  popular recipe for new programming languages  in the past 20
years has been to take the C model of computing and add to it, piecemeal, parts
taken from the Lisp model, like runtime typing and garbage collection."
#+end_quote

- [[http://www.paulgraham.com/articles.html][Essays by Paul Graham]]


#+texinfo: @heading Why Common Lisp for Scientific Programming?
- https://drmeister.wordpress.com

#+attr_texinfo: :author Christian Schafmeister, 2015-11-23, creator of CLASP
#+begin_quote
I’ve programmed  in many languages  and Common Lisp  is the best  at expressing
ideas. Every language  gets translated into an abstract syntax  tree on its way
to native code, Lisp  code is an abstract syntax tree.  There is no programming
concept that can’t  be expressed compactly in  Lisp, this is not  true in other
languages.  You  cannot  yet   express  multiple  dispatch  functions,  dynamic
variables  or Common  Lisp style  macros (a  few CL  features) compactly  in R,
Fortran, C++, or Python.

Why are R, Fortran, C++, or Python considered suitable for scientific
computing?

It is the wrong  question – those languages are just  the languages that people
started using and so they keep using them.  It is not a choice most people make
– it is inertia.

I choose Common Lisp.
#+end_quote

#+texinfo: @subheading About Christian Schafmeister
- https://drmeister.wordpress.com/about/

#+begin_quote
I’m a chemistry  professor who writes software to design  molecules that I hope
will make  the world a better  place. I’ve been  programming since I was  12, I
have  written code  in  a lot  of programming  languages  including Basic,  X86
assembler, Pascal,  Prolog, Fortran,  Smalltalk, TCL, PHP,  Python, C,  C++ and
Common Lisp....

I run  a research  group in  the Chemistry Department  at Temple  University in
Philadelphia, PA. We have developed a way to make the largest, most complex and
most “programmable” molecules outside of biology. We call them “spiroligomers”,
they are large, shape-programmable  and functional group programmable molecules
that  let  us  construct  molecules  that bind  proteins  as  therapeutics  and
accelerate chemical  reactions the way that  enzymes do. The goal  is to create
molecules  that  can do  everything  that  proteins can  do  in  nature but  be
designable and evolvable by human beings.
#+end_quote

#+texinfo: @heading The Power of Runtime Compilation

#+attr_texinfo: :author https://wiki.c2.com/?RuntimeCompilation (2005)
#+begin_quote
While there are projects to implement CL on top of a C compiler (see ECL), that
behaviour is  the exception,  not the  rule. There are,  however, very  good CL
compilers  (see  CMUCL for  a  free  one) which  will  compile  CL to  Assembly
Language, generally within a factor of 2  of a good optimizing C compiler. This
is  pretty amazing,  considering how  much more  power you  get in  CL compared
to  C.  To  put it  another  way:  a  lot  of  people like  languages  such  as
tcl/perl/python, because it's abstractions let  them code much faster than they
would in C. However, the "abstraction penalty", if you want to call it that, is
sometimes quite high, often a couple or  even three of orders of magnitude.  So
often people  optimize by  going back and  writing critical bits  in C  or C++,
which is  a bit of  a mess. With  CL, you get  more power and  abstraction than
these languages, and  with appropriately written code you can  have very little
penalty.  Why  this hasn't  sunk it for  more people I  am not  sure (actually,
that's a fib - I have some ideas). [[https://wiki.c2.com/?WhyNotLisp][(Why Not Lisp?)]]
#+end_quote

#+attr_texinfo: :author Peter Norvig, Retrospective
#+begin_quote
In 1991 Lisp offered  a combination of features that could not  be found in any
other language. This combination made Lisp almost a necessity for certain kinds
of work (in AI and other applications) and made Lisp the language of choice for
a  large community  of  users. Since  then  Lisp has  maintained  and added  to
features, but other languages have caught up. ...

One more  important feature that didn't  make this list is  efficiency. Lisp is
about 1.5  to 4 times faster  than Java, and about  10 to 50 times  faster than
Python. Lisp  is probably  within 20%  to 60%  of C/C++  in efficiency  on most
tasks,  which  is  close  enough  that  the  differences  depend  more  on  the
programmers  involved  than  the  language,  and close  enough  that  for  most
applications that speed is not an issue  for Lisp. Python is a different story:
there is a large class of problems for which Python is too slow. ...

New Lisp Books

The best, in my opinion, are Paul Graham's On Lisp and ANSI Common Lisp.
Probably the best book ever on how to write Lisp compilers and interpreters is
Christian Queinnec's Lisp in Small Pieces.

- http://norvig.com/Lisp-retro.html
#+end_quote

#+texinfo: @heading The Demise of Lisp

#+attr_texinfo: :author Ron Garret, f/k/a Erann Gat
#+begin_quote
The demise  of Lisp  at JPL  is a  tragedy. The  language is  particularly well
suited  for  the  kind  of  software  development  that  is  often  done  here:
one-of-a-kind, highly dynamic applications that  must be developed on extremely
tight  budgets and  schedules. The  efficacy of  the language  in that  kind of
environment  is  amply documented  by  a  long  record of  unmatched  technical
achievements.

The  situation  is particularly  ironic  because  the  argument that  has  been
advanced for  discarding Lisp in favor  of C++ (and  now for Java) is  that JPL
should use "industry best practice." The problem with this argument is twofold:
first, we're  confusing best practice with  standard practice. The two  are not
the same. And  second, we're assuming that best (or  even standard) practice is
an  invariant with  respect to  the task,  that the  best way  to write  a word
processor  is also  the best  way to  write a  spacecacraft control  system. It
isn't.

My job today (I  am now working on software verification  and validation) is to
solve problems that can be traced directly back to the use of purely imperative
langauges with  poorly defined semantics  like C and  C++. (The situation  is a
little better with Java, but not much.) But, of course, the obvious solution --
to use non-imperative languages with well defined semantics like Lisp -- is not
an option. I can't even say the  word Lisp without cementing my reputation as a
crazy lunatic who thinks  Lisp is the Answer to Everything. So  I keep my mouth
shut (mostly) and watch helplessly as millions of tax dollars get wasted.
#+end_quote

- from /Lisping at JPL/
- http://www.flownet.com/gat/jpl-lisp.html



#+texinfo: @heading The Power of Macros

#+attr_texinfo: :author Peter Seibel, author of /Practical Common Lisp/
#+begin_quote
Java added  a similar kind  of loop construct  [i.e., Common Lisp’s  ~DOLIST~ ]
with the "enhanced"  for loop in Java  1.5, as part of JSR-201.   Notice what a
difference macros  make.  A  Lisp programmer  who notices  a common  pattern in
their code can  write a macro to give themselves  a source-level abstraction of
that pattern.  A  Java programmer who notices the same  pattern has to convince
Sun that this particular abstraction is  worth adding to the language. Then Sun
has  to publish  a JSR  and  convene an  industry-wide "expert  group" to  hash
everything  out.   That  process--according  to Sun--takes  an  average  of  18
months. After that, the compiler writers all have to go upgrade their compilers
to  support the  new  feature. And  even once  the  Java programmer's  favorite
compiler supports  the new version of  Java, they probably still  can't use the
new  feature until  they're allowed  to break  source compatibility  with older
versions of Java. So an annoyance  that Common Lisp programmers can resolve for
themselves within five minutes plagues Java programmers for years.

- From /Practical  Common Lisp/,  Ch 7  “Macros: Standard  Control Constructs”,
  footnote 5.
#+end_quote

#+texinfo:@heading Interactive Programming

Interactive  programming boosts  your productivity  so much  that I  believe it
should always  be part  of the  decision process  when it  comes to  choosing a
language to  work with. Hopefully this  advance in the practice  of programming
will be remembered when we design the language of the future.

I believe that for this reason alone Common Lisp is worth learning (and using).

- Modern, functional Common Lisp: Myths and tips
- https://ambrevar.xyz/modern-common-lisp/#orgc7349fb


* Introduction to Lisp
:PROPERTIES:
:unnumbered: t
:END:

#+texinfo:@ifnothtml
[[./resources/images/lisp-creature.png]]
#+texinfo:@end ifnothtml
#+texinfo:@ifhtml
[[../resources/images/lisp-creature.png]]
#+texinfo:@end ifhtml


- Introducing Commong Lisp :: [[https://lisp-lang.org][Common Lisp]]

  Welcome to ~lisp-lang.org~, the new home of Common Lisp on the web.

  Previously, if someone wanted to learn  Common Lisp, the language, their best
  bet was  Peter Seibel’s  /Practical Common  Lisp/. But  the book,  written in
  2005, doesn’t cover setting up a *modern Common Lisp environment*: tools like
  ~Quicklisp~ and ~Quickdocs~ are more recent inventions.

  Learning how  to write =ASDF=  systems (think ~package.json~), how  a library
  should  be   structured,  where   to  find   documentation  (the   answer  is
  ~Quickdocs~), all of  that information is spread across  dozens of tutorials,
  manuals and blog posts across different websites.

  Languages  created by  a  single person  or  a small  group,  around which  a
  community accretes, tend to do better  here: ~Python~, ~Ruby~ and ~Scala~ all
  have  websites that  provide all  of  these resources.  Languages created  by
  commitees, like  ~JavaScript~ or ~Common  Lisp~ or ~C~, rarely  have official
  websites.

  The goal of ~lisp-lang.org~ is to lower  the barrier to entry to Common Lisp:
  - provide a central location to both advertise Common Lisp, and

  - provide all  the information  prospective users  need to  become productive
    with it,

  - without having  to collect it from  different sites and blogs,  and

  - without falling into  choice paralysis.


  ‘Productive’ means  going beyond teaching  users about lists and  macros, and
  including information on
    - how to write libraries,
    - unit-test them,
    - use CI and code coverage, and
    - publish them to Quicklisp.


  Currently we have:

  - tutorials
  - style guide
  - success stories
  - lisp books


- Awesome Common Lisp :: [[https://github.com/CodyReichert/awesome-cl][Awesome Common Lisp]]

  A curated list of awesome Common Lisp libraries (and more)

- Common Lisp Wiki :: https://wiki.c2.com/?CommonLisp

  Descended  from  one of  the  oldest  surviving programming  languages  (only
  Fortran is older),  CommonLisp is the first language  with integrated support
  for Object Oriented Programming to get ANSI standardized.

  It  is a  rich  language with  clear semantics  which  allows programming  in
  procedural, functional, object oriented and logical (rule based) style all in
  the same program.

- Standardized Features ::
  - A well designed, well integrated object system (CLOS)
  - A well designed exception/condition handling mechanism
  - A not so easy to use/understand, but working, Package system
  - Support for Runtime Compilation[fn:1]
  - A MetaObjectProtocol (the MOP is supplied in most implementations)[fn:2]

- Common-Lisp :: https://common-lisp.net

  ``This site is one among many gateways to Common Lisp. Its goal is to provide
  the  Common Lisp  community  with  development resources  and  to  work as  a
  starting point for new programmers.''

  Common   Lisp   is   the  *modern*,   *multi-paradigm*,   *high-performance*,
  *compiled*,   *ANSI-standardized*,  most   prominent   (along  with   Scheme)
  descendant of the long-running family of Lisp programming languages.

  Common Lisp is  known for being extremely flexible,  having excellent support
  for object oriented  programming, and fast prototyping  capabilities. It also
  sports  an extremely  powerful macro  system that  allows you  to tailor  the
  language to your application, and a flexible run-time environment that allows
  modification and debugging of running applications (excellent for server-side
  development  and  long-running critical  software).  It  is a  multi-paradigm
  programming  language that  allows you  to choose  the approach  and paradigm
  according to your application domain.


LISP  was  originally  specified  in  1958 and  derives  its  name  from  =LISt
Processing= (or Lots of Insignificant Silly Parentheses).

[[http://www.maclisp.info][Maclisp]] is a dialect  of Lisp developed at MIT in 1966.  It added many features
that we  take for  granted in  Lisp today: functions  with variable  numbers of
arguments, macros, arrays,  and non-local dynamic exits. It  was influential on
the development of EmacsLisp, Scheme, ZetaLisp and CommonLisp. The first Scheme
interpreter and  the first Emacs  with Lisp facilities (see  MulticsEmacs) were
written in MacLisp.

- [[http://www.maclisp.info/pitmanual/index.html][The MacLISP Manual]]

- [[https://www.gnu.org/software/emacs/emacs-paper.html][EMACS: The Extensible, Customizable Display Editor (RMS 1981)]]
** What is Common Lisp?
Common  Lisp is  well  suited  to large  programming  projects and  explorative
programming. The language  has a dynamic semantics which  distinguishes it from
languages  such as  C  and Ada.  It features  automatic  memory management,  an
interactive  incremental  development environment,  a  module  system, a  large
number  of  powerful  data  structures,  a large  standard  library  of  useful
functions, a  sophisticated object  system supporting multiple  inheritance and
generic functions, an  exception system, user-defined types and  a macro system
which allows programmers to extend the language.

** The Roots of Lisp
*** John McCarthy and LISP
 - http://jmc.stanford.edu/articles/recursive.html


 #+texinfo: @heading Recursive Functions of Symbolic Expressions and Their Computation by Machine, Part I

 #+texinfo: @subheading This was the original paper on LISP.

 - http://jmc.stanford.edu/articles/recursive.html

 It is copied with  minor notational changes from CACM, April  1960. If you want
 the exact typography,  look there. A few typographical changes  have been made,
 but the notation  has not been modernized. There are  also some new explanatory
 footnotes. Part  II, which never appeared,  was to have had  some Lisp programs
 for algebraic computation.

 In  this  article,  we  first  describe  a  formalism  for  defining  functions
 recursively. We  believe this  formalism has advantages  both as  a programming
 language and  as a  vehicle for  developing a theory  of computation.  Next, we
 describe S-expressions and  S-functions, give some examples,  and then describe
 the universal S-function apply which plays  the theoretical role of a universal
 Turing machine and  the practical role of an interpreter.  Then we describe the
 representation of S-expressions in the memory of the IBM 704 by list structures
 similar to  those used  by Newell,  Shaw and Simon,  and the  representation of
 S-functions  by  program.  Then  we  mention the  main  features  of  the  LISP
 programming  system for  the  IBM 704.  Next comes  another  way of  describing
 computations  with  symbolic  expressions,  and finally  we  give  a  recursive
 function interpretation of flow charts.

 [[http://jmc.stanford.edu/articles/recursive/recursive.pdf][Download the article in PDF]]

*** Paul Graham's "The Roots of Lisp"

 - [[http://www.paulgraham.com/rootsoflisp.html][The Roots of Lisp, by Paul Graham]] January 18, 2002

(I  wrote  this  article  to  help  myself  understand  exactly  what  McCarthy
discovered. You don't need to know this stuff to program in Lisp, but it should
be helpful to anyone who wants to understand  the essence of Lisp — both in the
sense of its origins and its semantic core. The fact that it has such a core is
one  of  Lisp's distinguishing  features,  and  the  reason why,  unlike  other
languages, Lisp has dialects.) -- Paul Graham

 #+begin_quote
 Paul Graham's  The Roots of Lisp,  a cogent essay dealing  with John McCarthy's
 astonishing 1960's  paper[fn:3] which  introduced the  LISP language,  and more
 importantly, the functional model of programing.

 Graham stresses  his essay is  more important today  than ever, given  how more
 languages have  moved (albeit in a  piecemeal fashion) towards the  LISP model.
 Working with seven primitive operators, the paper shows how the entire language
 is built.  Most importantly, the paper  shows the LISP trademark,  how to write
 the language in itself.

 An interesting aspect  for Scheme programmers like myself is  the discussion of
 dynamic versus lexical scoping.

 Reading the paper reminds us of why functional languages, especially LISP based
 ones, aren't just the best for  expressing algorithms, but are the most elegant
 models  of  programming  since  the  are  easily  transcribed  in  mathematical
 notation.

 I can't  recommend The Roots  of Lisp enough. The  paper is available  for free
 download on Paul Graham's site.
 #+end_quote

 Posted by Robert D. Skeels * rdsathene Saturday, January 2, 2010 @
 http://tech-rdsathene.blogspot.com/search/label/Scheme

*** History of Lisp

- http://jmc.stanford.edu/articles/lisp.html


The history  of LISP according to  McCarthy's memory in 1978,  presented at the
ACM SIGPLAN History of Programming Languages Conference.

This  paper concentrates  on the  development of  the basic  ideas of  LISP and
distinguishes two  periods - Summer 1956  through Summer 1958 when  most of the
key ideas were  developed (some of which were implemented  in the FORTRAN based
FLPL), and Fall 1958 through 1962 when the programming language was implemented
and applied to problems of artificial intelligence. After 1962, the development
of LISP  became multi-stranded, and  different ideas were pursued  in different
places.

- [[http://jmc.stanford.edu/articles/lisp/lisp.pdf][Download the article in PDF.]]

*** LISP --- Notes on its Past and Future --- 1980

- http://jmc.stanford.edu/articles/lisp20th.html


This paper  was published in 1980.  I put it  up since it mostly  represents my
present opinions. There are some 1999 footnotes.

LISP has survived for 21 years because it is an approximate local optimum in
the space of programming languages. However, it has accumulated some barnacles
that should be scraped off, and some long-standing opportunities for
improvement have been neglected. It would benefit from some co-operative
maintenance especially in creating and maintaining program libraries. Computer
checked proofs of program correctness are now possible for pure LISP and some
extensions, but more theory and some smoothing of the language itself are
required before we can take full advantage of LISP's mathematical basis.LISP
has survived for 21 years because it is an approximate local optimum in the
space of programming languages. However, it has accumulated some barnacles that
should be scraped off, and some long-standing opportunities for improvement
have been neglected. It would benefit from some co-operative maintenance
especially in creating and maintaining program libraries. Computer checked
proofs of program correctness are now possible for pure LISP and some
extensions, but more theory and some smoothing of the language itself are
required before we can take full advantage of LISP's mathematical basis.

- [[http://jmc.stanford.edu/articles/lisp20th/lisp20th.pdf][Download the article in PDF.]]
*** Common Lisp --- The Untold Story
    :PROPERTIES:
    :author:   Kent M. Pitman
    :date:     2008
    :END:

This paper summarizes a talk given  at “Lisp50@OOPSLA,” the 50th Anniversary of
Lisp workshop, Monday, October 20, 2008, an event co-located with the OOPSLA’08
in Nashville, TN, in  which I offered my personal, subjective  account of how I
came to be involved with Common Lisp  and the Common Lisp standard, and of what
I learned from the process.
*** Lisp 1 Programmer's Manual
    :PROPERTIES:
    :author:   Phyllis Fox
    :date:     1960
    :END:
- http://history.siam.org/sup/Fox_1960_LISP.pdf

*** Lisp 1.5 Programmer's Manual
- http://www.softwarepreservation.org/projects/LISP/book/LISP%201.5%20Programmers%20Manual.pdf


By John McCarthy, Paul W. Abrahams, Daniel J. Edwards, Timothy P. Hart and
Michael I. Levin, 1962

#+texinfo: @heading Summary

The LISP language  is designed primarily for symbolic data  processing used for
symbolic calculations in differential and integral calculus, electrical circuit
theory,  mathematical  logic, game  playing,  and  other fields  of  artificial
intelligence. The manual  describes LISP, a formal  mathematical language. LISP
differs from most programming languages in  three important ways. The first way
is in the nature of the data. In the LISP language, all data are in the form of
symbolic  expressions  usually  referred  to as  S-expressions,  of  indefinite
length, and which have a branching  tree-type of structure, so that significant
subexpressions can  be readily isolated.  In the LISP  system, the bulk  of the
available  memory  is used  for  storing  S-expressions  in  the form  of  list
structures. The  second distinction  is that  the LISP  language is  the source
language  itself which  specifies  in  what way  the  S-expressions  are to  be
processed. Third, LISP  can interpret and execute programs written  in the form
of S-expressions. Thus, like machine language, and unlike most other high level
languages, it can be used to generate programs for further executions.

** Essays About Lisp
*** What's Wrong With Lisp
    :PROPERTIES:
    :author:   Robert Standh
    :END:
- http://metamodular.com/Essays/wrong.html


Contrary to what the title says,  we don't think there is anything particularly
wrong with  the Lisp programming  language. However,  a large number  of people
seem  to  have very  strong  and  very  strange  reactions to  this  particular
programming language.

I will ... attempt  to analyze some commonly recurring criticism  of Lisp in an
attempt to shed some light on the question and why it is often asked.

Today,  it is  a modern,  multi-paradigm language  which has  perhaps the  most
sophisticated  features of  all general-purpose  languages in  use (the  object
system, macros,  reader macros, conditions,  etc, etc). The first  question one
might ask is then "If Lisp is so good, why is it not more popular?". People who
ask such  a question typically assume  that "good" implies "popular",  and thus
look for some part of Lisp that is  NOT good, which would explain why it is not
popular. However, there  is absolutely no reason to assume  that "good" implies
"popular", so the question is really quite naive.

\dots

Lisp is not THAT unpopular (and now I will include Emacs Lisp for convenience).
In a  recent line count, Lisp  came in as number  4 when it comes  to number of
source lines of code (SLOC) in the Debian GNU/Linux (Woody) distribution, after
C, C++, and  shell with some 4  million SLOC (around 4%),  before Perl, Python,
ML, Fortran, etc.

\dots

Lisp is sufficiently different from what most people already know and expect in
a programming language, that they just aren't  willing to make the effort. In a
different  essay,  I  called  these people  "performance  oriented",  and  they
(unfortunately) make up the vast majority  of people in general, though perhaps
disproportionally so in software developers.  To summarize that essay, they are
simply victims of an incredibly strong  psychological force (that exist to some
degree in all  of us) that makes  the person attempt to  explain away something
new as being bad or useless, just in  order to avoid the hard work of having to
learn it.  The stranger  the new thing  is (like Lisp),  the harder  the victim
estimates the work to learn it, and the more important it becomes to declare it
bad or useless.

\dots

Why should all that counts in a programming language be popularity?

I often see the  very revealing parallel drawn between Lisp  and a fine violin.
Should we alter violins in order to  attract people who are used to playing the
accordion, and who are  not willing to learn the violin because  it is too hard
and too different from the accordion? Of  course not! The violin has its place,
and is a great instrument when played by someone who really masters it. Lisp is
a great  programming language  when used by  someone who knows  how to  use it.
Dumbing it down to attract mediocre performance-oriented programmers would be a
grave mistake.
*** Tutorial on Good Lisp Programming Style
- https://www.iiia.csic.es/~puyol/TAPIA/transpas/Norvig-luv-slides.pdf

  - By Peter Norvig and Kent Pitman
  - August 10, 1993
*** Lisp---Good News Bad News How to Win Big
    :PROPERTIES:
    :author:   Richard P. Gabriel
    :date:     1991
    :END:

#+texinfo: @heading Abstract
Lisp has done quite well over the last ten years: becoming nearly standardized,
forming  the basis  of a  commercial sector,  achieving excellent  performance,
having good environments, able to  deliver applications. Yet the Lisp community
has  failed to  do as  well as  it  could have.  In this  paper I  look at  the
successes, the failures, and what to do next.
*** Parenthetically Speaking (with Kent M. Pitman)
- http://www.nhplace.com/kent/PS/About-PS.html


Parenthetically Speaking expresses opinions and  analysis about the Lisp family
of languages. Except as explicitly  indicated otherwise, the opinions expressed
are those of  the author and do not necessarily  reflect the official positions
of any organization or company with which the author is affiliated.
*** Alan Kay’s advice to computer science students
    :PROPERTIES:
    :date:     2018-11-09
    :author:   Mark Miller
    :cite:     https://tekkie.wordpress.com/2018/11/09/alan-kays-advice-to-computer-science-students/
    :END:
#+texinfo: @heading Tekkie
- https://tekkie.wordpress.com/2018/11/09/alan-kays-advice-to-computer-science-students/
- by Mark Miller, Nov 9, 2018

"I’m once again going to quote a Quora answer verbatim, because I think there’s
a lot of value in it. Alan Kay answered /What book(s) would you recommend to a
computer science student?/"

#+attr_texinfo: :author Alan Kay
#+begin_quote
My basic answer is: read a lot outside of the computer field.

It is worth trying to understand what “science” means in “Computer Science” and
what “engineering” means in “Software Engineering”.

“Science” in its  modern sense means trying to reconcile  phenomena into models
that are as  explanatory and predictive as possible. There  can be “Sciences of
the Artificial”  (see the important  book by Herb Simon).  One way to  think of
this is that if people (especially engineers) build bridges, then these present
phenomena for  scientists to understand  by making models.  The fun of  this is
that  the science  will almost  always  indicate new  and better  ways to  make
bridges, so  friendly collegial relationships between  scientists and engineers
can really make progress.

An example in  computing is John McCarthy thinking about  computers in the late
50s, the really large  range of things they can do (maybe  AI?), and creating a
model  of computing  as a  language that  could serve  as its  own metalanguage
(LISP).  MY FAVORITE  BOOK ON  THIS IS  “The Lisp  1.5 Manual”  from MIT  Press
(written by McCarthy et al.). THE FIRST PART OF THIS BOOK IS STILL A CLASSIC ON
HOW TO THINK IN GENERAL, AND ABOUT COMPUTING IN PARTICULAR.

(A  later  book inspired  by  all  this is  “Smalltalk:  the  language and  its
implementation” (by  Adele Goldberg and  Dave Robson  — the “Blue  Book”). Also
contains a complete implementation in Smalltalk written in itself, etc.)

A still later  book that I like a  lot that is “real computer  science” is “The
Art of the  Metaobject Protocol” by Kiszales, Bobrow, Rivera,).  The early part
of this book especially is quite illuminating.

An early thesis  (1970) that is real computer science  is “A Control Definition
Language” by Dave Fisher (CMU).

Perhaps  my favorite  book about  computing might  seem far  afield, but  it is
wonderful  and the  writing  is wonderful:  “Computation:  Finite and  Infinite
Machines” by Marvin Minsky (ca 1967). Just a beautiful book.

To  help with  “science”,  I usually  recommend a  variety  of books:  Newton’s
“Principia” (the ultimate  science book and founding  document), “The Molecular
Biology of  the Cell”  by Bruce  Alberts, et  al. There’s  a book  of Maxwell’s
papers, etc.

You need to  wind up realizing that “Computer Science”  is still an aspiration,
not an accomplished field.

“Engineering” means “designing and building  things in principled expert ways”.
The level of this is very high for the engineering fields of Civil, Mechanical,
Electrical, Biological, etc. Engineering. These  should be studied carefully to
get the larger sense of what it means to do “engineering”.

To help  with “engineering” try  reading about the  making of the  Empire State
Building, Boulder Dam, the Golden Gate Bridge, etc. I like “Now It Can Be Told”
by  Maj Gen  Leslie  Groves (the  honcho  on the  Manhattan  Project). He’s  an
engineer, and this history  is very much not from the Los  Alamos POV (which he
also  was in  charge of)  but about  Oak Ridge,  Hanford, etc  and the  amazing
mobilization of  600,000 plus people  and lots of  money to do  the engineering
necessary to create the materials needed.

Then think about  where “software engineering” isn’t — again,  you need to wind
up realizing that “software engineering” in  any “engineering” sense is at best
still an aspiration not a done deal.

Computing  is  also a  kind  of  “media” and  “intermediary”,  so  you need  to
understand what these do for us and to us. Read Marshall McLuhan, Neil Postman,
Innis, Havelock,  etc. Mark Miller (comment  below) just reminded me  that I’ve
recommended “Technics  and Human Development,”  Vol. 1 of Lewis  Mumford’s “The
Myth  of  the  Machine” series,  as  a  great  predecessor  of both  the  media
environment ideas and of an important facet of anthropology.

I don’t know of a great anthropology  book (maybe someone can suggest), but the
understanding of human beings is the most important thing to accomplish in your
education. In a  comment below, Matt Gaboury recommended  “Human Universals” (I
think he means  the book by Donald  Brown.) This book certainly  should be read
and understood  — it  is not in  the same  class as books  about a  field, like
“Molecular Biology of the Cell”.

I like Ed Tufte’s books on “Envisioning Information”: read all of them.

Bertrand Russell’s  books are  still very  good just  for thinking  more deeply
about “this and that” (“A History of Western Philosophy” is still terrific).

Multiple points  of view  are the only  way to fight  against human  desires to
believe and create  religions, so my favorite current history  book to read is:
“Destiny Disrupted” by Tamim Ansary. He grew up in Afghanistan, moved to the US
at age 16, and is able to write  a clear illuminating history of the world from
the time of Mohammed from the point  of view of this world, and without special
pleading.
#+end_quote
*** Multics
- https://www.multicians.org/multics.html
- https://www.multicians.org/mepap.html
*** Lisp as an Alternative to Java
- https://www.iiia.csic.es/~puyol/TAPIA/lisp-java.pdf

** A Note on S-expressions--Forms--Types
The development of  the package system is  related to the change  of focus from
S-expressions  to   forms.   The  index   of  CLtL-2  contains  no   entry  for
S-expressions  or symbolic  expressions, but  the entry  for forms  contains 14
subentries and points to a total of 39 different pages.

The change  in focus from  S-expressions to forms is  bound up with  the devel-
opment of  a mature typing system,  since Common Lisp has  typed objects rather
than typed expressions.

- S-expressions ::

  S-expressions  are syntactic  units, sequences  of characters  that form  the
  written version of Lisp programs and data structures.

  We used to  say that the Lisp language consisted  of S-expressions, the major
  action of Lisp  was the evaluation of S-expressions,  and the read-eval-print
  loop consisted of  reading an S-expression, evaluating it,  and then printing
  the value as an S-expression.

- Forms ::

  A form, on the other hand, is a Common Lisp object that can be evaluated, and
  the major action of Common Lisp is the evaluation of such forms, or objects.

  The  Common Lisp  read-eval-print  loop  really has  five  steps:

  1. reading  an  S-expression,
  2. creating  the object  the S-expression denotes,
  3. evaluating the object,
  4. choosing a printed representation of the value, and
  5. printing that representation.

- Types ::

  Common Lisp  has an  extensive set of  types, each with  a predicate  to rec-
  ognize objects  of that type and  a collection of operations  defined for it,
  all organized into a type hierarchy.

  Types  covered  include:
  - numbers   (integers,  floating-point  numbers,  and ratios),
  - characters,
  - strings,
  - symbols,
  - packages,
  - lists,
  - conses,
  - functions,
  - hash tables, and
  - single dimensional arrays

  Common Lisp  is an object-oriented  language similar to  the way that  CLU is
  object-oriented,  as  opposed  to  the  modern  meaning  of  that  phrase  in
  object-oriented  programming.  Common  Lisp is  object-oriented in  the sense
  that:

  - variables have objects as their  values, and
  - two variables can be bound to the same  object;
  - composite objects have objects as  their parts;
  - objects, rather than expressions, have values and types

  To  see the  significance  of Common  Lisp’s typing  of  objects, compare  an
  untyped  language such  as Fortran  with a  strongly typed  language such  as
  Pascal with Common Lisp. In Fortran, one may store a value of one type into a
  variable,  and then  pass  that variable  by reference  to  a procedure  that
  operates on  it as  if it were  another type. In  Pascal, the  compiler would
  catch this as  an error because the  variable would be declared  as one type,
  whereas the  formal parameter would  be declared  as another type.  In Common
  Lisp, this would be caught as  an error during execution because the operator
  would complain that  the object it was  given to operate on was  of the wrong
  type.

  Common Lisp has a macro check-type that  can be used to make sure the objects
  passed to a  function are of the  correct type.  One may choose  never to use
  check-type, but  one then runs the  risk of a built-in  function, called many
  levels deep in user-defined functions, complaining that some object is of the
  wrong type. It then can be very hard to find which function actually made the
  mistake.

- Evaluation ::

  Unlike other  programming languages,  Lisp does  not operate  on a  series of
  imperative statements---“do this, then do this, and so on,” but rather on ex-
  pressions,  called   symbolic  expressions   or  S-expressions,   which  Lisp
  evaluates.

  More accurately,  a session with Common  Lisp involves an interaction  with a
  Lisp /listener/, during which the following five steps are repeated until you
  decide to stop:

  1. You type an S-expression to the Lisp listener.

  2.  The   Lisp  listener   interprets  your   S-expression  as   the  printed
     representation of a Common Lisp object.

  3. That object is evaluated. Its value is also a Common Lisp object.

  4. The Lisp listener chooses a printed representation for the value object.

  5. That printed representation is printed for you to read.

  Common Lisp is object-oriented in the sense that objects, rather than expres-
  sions, are evaluated,  and unlike many other  programming languages, objects,
  rather than expressions, have types.

** A Road to Common Lisp
"This is a road to Common Lisp, not the road to Common Lisp."

- https://stevelosh.com/blog/2018/08/a-road-to-common-lisp/

** What the Hell is Symbolic Computation?
"symbols" and  "quoting": for many  programmers coming from  non-Lisp languages
these are new, foreign concepts that don't really map back to anything in their
previous experience.

This post is an  attempt to explain what symbols actually  are and what quoting
does.

- https://stevelosh.com/blog/2016/06/symbolic-computation/

One book that  does spend more time on this  is the appropriately-named /Common
Lisp: A Gentle  Introduction to Symbolic Computation/. If you're  looking for a
good introductory Lisp book, that's the one I'd recommend.

* Common Lisp Implementations
- [[https://www.cliki.net/Common%20Lisp%20implementation][Cliki Comparison of Actively Developed Common Lisp Implementations]]
  - All the implementations provide an FFI and sockets interface
- [[https://en.wikipedia.org/wiki/Common_Lisp#Implementations][Wiki Common Lisp Implementations]]
- [[https://common-lisp.net/implementations]]
- [[http://web.archive.org/web/20161105160832/https://common-lisp.net/~dlw/LispSurvey.html][Daniel Weinreb Survey of Common Lisp Implementations (2010)]]
  - This paper is a November, 2007 (updated February, 2010) survey of Common
    Lisp implementations that are currently being actively maintained


Common Lisp comes  in many different flavors, or implementations.   You have to
choose a Lisp implementation.  This may seem like a strange thing to have to do
for folks used to languages such as Perl, Python, Visual Basic, C#, and Java.

The  difference is  that  Common Lisp  is defined  by  its standard---there  is
neither a  single implementation controlled  by a benevolent dictator,  as with
Perl and Python, nor a canonical implementation controlled by a single company,
as with VB, C#,  and Java. Anyone who wants to read  the standard and implement
the language is free to do so.

Changes to the standard have to be made in accordance with a process controlled
by  the  standards body  American  National  Standards Institute  (ANSI).  That
process is designed to keep any one entity, such as a single vendor, from being
able to  arbitrarily change the standard.  Thus, the Common Lisp  standard is a
contract  between any  Common  Lisp  vendor and  Common  Lisp programmers.  The
contract tells you  that if you write  a program that uses the  features of the
language  the way  they're described  in the  standard, you  can count  on your
program behaving the same in any conforming implementation.

On the other hand, the standard may not  cover everything you may want to do in
your programs---some  things were  intentionally left  unspecified in  order to
allow continuing  experimentation by implementers  in areas where  there wasn't
consensus about the  best way for the language to  support certain features. So
every implementation offers some features  above and beyond what's specified in
the standard. Depending  on what kind of programming you're  going to be doing,
it may make sense  to just pick one implementation that  has the extra features
you need and use that. On the other hand, if we're delivering Lisp source to be
used by  others, such as libraries,  you'll want--as far as  possible--to write
portable Common Lisp. For writing code  that should be mostly portable but that
needs facilities not  defined by the standard, Common Lisp  provides a flexible
way to write  code "conditionalized" on the features available  in a particular
implementation.

If you are looking for an open-source implementation, you have several options.

- SBCL: ("Steel Bank Common Lisp") is a high-quality open-source implementation
  that compiles to native code and runs  on a wide variety of Unixes, including
  Linux and OS X.  It supports 21-bit Unicode.

- CMUCL: ("Carnegie Mellon University Common Lisp") SBCL is derived from CMUCL,
  which is a Common Lisp developed at  Carnegie Mellon University and is in the
  public domain.

- CCL: ("Clozure Common Lisp") (formerly OpenMCL) is an excellent choice for OS
  X users.  It  compiles to machine code, supports threads,  and has quite good
  integration with OS X's Carbon and Cocoa toolkits.

Slime ("Superior Lisp Interaction Mode for  Emacs") will smooth out some of the
differences  between  implementations  by  providing  a  common  interface  for
interacting with Lisp.  Slime lets you interact with Lisp both via the REPL and
while  editing source  files.   Slime will  let you  evaluate  or compile  both
individual expressions and whole files directly from your editor.

** CMU Common Lisp
- [[https://cmucl.org][CMUCL Home]]
- [[https://gitlab.common-lisp.net/cmucl/cmucl/-/wikis/home][CMUCL Wiki]]
- [[https://www.cons.org/cmucl/doc/index.html][CMUCL Documentation]]
- Current Released Version is [[https://cmucl.org/downloads/release/21d/][CMUCL 21d]] (12/08/2018) ([[https://gitlab.common-lisp.net/cmucl/cmucl/blob/master/src/general-info/release-21d.md][see release notes]])
- [[https://common-lisp.net/project/cmucl/downloads/snapshots/2020/04/][Latest Snapshot 2020-04]] issued on 2020-03-28 ([[https://common-lisp.net/project/cmucl/downloads/snapshots/2020/04/release-21e.md][see release notes]])
- [[https://common-lisp.net/project/cmucl/downloads/][Downloads]]
- [[https://gitlab.common-lisp.net/cmucl/cmucl/-/wikis/GitAndCmucl][Git and CMUCL]]
- [[https://www.cons.org/cmucl/FAQ.html][FAQ]]


*NOTE:* CMUCL does not appear to run on modern Mac systems as it is 32bit only.


CMUCL is a free, high performance implementation of the Common Lisp programming
language which  runs on most  major Unix platforms.  It mainly conforms  to the
ANSI Common Lisp standard. CMUCL provides:
- a sophisticated native code compiler;
- a powerful  foreign function interface;
- an  implementation of  CLOS, the  Common Lisp  Object System;  which includes
  multimethods;
- a  metaobject protocol;
- a source-level debugger and  code profiler; and
- an  Emacs-like editor implemented in Common Lisp.


#+texinfo: @heading Summary of Main Features
- Support for static arrays that are never moved by GC but are properly removed
  when no longer referenced.
- Unicode support, including  many of the most common external  formats such as
  UTF-8 and support for handling Unix, DOS, and Mac end-of-line schemes.
- native  double-double  floats  including  complex  double-double  floats  and
  specialized  arrays for  double-double floats  and and  complex double-double
  floats that give approximately 106 bits (32 digits) of precision.
- a  sophisticated  native-code compiler  which  is  capable of  powerful  type
  inferences, and generates code competitive in speed with C compilers.
- generational  garbage collection  and multiprocessing  capability on  the x86
  ports.
- a foreign function interface which allows  interfacing with C code and system
  libraries, including shared libraries on most platforms, and direct access to
  Unix system calls.
- support for interprocess communication and remote procedure calls.
- an  implementation of  CLOS, the  Common Lisp  Object System,  which includes
  multimethods and a metaobject protocol.
- a  graphical  source-level debugger  using  a  Motif  interface, and  a  code
  profiler.
- an interface  to the X11 Window  System (CLX), and a  sophisticated graphical
  widget library (Garnet).
- programmer-extensible input and output streams.
- an Emacs-like editor implemented in Common Lisp.
- freely redistributable

** Steel Bank Common Lisp
- http://www.sbcl.org
- [[http://www.sbcl.org/manual/index.html][SBCL Manual]]


A branch from CMUCL. "Broadly speaking, SBCL  is distinguished from CMU CL by a
greater  emphasis on  maintainability.  SBCL  does not  use  an interpreter  by
default; all expressions  are compiled to native code unless  the user switches
the interpreter on. The SBCL compiler generates fast native code according to a
previous version of The Computer Language Benchmarks Game.

- SBCL ::
  - Steel Bank Common Lisp[fn:4]
  - In doubt, just get [[http://www.sbcl.org/platform-table.html][SBCL]]
  - Articulate Lisp also [[http://articulate-lisp.com/implementations/summary.html][recommends SBCL]] for beginners
  - A high performance Common Lisp compiler and runtime system
  - provides  an interactive  environment  including  a debugger,  a
    statistical  profiler,  a code  coverage  tool,  and many  other
    extensions
  - [[http://www.sbcl.org/manual/index.html][SBCL 2.0.8 User Manual]]

*** Running and Stopping SBCL
To run SBCL type =sbcl= at the command  line. You should end up in the toplevel
REPL (read,  eval, print  -loop), where  you can interact  with SBCL  by typing
expressions.

#+begin_example
▶ which sbcl
/opt/local/bin/sbcl

▶ sbcl
This is SBCL 2.0.7, an implementation of ANSI Common Lisp.
More information about SBCL is available at <http://www.sbcl.org/>.

SBCL is free software, provided as is, with absolutely no warranty.
It is mostly in the public domain; some portions are provided under
BSD-style licenses.  See the CREDITS and COPYING files in the
distribution for more information.
,* 
#+end_example

SBCL can be stopped at any  time by calling ~sb-ext:exit~, optionally returning
a specified numeric value to the calling process.

By default  SBCL also  exits on end  of input, caused  either by  user pressing
=Control-D= on an attached terminal, or end of input when using SBCL as part of
a shell pipeline.

**** SBCL as an inferior Lisp in Emacs

To run SBCL as an inferior-lisp from Emacs in your =.emacs= do something like:

#+begin_src elisp
;;; The SBCL binary and command-line arguments
(setq inferior-lisp-program "/opt/local/bin/sbcl --noinform")
#+end_src

=--noinform= suppress the printing of any banner or other informational message
at startup. This makes  it easier to write Lisp programs  which work cleanly in
Unix pipelines.

See [[http://www.sbcl.org/manual/index.html#Editor-Integration][Editor Integration]]

**** SBCL as a Shell Script
Standard Unix tools that are interpreters follow a common command line protocol
that is  necessary to work with  “shebang scripts”. SBCL supports  this via the
--script command line option.

#+name:hello.lisp
#+begin_src sh
#!/opt/local/bin/sbcl --script
(write-line "Hello, World!")
#+end_src

#+begin_example
$ ./hello.lisp
Hello, World!
$ sbcl --script hello.lisp
Hello, World!
#+end_example

** Clozure Common Lisp --- CCL
- https://ccl.clozure.com
- [[https://ccl.clozure.com/manual/][Clozure CL Documentation]]
- [[https://ccl.clozure.com/docs/ccl.html][CCL Manual (one page HTML)]]
- [[https://github.com/Clozure/ccl][CCL on GitHub]]
- [[https://ccl.clozure.com/openmcl-overview.pdf][Overview]]

"Clozure CL is a fast, mature, open source Common Lisp implementation that runs
on Linux, Mac OS X, FreeBSD, and Windows. Clozure CL was forked from Macintosh
Common Lisp (MCL) in 1998 and the development has been entirely separate
since."


Some  distinguishing features  of the  implementation include:
- fast compilation speed,
- native  threads,
- a precise, generational,  compacting garbage collector, and
- a convenient foreign-function interface.


Clozure CL is available for the following platforms:

- Mac OS X 10.6 and later (x86, x86-64)
- Linux (x86, x86-64, ppc32, ppc64, armv7l/armv6)
- FreeBSD (x86, x86-64)
- Solaris (x86, x86-64)
- Microsoft Windows XP and later (x86, x86-64)


- CCL ::
  - [[https://ccl.clozure.com][Clozure CL]]
  - Clozure CL compiles to native code and supports multithreading
    using native OS threads.
  - supports both Lisp code that calls external code, and external
    code that calls Lisp code.
  - Clozure CL can create standalone executables on all supported
    platforms.
  - A good implementation with very fast build times
  - fast compilation speed,
  - native threads,
  - a precise, generational, compacting garbage collector, and
  - a convenient foreign-function interface.
  - On Mac OS X, Clozure CL supports building GUI applications that
    use OS X's native Cocoa frameworks, and the OS X distributions
    include an IDE written with Cocoa, and distributed with complete
    sources.
  - On all supported platforms, Clozure CL can run as a command-line
    process, or as an inferior Emacs process using either SLIME or
    ILISP.
  - Documentation for CCL is written in a notation called [[https://github.com/Clozure/ccldoc][CCLDoc]].
  - [[https://ccl.clozure.com/docs/ccl.html][Clozure CL Manual]]

*** Running CCL

You should have a directory on your system named ~ccl~. This directory is
called the ~ccl directory~.

: /opt/local/share/ccl/<ver>

Clozure CL is made up of two parts:

- the lisp kernel ::

  The binary executable program that implements the lowest levels of the Lisp
  system.

- a heap image ::

  The  in-memory state  of a  running Lisp  system, containing  functions, data
  structures, variables, and  so on. Also, a file  containing archived versions
  of these data  in a format that  can be loaded and reconstituted  by the Lisp
  lisp kernel.


When the lisp kernel starts up, it locates the heap image, maps it into memory,
and starts running the lisp code contained  in the image. In the ccl directory,
you  will find  pre-built  lisp kernel  executables and  heap  images for  your
platform. The  heap images  have the  same basename  as the  corresponding lisp
kernel, but with an added ~.image~ suffix.

By default, the lisp kernel will look for a heap image with an appropriate name
in the same directory  that the lisp kernel itself is in.  Thus, it is possible
to start Clozure  CL simply by running ~./dx86cl64~ (or  whatever the appropriate
binary is called) directly from the ~ccl~ directory.

- OS X x86, x86-64 ::

  - ~dx86cl~, ~dx86cl.image~
  - ~dx86cl64~, ~dx86cl64.image~


If you  always run  Clozure CL  from Emacs, it  is sufficient  to use  the full
pathname of the lisp kernel binary directly.  That is, in your Emacs init file,
you could write something like:

: (setq inferior-lisp-program "/opt/local/share/ccl/1.12/dx86cl64")

or make the equivalent changes to =slime-lisp-implementations=, a list of known
Lisp implementations of the form:

: ((NAME (PROGAM PROGRAM-ARGS...) &key KEYWORD-ARGS) ...)
:
: ((ccl
:  ("/opt/local/share/ccl/1.12/dx86cl64"))
: (sbcl
:  ("/opt/local/bin/sbcl")
:  :coding-system utf-8-unix))


**** Running CCL from the Command-Line as a Script

It can also be handy to run Clozure  CL straight from a terminal prompt. In the
~scripts/~ directory of the ~ccl~ directory, there are two files named:

 - ~ccl~
 - ~ccl64~


Copy these files into ~/usr/local/bin~ or  some other directory that is on your
path, and then edit them so that the value of

: CCL_DEFAULT_DIRECTORY

is your ~ccl~ directory or add this environment variable to a startup file. You
can then start up the lisp by typing:

 : ccl
 or
 : ccl64

You may  wish to  install ~scripts/ccl64~ with  the name ~ccl~  if you  use the
64-bit lisp more. If you want the 32-bit  lisp to be available as well, you can
install  ~scripts/ccl~ as  ~ccl32~. Note  that there  is nothing  magical about
these scripts. You should feel free to edit them as desired.

*NOTE*: the  scripts start the kernel  using the shell's ~exec~  command, which
replaces  the current  process  with the  new ~ccl~  process.   The process  is
stopped using the:
: (ccl:quit) ; or
: (quit)
command, which  terminates the process.   If you  are running ~tmux~,  and have
only one window with one pane open, this instantly terminates that session, and
~tmux~ will exit.  There are two options to get around this.  One is not to use
~exec~.   The other  is to  have an  additional window  or pane  in the  ~tmux~
session, which will become current when the ~ccl~ process exits.

To obtain a list of available command-line options, type:
: ccl --help

**** The CCL Init File

By default, Clozure CL will look for a file named:

: ~/.ccl-init.lisp

in your home directory, and load it  upon startup. If you wish, you can compile
your init file,  and Clozure CL will  load the compiled version if  it is newer
than the  corresponding source file. Because  the init file is  loaded the same
way as normal Lisp  code is, you can put anything you want  in it. For example,
you can change the working directory, and load code that you use frequently.

To suppress the loading of this init-file, invoke Clozure CL with the:

: --no-init (or -n)

option.

*** CCLDoc Documentation System
- [[https://github.com/Clozure/ccldoc][CCLDoc on GitHub]]


CCLDoc is  a system for creating  Lisp documentation. It uses  S-expressions to
represent document structure, markup, cross  references, and contents. It has a
small number  of basic  operators, supports macros  for syntax  extensions, and
supports  a  simple syntax  for  embedding  expressions  in strings  for  added
convenience.

To use CCLDoc to format the CCL documentation, follow these steps:

1. Install CCL.
2. Install Quicklisp.
3. Check out the CCLDoc sources into =~/quicklisp/local-projects=


Now, start CCL, and do the following:

#+begin_src lisp
  (load "home:quicklisp;setup")
  (ql:quickload :ccldoc)
  (defparameter *d* (ccldoc:load-document "ccl:doc;manual;ccl.ccldoc"))
  (ccldoc::output-html *d* "/tmp/ccl.html" :stylesheet "ccl.css"
#+end_src

You can then view the generated ~ccl.html~ file in your browser. The generated
HTML expects to use a style file named ~ccl.css~ in the same directory.

There  is   also  a   not-quite-complete  LaTeX  converter.   To  use   it,  do
=(output-latex  *d*  "ccl.tex")=  and  then process  the  ~ccl.tex~  file  with
~xelatex~  to produce  a PDF  file. The  version of  ~xelatex~ that  comes with
MacTeX 2014 works.

*** CCL History
- 1984 :: Coral Software began the development of a Common Lisp for the
  Macintosh, called Coral Common Lisp (CCL).
- 1987 :: CCL 1.0 was released. It ran on a 1 MB Macintosh Plus.
- 1988 :: Coral  entered into a marketing relationship with  Franz, under which
  CCL was  renamed to Macintosh  Allegro Common  Lisp (MACL). That  didn't last
  long.
- 1988 ::  Coral was acquired  by Apple, who released  the Lisp under  the name
  Macintosh Common Lisp (MCL).
- 1994 ::  In the midst of  switching from the 68K  to the PowerPC CPU  for its
  Macintosh line, Apple transferred MCL to Digitool.
- 1995 :: Digitool completed the PowerPC port and released a PowerPC version of
  MCL.
- 1998  ::  Erann Gat  (now known  as Ron Garret)  of JPL  wanted to  develop a
  small-footprint Lisp  for use on  PowerPC-based robots and flight  systems. A
  source  license for  MCL was  acquired from  Digitool.  Gary  Byers ported  a
  version of the MCL compiler and runtime to VxWorks and LinuxPPC.
- 2007 ::  Alice  Hartley of Digitool announced that the  code for the original
  MCL would  be released  under an  open source license.   Largely in  order to
  avoid confusion  with this  newly open  sourced version  of MCL,  OpenMCL was
  renamed to Clozure CL.

** Armed Bear Common Lisp---JVM
- https://common-lisp.net/project/armedbear/
- [[https://github.com/slyrus/abcl][ABCL on GitHub]]


- Java has great GUI libraries
: <religious-statement>
:   but it's not the world's greatest programming language
: </religious-statement>

- Lisp on the other hand
: <religious-statement>
:   is the world's greatest programming language
: </religious-statement>
: but has no standard GUI libraries.

- Therefore:
: Write great applications using Java for your front-end GUI...
: backed with Lisp code and ...
: get the best of both worlds.


- ABCL ::
  - [[https://common-lisp.net/project/armedbear/][Armed Bear Common Lisp]]
  - A full implementation of the Common Lisp language
  - To interface with the JVM
  - features both an interpreter and a compiler, running in the JVM.
  - [[https://abcl.org/doc/abcl-user.html][User Documentation]]
  - [[https://abcl.org/releases/1.7.1/abcl-1.7.1.pdf][Armed Bear Common Lisp User Manual Version 1.7.1 July 2020]]
*** Install ABCL
- Go to [[https://abcl.org/][ABCL Home]] and download ABCL
- Build according to [[http://common-lisp.net/project/armedbear/doc/abcl-install-with-java.html][instructions]]
- or install using MacPorts: ~port install abcl~
- Add ~<abcl-dir>/dist/abcl.jar~ to your =CLASSPATH= for ABCL projects
- when installed with MacPorts, ~abcl.jar~ is at:
: /opt/local/share/java/abcl/abcl.jar

** GNU Common Lisp
- https://www.gnu.org/software/gcl/


- GNU Common Lisp ::
  - [[https://en.wikipedia.org/wiki/GNU_Common_Lisp][GNU Common Lisp]]
  - the GNU Project's ANSI Common Lisp compiler, an evolutionary
    development of Kyoto Common Lisp. It produces native object code
    by first generating C code and then calling a C compiler.

** CLISP
- https://clisp.sourceforge.io
- [[https://clisp.sourceforge.io/impnotes/clisp.html][CLISP Manual]]


- CLISP ::
  - [[https://clisp.sourceforge.io][CLISP Home]]
  - [[https://en.wikipedia.org/wiki/CLISP][GNU ANSI Common Lisp implementation]]
  - CLISP is an implementation of the programming language Common
    Lisp originally developed by Bruno Haible and Michael Stoll for
    the Atari ST

** CLASP---C++
- [[https://github.com/clasp-developers/clasp][CLASP on GitHub]]
- [[https://github.com/roswell/clasp][CLASP on Roswell on GitHub]]


"Bringing Common Lisp and C++ Together"

Clasp is an implementation of  Common Lisp primarily designed for compatibility
with C++-language programs and libraries.  Clasp conforms with the requirements
of =ANSI INCITS 226-1994= (R2004) with  some exceptions. Any deviation from the
standard  not   listed  there   is  a   bug,  and   should  be   reported  (see
"Contributing"). Clasp  is the project  of Dr. Christian  Schafmeister. Clasp's
source code is derived substantially from that  of [[*Embeddable Common Lisp---C][Embeddable Common Lisp]]. Code
from [[*Steel Bank Common Lisp][SBCL]] and SICL has been incorporated as well. Most notably, the compiler is
SICL's Cleavir compiler with some minor customizations.

Clasp is  a new Common  Lisp implementation that seamlessly  interoperates with
C++ libraries  and programs  using [[http://llvm.org][LLVM]]  for compilation  to native  code. This
allows Clasp  to take advantage  of a vast  array of preexisting  libraries and
programs, such as out of the  scientific computing ecosystem. Embedding them in
a  Common  Lisp environment  allows  you  to  make  use of  rapid  prototyping,
incremental  development,  and  other  capabilities that  make  it  a  powerful
language.

*** CLASP Manual
- https://github.com/clasp-developers/clasp/wiki/Manual

*** Build CLASP
- https://github.com/clasp-developers/clasp/wiki/Build-Instructions


#+texinfo: @heading MacOS installation of dependencies
While Clasp  requires a  specific release of  llvm and does  not use  the Xcode
version, it does use Xcode files.  You will need to first install Homebrew.

1. ~brew install cmake llvm@6 libffi bdw-gc gmp boost libunwind-headers sbcl~
2. git clone https://github.com/clasp-developers/clasp.git
3. If on mojave, after reinstalling xcode execute (from the gui):
   - ~/Library/Developer/CommandLineTools/Packages/macOS_SDK_headers_for_macOS_10.14.pkg~
     to get the headers in ~/usr/include/~
4. ~cd clasp~
5. ~./waf configure~; if ~./waf configure~ fails, see hint in linux instructions.
6. ~./waf build_cboehm~


The executables will be in ~clasp/build/boehm/cclasp-boehm~ and
~clasp/build/mps/cclasp-mps~

** Embeddable Common Lisp---C
- https://common-lisp.net/project/ecl/
- [[https://gitlab.com/embeddable-common-lisp/ecl/][ECL on GitLab]]
- [[https://common-lisp.net/project/ecl/static/manual/][ECL Manual]]


- Embeddable CL ::
  Compiles to C

** Spice List
- 

** Allegra Common Lisp

- Allegra CL ::
  Proprietary

** LispWorks

- LispWorks ::
  Proprietary

** SICL
- [[https://github.com/robert-strandh/SICL][SICL on GitHub]]


"A fresh implementation of Common Lisp"

SICL is a  new implementation of Common Lisp. It  is intentionally divided into
many  implementation-independent  modules that  are  written  in a  totally  or
near-totally portable way, so as  to allow other implementations to incorporate
these modules  from SICL,  rather than  having to  maintain their  own, perhaps
implementation-specific versions.

** Kyoto Common Lisp
- [[https://www.cs.cmu.edu/afs/cs/project/ai-repository/ai/lang/lisp/impl/kcl/0.html][KCL: Kyoto Common Lisp]]
- [[http://web.cecs.pdx.edu/~mperkows/=LISP/kcl][Frequently Asked Questions about KCL and AKCL]]
- https://en.wikipedia.org/wiki/Kyoto_Common_Lisp
- https://www.cs.cmu.edu/afs/cs/project/ai-repository/ai/lang/lisp/impl/kcl/kcl.faq
- http://www.aiai.ed.ac.uk/project/pub/packages/lisp/kcl/
- https://www.cs.cmu.edu/afs/cs/project/ai-repository/ai/lang/lisp/impl/kcl/kcl/broadcst.txt

** Corman Lisp
- https://github.com/sharplispers/cormanlisp


Corman  Lisp is  a Common  Lisp development  environment for  Microsoft Windows
operating systems running on Intel platforms.  Corman Lisp consists of a Common
Lisp  native   code  compiler  for   Intel  processors,  80x86   assembler  and
disassembler, incremental  linker and multi-window  text editor. It  requires a
system  running a  Microsoft  Windows  operating system  (such  as Windows  XP,
Windows 2000, Windows ME or Windows NT).  It is fully integrated with the Win32
API, and all the Windows API  functions are readily available from Lisp. Corman
Lisp incorporates  state-of-the-art compiler technology  to bring you  a Common
Lisp system unmatched on Windows platforms.

* Common Lisp Resources
** Common Lisp Documentation Resources
*** Common Lisp Specification
 "The ANSI Common  Lisp draft specification, parsed from  TeX sources, available
 as a Common Lisp library."

 - [[https://github.com/LispLang/ansi-spec][ANSI Common Lisp Specification]]

*** Common Lisp Hyper Spec
  - https://wiki.c2.com/?CommonLispHyperSpec


  The  CommonLisp Hyperspec  is  an HTMLified  version of  the  ANSI Common  Lisp
  language standard  (X3.226-1994). You can  view it  online or download  it from
  Xanalys (formerly Harlequin) at:

  - http://www.lispworks.com/reference/HyperSpec/
*** Common Lisp Cookbook
 - [[https://lispcookbook.github.io/cl-cookbook/][The Common Lisp Cookbook Home---GithubGroup Addendum]]
 - [[http://cl-cookbook.sourceforge.net/index.html][The Common Lisp Cookbook home---Sourceforge Version]]
 - [[https://lispcookbook.github.io/cl-cookbook/getting-started.html][The Common Lisp Cookbook – Getting started]]
 - [[https://github.com/LispCookbook/cl-cookbook][On GitHub]]


 This is a  collaborative project that aims to provide  for Common Lisp
 something similar to the Perl Cookbook published by O'Reilly

*** Common Lisp The Language 2nd Edition
 - http://www.cs.cmu.edu/afs/cs.cmu.edu/project/ai-repository/ai/html/cltl/clm/clm.html
 - https://wiki.c2.com/?CommonLispTheLanguage
 - [[https://www.cs.cmu.edu/Groups/AI/html/cltl/cltl2.html][Common Lisp the Language, 2nd Edition from CMU]]
 - [[https://icem.folkwang-uni.de/~finnendahl/cm_kurse/doc/cltl2/cltl2.html][Common Lisp the Language, 2nd Edition]]
 - Publisher: Digital Press; 2nd edition (June 15, 1990) ISBN 978-1555580414, ISBN 1555580416

*** ANSI Common Lisp---Paul Graham
 - http://www.paulgraham.com/acl.html
 - Prentice Hall, 1995, 432 pages, paperback. ISBN 0133708756.
 - https://wiki.c2.com/?AnsiCommonLisp


 ANSI  Common  Lisp  combines  an   introduction  to  Lisp  programming,  and  a
 convenient, up-to-date  reference manual for  ANSI Common Lisp.  Beginners will
 find  that  its  careful  explanations   and  interesting  examples  make  Lisp
 programming  easy  to  learn.  Professional  programmers  will  appreciate  its
 thorough, practical approach.

**** Features

 - An up-to-date reference manual for ANSI Common Lisp.
 - An in-depth look at object-oriented programming. Explains the Common Lisp
   Object System (CLOS), and also shows how to write your own object-oriented
   language.
 - Over 20 substantial examples, including programs for ray-tracing, text
   generation, pattern-matching, logical inference, generating HTML, sorting and
   searching, file I/O, compression, and date arithmetic.
 - Special attention to critical concepts, including prefix syntax, code
   vs. data, recursion, functional programming, types, implicit pointers,
   dynamic allocation, closures, macros, class precedence, and generic functions
   vs. message-passing.
 - A complete guide to optimization.
 - The clearest and most thorough explanation of macros in any introductory
   book.
 - Examples that illustrate Lisp programming styles, including rapid
   prototyping, bottom-up programming, object-oriented programming, and embedded
   languages.
 - An appendix on debugging, with examples of common errors.

*** Lisp Documentation Resources
  - Documentation :: https://common-lisp.net/documentation

  - QuickDocs :: http://quickdocs.org
    Ready and Up-to-Date Documentation for All Common Lisp Projects.

  - QuickRef :: https://quickref.common-lisp.net/index-per-library.html
    Reference manuals for Quicklisp libraries

  - Common Lisp in the Wild :: https://www.darkchestnut.com/book-common-lisp-application-deployment/

  - Books on CL :: https://cliki.net/Lisp+Books

  - The CL Cookbook :: https://lispcookbook.github.io/cl-cookbook/

  - The CL Ecosystem 2015 ::  https://borretti.me/article/common-lisp-sotu-2015

*** Articulate Common Lisp
 - http://articulate-lisp.com


 How to write Common Lisp in 2018 - an initiation manual for the
 uninitiated.
** Common Lisp Help System
*** Apropos
    #+findex:apropos
 Common Lisp defines 978 symbols. There  are probably hundreds of others as well
 for language extensions,  libraries, a graphical user interface,  etc. You will
 not remember all  of the names, but  you will probably remember  parts of them.
 Once you  have a good  guess at a  part of  the name, you  can find all  of the
 matching names by using a tool called ~APROPOS~.

 #+begin_src sh
 $ sbcl
 ,* (apropos "MAP" :cl)
 MAP (fbound)
 MAP-INTO (fbound)
 MAPC (fbound)
 MAPCAN (fbound)
 MAPCAR (fbound)
 MAPCON (fbound)
 MAPHASH (fbound)
 MAPL (fbound)
 MAPLIST (fbound)
 #+end_src

 #+begin_src sh
 $ clisp
 [1]> (apropos "MAP" :cl)
 MAP                                        function
 MAP-DEPENDENTS                             function
 MAP-INTO                                   function
 MAPC                                       function
 MAPCAN                                     function
 MAPCAR                                     function
 MAPCON                                     function
 MAPHASH                                    function
 MAPL                                       function
 MAPLIST                                    function
 #+end_src

 APROPOS expects a string or a symbol --- this provides the fragment of the name
 that you’d like to find. An  optional second argument designates a package; use
 it if you’d like  to limit your search to the symbols  in a particular package.
 The package designator can be a string  or symbol matching the name or nickname
 of a package  or it can be the  package object itself. If you  omit the package
 designator, then APROPOS will search for symbols in all packages.

*** Describe
    #+findex:describe
 Once you know the name of a symbol, you can get additional information by using
 the ~DESCRIBE~ function.

 ~DESCRIBE~ =object=  =stream= sends information  about an =object= to  a stream
 (=standard-output= by default). =object= can be a symbol, string, or function.

 ~DESCRIBE~  prints,   to  the  stream  in   the  variable  =*standard-output*=,
 information  about the  object. Sometimes  it will  describe something  that it
 finds  inside   something  else;  such  recursive   descriptions  are  indented
 appropriately. For instance,  ~DESCRIBE~ of a symbol will  exhibit the symbol's
 value,  its   definition,  and  each   of  its  properties.  ~DESCRIBE~   of  a
 floating-point number will exhibit its internal representation in a way that is
 useful for tracking  down round-off errors and the like.  The nature and format
 of the output is implementation-dependent.

 The output  is sent  to the specified  stream, which defaults  to the  value of
 =*standard-output*=; the stream may also be =nil= (meaning =*standard-output*=)
 or  =t= (meaning  =*terminal-io*=). ~DESCRIBE~  is forbidden  to prompt  for or
 require user input when given exactly one argument.

 #+begin_src sh
 $ sbcl

 ,* (describe 'mapl)
 COMMON-LISP:MAPL
   [symbol]

 MAPL names a compiled function:
   Lambda-list: (FUNCTION LIST &REST SB-IMPL::MORE-LISTS)
   Dynamic-extent arguments: positional=(0)
   Declared type: (FUNCTION ((OR FUNCTION SYMBOL) LIST &REST LIST)
                   (VALUES LIST &OPTIONAL))
   Derived type: (FUNCTION (T T &REST T) (VALUES T &OPTIONAL))
   Documentation:
     Apply FUNCTION to successive tuples of CDRs of LIST and MORE-LISTS.
     Return LIST.
   Known attributes: call, foldable
   Source file: SYS:SRC;CODE;LIST.LISP
 #+end_src

*** Documentation
    #+findex:documentation
 The  generic   function  ~DOCUMENTATION~   returns  the   documentation  string
 associated  with the  given object  if it  is available;  otherwise it  returns
 =nil=.  The  ~DOCUMENTATION~ function  gives  you  access to  the  programmer’s
 innermost thoughts.

 The ~DOCUMENTATION~ function expects two arguments.  The first is an object for
 which you wish  to retrieve documentation, or a symbol  naming that object. The
 second is  a symbol designating the  kind of documentation (there  are several)
 you wish to retrieve.

 - variable :: defvar, defparameter, defconstant
 - function :: defun, defmacro, special forms
 - structure :: defstruct
 - type :: deftype
 - setf :: defsetf
 - compiler-macro :: define-compiler-macro
 - method-combination :: define-method-combination

*** Inspect
    #+findex:inspect
 ~INSPECT~  is  an  interactive  version   of  ~DESCRIBE~.  The  nature  of  the
 interaction is  implementation-dependent, but  the purpose  of ~INSPECT~  is to
 make it easy to wander through  a data structure, examining and modifying parts
 of it.

 ~INSPECT~  is like  ~DESCRIBE~,  but  instead of  printing  the information  it
 presents the information in some  kind of interactive display; typically either
 a  command loop  in the  current listener  or a  new window  with its  own user
 interface.

 Implementations are encouraged to respond to the  typing of =?= or a ``help key''
 by providing help, including a list of commands.
** Lisp-Lang
- [[https://lisp-lang.org][Home]]
*** Recommended Libraries
- https://lisp-lang.org/wiki/article/recommended-libraries

** Common-Lisp dot Net
 - https://common-lisp.net


This site is one among many gateways to Common Lisp. Its goal is to
provide the Common Lisp community with development resources and to
work as a starting point for new programmers.

*** Getting Started in Common Lisp
 - https://common-lisp.net/downloads

*** Common Lisp Documentation
 - https://common-lisp.net/documentation

** Planet Lisp
- http://planet.lisp.org


Planet Lisp is  a meta blog that collects the  contents of various Lisp-related
blogs.

** CLiki
- https://cliki.net


CLiki  is a  Common  Lisp wiki  hosted  by The  Common  Lisp Foundation.  CLiki
contains resources for learning about and using the programming language Common
Lisp, and information about DFSG-compliant  free software implemented in Common
Lisp.

** Common Lisp Books
"Most of Lisp books in one place."

- https://www.pinterest.com/vseloved/lisp-books/

- https://wiki.c2.com/?DefinitiveCommonLispBooks

- [[http://metamodular.com/Common-Lisp/bibliography.html][Bibliography of documents related to Common Lisp]]

  - Peter Seibel, Practical Common Lisp ::

    This is an  excellent introduction to the Common Lisp  language. Instead of
    focusing on mechanisms the way most  other books do, this book is organized
    around practical examples related to contemporary problems.

  - Edmund Weitz, Common Lisp Recipes ::

    This is a reference book of advanced CL techniques.

    - Errata : http://weitz.de/cl-recipes/errata.pdf
    - Download Code : http://weitz.de/cl-recipes/code.zip

    This book is a collection of solutions to problems and answers to questions
    you are likely to encounter  when writing real-world applications in Common
    Lisp. Written  by an  author who  has used Common  Lisp in  many successful
    commercial projects  over more  than a  decade, this  book covers  areas as
    diverse  as   web  programming,   databases,  graphical   user  interfaces,
    integration with  other programming languages, multi-threading,  and mobile
    devices as  well as debugging techniques  and optimization, to name  just a
    few. It is also  the first Common Lisp book to  tackle such advanced topics
    as  environment  access,  logical  pathnames,  Gray  streams,  delivery  of
    executables, pretty  printing, setf expansions,  or changing the  syntax of
    Common Lisp.

  - Paul Graham, ANSI Common Lisp, Prentice Hall ::

    This book is  an introduction to the Common Lisp  programming language. The
    programming style of Paul  Graham is a bit different from  the one you will
    find in most  modern Common Lisp programs,  but this fact is  not likely to
    make a big difference to the debutant.

  - Paul Graham, On Lisp, Prentice Hall ::

    This book is  about advanced programming Common Lisp,  and specifically how
    to use the Common Lisp language  to create Domain Specific Languages (DSLs)
    using a technique called embedded  languages. This entire book is available
    as a free download.

  - Sonya E. Keene, Object-Oriented Programming  in Common Lisp, Addison Wesley ::

    The Common  Lisp object system (CLOS) is quite  different from, and more
    power than  that of  other object-oriented languages.  This books  gives an
    introduction to object-oriented  programming using CLOS. The book  is a bit
    old,  and this  is  particularly obvious  in the  examples  given, but  the
    mechanisms discussed have not changed, of course.

  - Peter  Norvig,  [[https://github.com/norvig/paip-lisp][Paradigms  of  Artificial  Intelligence  Programming:]]  Case Studies in Common Lisp, Morgan Kaufmann  ::

    - https://wiki.c2.com/?ParadigmsOfArtificialIntelligenceProgramming

    This  is a  very  good programming  book.  Peter Norvig  shows  how to  use
    advanced  features of  the  Common Lisp  language to  program  some of  the
    traditional problems  of Artificial Intelligence (search  problems, natural
    languages,  etc.), but  it is  definitely not  a book  about AI,  but about
    programming techniques, so  it is worth reading for everyone,  and not only
    for those who are interested in AI.

    - [[http://norvig.com/Lisp-retro.html][A Retrospective on Paradigms of AI Programming]]

  - Gregor  Kiczales, Jim  des  Rivières,  Daniel G.  Bobrow,  The  Art of  the Metaobject Protocol ::

    In this book, the authors show how the Common Lisp Object System (CLOS) can
    be  defined in  a meta-circular  way, i.e.,  as an  object-oriented program
    using CLOS. Though this might sound like  a cute exercise with little or no
    practical use, this is definitely not the case, because that is in fact how
    CLOS  is written.  The  authors also  discuss  bootstrapping problems  that
    invariably occur with  such systems, and how these problems  were solved in
    their  implementation of  CLOS  called PCL.  The second  part  of the  book
    contains a complete  specification of CLOS, and that part  is available for
    free as online html.

  - David Touretzky, COMMON LISP: A Gentle Introduction to Symbolic Calculation ::

    The 1990 edition  of this book is available as download  for free. For a
    long time  it was out  of print, but  now it is  back in print  "with minor
    revisions".

  - Guy L. Steele, [[https://www.cs.cmu.edu/Groups/AI/html/cltl/cltl2.html][Common Lisp the Language, second Edition]] ::

    This book  is as close to  a reference manual  for Common Lisp at  it gets.
    Unfortunately,  the book  was  published before  the  Common Lisp  standard
    process was entirely finished, and there are some discrepancies between the
    contents of the book and what finally ended up in the standard. Having said
    that, I  think it  is a  great book, and  it explains  many things  in much
    greater depth than what the  HyperSpec is able to communicate. Furthermore,
    the entire books is available to download for free, or to consult as HTML.

  - Stuart C. Shapiro Common Lisp---An Interactive Approach ::

    The purpose of  this book is to  help you learn the Common  Lisp dialect of
    the programming  language Lisp (LISt Processing  language) by experimenting
    with it via an interactive computer  terminal. The recommended method is to
    read a  chapter or two,  sit down  at a terminal  and try the  examples and
    exercises  of those  chapters, leave  the terminal  and go  on to  the next
    chapters, and so on.  The book is  intended to be a self-paced study guide,
    requiring additional information from an instructor, manual, consultant, or
    friend only to fill in the details  of the local operating system and a few
    implementation-dependent features.

    In this edition, ..., I am  strictly following the Common Lisp standard set
    out in  Guy L.   Steele, Jr.’s  COMMON LISP:  The Language,  Second Edition
    (Bedford, MA: Digital Press, 1990).

*** Practical Common Lisp by Peter Seibel
- [[https://wiki.c2.com/?PracticalCommonLisp][About Practical Common Lisp]]
- [[http://www.gigamonkeys.com/book/][Practical Common Lisp in HTML]]

*** ANSI Common Lisp by Paul Graham
- [[https://wiki.c2.com/?AnsiCommonLisp][About ANSI Common Lisp]]
- https://courses.cs.northwestern.edu/325/readings/graham/graham-notes.html

*** Common Lisp---A Gentle Introduction to Symbolic Computation
- https://www.cs.cmu.edu/~dst/LispBook/book.pdf
- https://wiki.c2.com/?CommonLispaGentleIntroductionToSymbolicComputation
- http://www.cs.cmu.edu/~dst/LispBook/index.html

*** On Lisp by Paul Graham
- http://www.paulgraham.com/onlisptext.html
- http://www.paulgraham.com/lisp.html
- https://wiki.c2.com/?OnLisp
- https://cliki.net/On+Lisp
- https://bitbucket.org/blevyq/onlisp/src/master/
- https://cliki.net/PgUtils a package containing all the utility functions and
  macros from On Lisp

"This is simply the best book written about any computing topic that I
have ever come  across. Even if you  don't know lisp, you  can get the
general gist of this book and enjoy it."

- https://code.google.com/archive/p/onlisp/
- https://code.google.com/archive/p/onlisp/downloads

  #+texinfo:@ifnothtml
  [[./resouces/src/onlisp.html]]
  #+texinfo:@end ifnothtml
  #+texinfo:@ifhtml
  [[../resources/src/onlisp.html]]
  #+texinfo:@end ifhtml


- [[https://github.com/DalekBaldwin/on-lisp][DalekBaldwin's on-lisp GitHub repo]]

  This repository  contains a version of  the code from /On  Lisp/ modified for
  use in  modern Lisp environments.  Paul  Graham's original code can  be found
  [[http://ep.yimg.com/ty/cdn/paulgraham/onlisp.lisp][here]].  The PDF  file of the book  available from Paul Graham's  site isn't so
  great for reading on a screen. A version with smaller margins and the missing
  figures re-added can be  found [[http://www.lurklurk.org/onlisp/onlisp.html][here]] and [[http://www.lurklurk.org/onlisp/onlisp.pdf][here]].

  Among other necessary changes, this version:

  - Updates code that relied on pre-ANSI built-ins
  - Includes the bug fixes mentioned on pg's errata page
  - Organizes everything into a modern system structure with ASDF and
    named-readtables
  - Adapts most of the example code into test suites
  - Makes it easy to load each version of the query system, Prolog system, and
    OOP system separately


  It was  written to  follow along  with the  book page  by page  and catalogue
  dependencies between the chapters, which become quite complex toward the end.

  The simplest way to  get it up and running is to  install Quicklisp and clone
  this repository into your quicklisp/local-projects directory.


- [[https://github.com/showgood/onlisp][showgood's onlisp org-mode format on GitHub]]

  This is the  org-mode format version of  the on lisp book from  Paul Graham I
  adopted       from       the       online       free       version       from
  https://code.google.com/archive/p/onlisp/.

*** Paradigms Of Artificial Intelligence Programming by Peter Norvig
- https://wiki.c2.com/?ParadigmsOfArtificialIntelligenceProgramming
- https://github.com/norvig/paip-lisp

*** Common Lisp, the Language 2nd Edition by Guy L. Steele, Jr.

Useful as  a reference book. However,  this isn't a good  tutorial for
learning CommonLisp--it assumes  that the reader is  familiar with the
language.

- https://wiki.c2.com/?CommonLispTheLanguage
- http://www.cs.cmu.edu/Groups/AI/html/cltl/cltl2.html
  This document contains the complete text of the book

*** The Common Lisp Cookbook
- https://lispcookbook.github.io/cl-cookbook/getting-started.html

*** Successful Lisp---How to Understand and Use Common Lisp
    :PROPERTIES:
    :author:   David Lamkins
    :cite:     http://ebixio.com/online_docs/SuccessfulLisp.pdf
    :END:
- [[http://ebixio.com/online_docs/SuccessfulLisp.pdf][Successful Lisp HTML]]

** Lisp Tutorials
*** The Little Lisper
- [[https://7chan.org/pr/src/__The_Little_LISPer___3rd_Edition.pdf][The Little Lisper (3rd Edition)]]
  
*** Iwanna Learn Lisp
 - https://wiki.c2.com/?IwannaLearnLisp

*** Lisp Quickstart
 - https://cs.gmu.edu/~sean/lisp/LispTutorial.html


Lisp is a  deep language with many  unusual and powerful features.  The goal of
this tutorial is not to teach you  many of those powerful features: rather it's
to teach you just enough of Lisp that  you can get up and coding quickly if you
have a previous background in a procedural  language such as C or Java. Notably
this tutorial  does not teach  macros, CLOS,  the condition system,  much about
packages and symbols, or very much I/O.

**** Running Lisp
On your laptop you have several options for running Lisp:

- ~sbcl~
- ~clisp~
- ~ccl~

***** Run SBCL

#+begin_quote
$ sbcl

This is SBCL 2.0.9, an implementation of ANSI Common Lisp.
More information about SBCL is available at <http://www.sbcl.org/>.

SBCL is free software, provided as is, with absolutely no warranty.
It is mostly in the public domain; some portions are provided under
BSD-style licenses.  See the CREDITS and COPYING files in the
distribution for more information.
#+end_quote

***** Run CLISP
#+begin_quote
$ clisp

  i i i i i i i       ooooo    o        ooooooo   ooooo   ooooo
  I I I I I I I      8     8   8           8     8     o  8    8
  I  \ `+' /  I      8         8           8     8        8    8
   \  `-+-'  /       8         8           8      ooooo   8oooo
    `-__|__-'        8         8           8           8  8
        |            8     o   8           8     o     8  8
  ------+------       ooooo    8oooooo  ooo8ooo   ooooo   8

Welcome to GNU CLISP 2.49.92 (2018-02-18) <http://clisp.org/>
#+end_quote

***** Run CCL
#+begin_quote
$ ccl

Clozure Common Lisp Version 1.12  DarwinX8664

For more information about CCL, please see http://ccl.clozure.com.

CCL is free software.  It is distributed under the terms of the Apache
Licence, Version 2.0.
#+end_quote

**** Breaking Lisp
Pressing =Control-C=  in Lisp halts  whatever is presently running  and returns
you to the command line. After  you press =Control-C=, the command line changes
to a  "subsidiary" command line  to reflect  that you are  in a break  or error
condition. Kinda like pressing =Control-C=  in a debugger. These conditions can
be stacked: if you  keep working while in a condition, and  then get in another
condition and so on, you're piling up conditions on a stack.

#+begin_example
$ sbcl

,* (loop)
^C
debugger invoked on a SB-SYS:INTERACTIVE-INTERRUPT in thread
#<THREAD "main thread" RUNNING {1001890143}>:
  Interactive interrupt at #x52BB2ED0.

Type HELP for debugger help, or (SB-EXT:EXIT) to exit from SBCL.

restarts (invokable by number or by possibly-abbreviated name):
  0: [CONTINUE] Return from SB-UNIX:SIGINT.
  1: [ABORT   ] Exit debugger, returning to top level.

((LAMBDA ()))
   source: (PROGN)
#+end_example

#+begin_example
$ clisp

[1]> (loop)
^C
,** - Continuable Error
EVAL: User break
If you continue (by typing 'continue'): Continue execution
The following restarts are also available:
ABORT          :R1      Abort main loop
#+end_example

Just like in a  debugger, at any break or error condition, you  have a bunch of
options (like  examining the stack, changing  what the return value  should be,
etc.) You  can even continue the  infinite loop we  just broke out of.  But you
probably just  want to escape. The  easiest option is  to escape out of  all of
your error conditions, right back up to the top.

- SBCL :: In SBCL on your laptop, this is done by typing :top or :n (where n is
  the largest number presented to you -- here it's 1).

- CLISP :: In clisp on zeus, you'd type :R1
**** Quitting Lisp
Type ~(quit)~ to exit from Lisp.
*** Brief Guide to CLOS
- http://www.aiai.ed.ac.uk/project/pub/packages/lisp/random/clos-guide
*** Learn X in Y Minutes Where X=Common Lisp
- https://learnxinyminutes.com/docs/common-lisp/


#+name:commonlisp.lisp
#+header: :export code
#+begin_src lisp

;;;-----------------------------------------------------------------------------
;;; 0. Syntax
;;;-----------------------------------------------------------------------------

;;; General form

;;; CL has two fundamental pieces of syntax: ATOM and S-EXPRESSION.
;;; Typically, grouped S-expressions are called `forms`.

10            ; an atom; it evaluates to itself
:thing        ; another atom; evaluating to the symbol :thing
t             ; another atom, denoting true
(+ 1 2 3 4)   ; an s-expression
'(4 :foo t)   ; another s-expression


;;; Comments

;;; Single-line comments start with a semicolon; use four for file-level
;;; comments, three for section descriptions, two inside definitions, and one
;;; for single lines. For example,

;;;; life.lisp

;;; Foo bar baz, because quu quux. Optimized for maximum krakaboom and umph.
;;; Needed by the function LINULUKO.

(defun meaning (life)
  "Return the computed meaning of LIFE"
  (let ((meh "abc"))
    ;; Invoke krakaboom
    (loop :for x :across meh
       :collect x)))                    ; store values into x, then return it

;;; Block comments, on the other hand, allow for free-form comments. They are
;;; delimited with #| and |#

#| This is a block comment which
   can span multiple lines and
    #|
       they can be nested!
    |#
|#


;;; Environment

;;; A variety of implementations exist; most are standards-conformant. SBCL
;;; is a good starting point. Third party libraries can be easily installed with
;;; Quicklisp

;;; CL is usually developed with a text editor and a Read Eval Print
;;; Loop (REPL) running at the same time. The REPL allows for interactive
;;; exploration of the program while it is running "live".


;;;-----------------------------------------------------------------------------
;;; 1. Primitive datatypes and operators
;;;-----------------------------------------------------------------------------

;;; Symbols

'foo ; => FOO  Notice that the symbol is upper-cased automatically.

;;; INTERN manually creates a symbol from a string.

(intern "AAAA")        ; => AAAA
(intern "aaa")         ; => |aaa|

;;; Numbers

9999999999999999999999 ; integers
#b111                  ; binary => 7
#o111                  ; octal => 73
#x111                  ; hexadecimal => 273
3.14159s0              ; single
3.14159d0              ; double
1/2                    ; ratios
#C(1 2)                ; complex numbers

;;; Function application are written as (f x y z ...) where f is a function and
;;; x, y, z, ... are the arguments.

(+ 1 2)                ; => 3

;;; If you want to create literal data, use QUOTE to prevent it from being
;;; evaluated

(quote (+ 1 2))        ; => (+ 1 2)
(quote a)              ; => A

;;; The shorthand for QUOTE is '

'(+ 1 2)               ; => (+ 1 2)
'a                     ; => A

;;; Basic arithmetic operations

(+ 1 1)                ; => 2
(- 8 1)                ; => 7
(* 10 2)               ; => 20
(expt 2 3)             ; => 8
(mod 5 2)              ; => 1
(/ 35 5)               ; => 7
(/ 1 3)                ; => 1/3
(+ #C(1 2) #C(6 -4))   ; => #C(7 -2)

;;; Booleans

t                      ; true; any non-NIL value is true
nil                    ; false; also, the empty list: ()
(not nil)              ; => T
(and 0 t)              ; => T
(or 0 nil)             ; => 0

;;; Characters

#\A                    ; => #\A
#\λ                    ; => #\GREEK_SMALL_LETTER_LAMDA
#\u03BB                ; => #\GREEK_SMALL_LETTER_LAMDA

;;; Strings are fixed-length arrays of characters

"Hello, world!"
"Benjamin \"Bugsy\" Siegel"   ; backslash is an escaping character

;;; Strings can be concatenated

(concatenate 'string "Hello, " "world!") ; => "Hello, world!"

;;; A string can be treated like a sequence of characters

(elt "Apple" 0) ; => #\A

;;; FORMAT is used to create formatted output, which ranges from simple string
;;; interpolation to loops and conditionals. The first argument to FORMAT
;;; determines where will the formatted string go. If it is NIL, FORMAT
;;; simply returns the formatted string as a value; if it is T, FORMAT outputs
;;; to the standard output, usually the screen, then it returns NIL.

(format nil "~A, ~A!" "Hello" "world")   ; => "Hello, world!"
(format t "~A, ~A!" "Hello" "world")     ; => NIL


;;;-----------------------------------------------------------------------------
;;; 2. Variables
;;;-----------------------------------------------------------------------------

;;; You can create a global (dynamically scoped) variable using DEFVAR and
;;; DEFPARAMETER. The variable name can use any character except: ()",'`;#|\

;;; The difference between DEFVAR and DEFPARAMETER is that re-evaluating a
;;; DEFVAR expression doesn't change the value of the variable. DEFPARAMETER,
;;; on the other hand, does.

;;; By convention, dynamically scoped variables have earmuffs in their name.

(defparameter *some-var* 5)
*some-var* ; => 5

;;; You can also use unicode characters.
(defparameter *AΛB* nil)

;;; Accessing a previously unbound variable results in an UNBOUND-VARIABLE
;;; error, however it is defined behavior. Don't do it.

;;; You can create local bindings with LET. In the following snippet, `me` is
;;; bound to "dance with you" only within the (let ...). LET always returns
;;; the value of the last `form` in the LET form.

(let ((me "dance with you")) me) ; => "dance with you"


;;;-----------------------------------------------------------------------------;
;;; 3. Structs and collections
;;;-----------------------------------------------------------------------------;


;;; Structs

(defstruct dog name breed age)
(defparameter *rover*
    (make-dog :name "rover"
              :breed "collie"
              :age 5))
*rover*            ; => #S(DOG :NAME "rover" :BREED "collie" :AGE 5)
(dog-p *rover*)    ; => T
(dog-name *rover*) ; => "rover"

;;; DOG-P, MAKE-DOG, and DOG-NAME are all automatically created by DEFSTRUCT


;;; Pairs

;;; CONS constructs pairs. CAR and CDR return the head and tail of a CONS-pair.

(cons 'SUBJECT 'VERB)         ; => '(SUBJECT . VERB)
(car (cons 'SUBJECT 'VERB))   ; => SUBJECT
(cdr (cons 'SUBJECT 'VERB))   ; => VERB


;;; Lists

;;; Lists are linked-list data structures, made of CONS pairs and end with a
;;; NIL (or '()) to mark the end of the list

(cons 1 (cons 2 (cons 3 nil)))     ; => '(1 2 3)

;;; LIST is a convenience variadic constructor for lists

(list 1 2 3)                       ; => '(1 2 3)

;;; When the first argument to CONS is an atom and the second argument is a
;;; list, CONS returns a new CONS-pair with the first argument as the first
;;; item and the second argument as the rest of the CONS-pair

(cons 4 '(1 2 3))                  ; => '(4 1 2 3)

;;; Use APPEND to join lists

(append '(1 2) '(3 4))             ; => '(1 2 3 4)

;;; Or CONCATENATE

(concatenate 'list '(1 2) '(3 4))  ; => '(1 2 3 4)

;;; Lists are a very central type, so there is a wide variety of functionality for
;;; them, a few examples:

(mapcar #'1+ '(1 2 3))             ; => '(2 3 4)
(mapcar #'+ '(1 2 3) '(10 20 30))  ; => '(11 22 33)
(remove-if-not #'evenp '(1 2 3 4)) ; => '(2 4)
(every #'evenp '(1 2 3 4))         ; => NIL
(some #'oddp '(1 2 3 4))           ; => T
(butlast '(subject verb object))   ; => (SUBJECT VERB)


;;; Vectors

;;; Vector's literals are fixed-length arrays

#(1 2 3) ; => #(1 2 3)

;;; Use CONCATENATE to add vectors together

(concatenate 'vector #(1 2 3) #(4 5 6)) ; => #(1 2 3 4 5 6)


;;; Arrays

;;; Both vectors and strings are special-cases of arrays.

;;; 2D arrays

(make-array (list 2 2))         ; => #2A((0 0) (0 0))
(make-array '(2 2))             ; => #2A((0 0) (0 0))
(make-array (list 2 2 2))       ; => #3A(((0 0) (0 0)) ((0 0) (0 0)))

;;; Caution: the default initial values of MAKE-ARRAY are implementation-defined.
;;; To explicitly specify them:

(make-array '(2) :initial-element 'unset)  ; => #(UNSET UNSET)

;;; To access the element at 1, 1, 1:

(aref (make-array (list 2 2 2)) 1 1 1)     ;  => 0
;;; This value is implementation-defined:
;;; NIL on ECL, 0 on SBCL and CCL.

;;; Adjustable vectors

;;; Adjustable vectors have the same printed representation as
;;; fixed-length vector's literals.

(defparameter *adjvec* (make-array '(3) :initial-contents '(1 2 3)
                                   :adjustable t :fill-pointer t))
*adjvec* ; => #(1 2 3)

;;; Adding new elements

(vector-push-extend 4 *adjvec*)   ; => 3
*adjvec*                          ; => #(1 2 3 4)


;;; Sets, naively, are just lists:

(set-difference '(1 2 3 4) '(4 5 6 7))   ; => (3 2 1)
(intersection '(1 2 3 4) '(4 5 6 7))     ; => 4
(union '(1 2 3 4) '(4 5 6 7))            ; => (3 2 1 4 5 6 7)
(adjoin 4 '(1 2 3 4))                    ; => (1 2 3 4)

;;; However, you'll need a better data structure than linked lists when working
;;; with larger data sets

;;; Dictionaries are implemented as hash tables.

;;; Create a hash table

(defparameter *m* (make-hash-table))

;;; Set value

(setf (gethash 'a *m*) 1)

;;; Retrieve value

(gethash 'a *m*) ; => 1, T

;;; CL expressions have the ability to return multiple values.

(values 1 2) ; => 1, 2

;;; which can be bound with MULTIPLE-VALUE-BIND

(multiple-value-bind (x y)
    (values 1 2)
  (list y x))

; => '(2 1)

;;; GETHASH is an example of a function that returns multiple values. The first
;;; value it return is the value of the key in the hash table; if the key is
;;; not found it returns NIL.

;;; The second value determines if that key is indeed present in the hash
;;; table. If a key is not found in the table it returns NIL. This behavior
;;; allows us to check if the value of a key is actually NIL.

;;; Retrieving a non-present value returns nil

(gethash 'd *m*) ;=> NIL, NIL

;;; You can provide a default value for missing keys

(gethash 'd *m* :not-found) ; => :NOT-FOUND

;;; Let's handle the multiple return values here in code.

(multiple-value-bind (a b)
    (gethash 'd *m*)
  (list a b))
; => (NIL NIL)

(multiple-value-bind (a b)
    (gethash 'a *m*)
  (list a b))
; => (1 T)


;;;-----------------------------------------------------------------------------
;;; 3. Functions
;;;-----------------------------------------------------------------------------

;;; Use LAMBDA to create anonymous functions. Functions always returns the
;;; value of the last expression. The exact printable representation of a
;;; function varies between implementations.

(lambda () "Hello World") ; => #<FUNCTION (LAMBDA ()) {1004E7818B}>

;;; Use FUNCALL to call anonymous functions

(funcall (lambda () "Hello World"))   ; => "Hello World"
(funcall #'+ 1 2 3)                   ; => 6

;;; A call to FUNCALL is also implied when the lambda expression is the CAR of
;;; an unquoted list

((lambda () "Hello World"))           ; => "Hello World"
((lambda (val) val) "Hello World")    ; => "Hello World"

;;; FUNCALL is used when the arguments are known beforehand. Otherwise, use APPLY

(apply #'+ '(1 2 3))   ; => 6
(apply (lambda () "Hello World") nil) ; => "Hello World"

;;; To name a function, use DEFUN

(defun hello-world () "Hello World")
(hello-world) ; => "Hello World"

;;; The () in the definition above is the list of arguments

(defun hello (name) (format nil "Hello, ~A" name))
(hello "Steve") ; => "Hello, Steve"

;;; Functions can have optional arguments; they default to NIL

(defun hello (name &optional from)
  (if from
      (format t "Hello, ~A, from ~A" name from)
      (format t "Hello, ~A" name)))

(hello "Jim" "Alpacas")       ; => Hello, Jim, from Alpacas

;;; The default values can also be specified

(defun hello (name &optional (from "The world"))
   (format nil "Hello, ~A, from ~A" name from))

(hello "Steve")               ; => Hello, Steve, from The world
(hello "Steve" "the alpacas") ; => Hello, Steve, from the alpacas

;;; Functions also have keyword arguments to allow non-positional arguments

(defun generalized-greeter (name &key (from "the world") (honorific "Mx"))
  (format t "Hello, ~A ~A, from ~A" honorific name from))

(generalized-greeter "Jim")
; => Hello, Mx Jim, from the world

(generalized-greeter "Jim" :from "the alpacas you met last summer" :honorific "Mr")
; => Hello, Mr Jim, from the alpacas you met last summer


;;;-----------------------------------------------------------------------------
;;; 4. Equality
;;;-----------------------------------------------------------------------------

;;; CL has a sophisticated equality system. Some are covered here.

;;; For numbers, use `='
(= 3 3.0)               ; => T
(= 2 1)                 ; => NIL

;;; For object identity (approximately) use EQL
(eql 3 3)               ; => T
(eql 3 3.0)             ; => NIL
(eql (list 3) (list 3)) ; => NIL

;;; for lists, strings, and bit-vectors use EQUAL
(equal (list 'a 'b) (list 'a 'b)) ; => T
(equal (list 'a 'b) (list 'b 'a)) ; => NIL


;;;-----------------------------------------------------------------------------
;;; 5. Control Flow
;;;-----------------------------------------------------------------------------

;;; Conditionals

(if t                ; test expression
    "this is true"   ; then expression
    "this is false") ; else expression
; => "this is true"

;;; In conditionals, all non-NIL values are treated as true

(member 'Groucho '(Harpo Groucho Zeppo)) ; => '(GROUCHO ZEPPO)
(if (member 'Groucho '(Harpo Groucho Zeppo))
    'yep
    'nope)
; => 'YEP

;;; COND chains a series of tests to select a result
(cond ((> 2 2) (error "wrong!"))
      ((< 2 2) (error "wrong again!"))
      (t 'ok)) ; => 'OK

;;; TYPECASE switches on the type of the value
(typecase 1
  (string :string)
  (integer :int))
; => :int


;;; Looping

;;; Recursion

(defun fact (n)
  (if (< n 2)
      1
    (* n (fact(- n 1)))))

(fact 5) ; => 120

;;; Iteration

(defun fact (n)
  (loop :for result = 1 :then (* result i)
     :for i :from 2 :to n
     :finally (return result)))

(fact 5) ; => 120

(loop :for x :across "abcd" :collect x)
; => (#\a #\b #\c #\d)

(dolist (i '(1 2 3 4))
  (format t "~A" i))
; => 1234


;;;-----------------------------------------------------------------------------
;;; 6. Mutation
;;;-----------------------------------------------------------------------------

;;; Use SETF to assign a new value to an existing variable. This was
;;; demonstrated earlier in the hash table example.

(let ((variable 10))
    (setf variable 2))
; => 2

;;; Good Lisp style is to minimize the use of destructive functions and to avoid
;;; mutation when reasonable.


;;;-----------------------------------------------------------------------------
;;; 7. Classes and objects
;;;-----------------------------------------------------------------------------

;;; No more animal classes. Let's have Human-Powered Mechanical
;;; Conveyances.

(defclass human-powered-conveyance ()
  ((velocity
    :accessor velocity
    :initarg :velocity)
   (average-efficiency
    :accessor average-efficiency
   :initarg :average-efficiency))
  (:documentation "A human powered conveyance"))

;;; The arguments to DEFCLASS, in order are:
;;; 1. class name
;;; 2. superclass list
;;; 3. slot list
;;; 4. optional specifiers

;;; When no superclass list is set, the empty list defaults to the
;;; standard-object class. This *can* be changed, but not until you
;;; know what you're doing. Look up the Art of the Metaobject Protocol
;;; for more information.

(defclass bicycle (human-powered-conveyance)
  ((wheel-size
    :accessor wheel-size
    :initarg :wheel-size
    :documentation "Diameter of the wheel.")
   (height
    :accessor height
    :initarg :height)))

(defclass recumbent (bicycle)
  ((chain-type
    :accessor chain-type
    :initarg :chain-type)))

(defclass unicycle (human-powered-conveyance) nil)

(defclass canoe (human-powered-conveyance)
  ((number-of-rowers
    :accessor number-of-rowers
    :initarg :number-of-rowers)))

;;; Calling DESCRIBE on the HUMAN-POWERED-CONVEYANCE class in the REPL gives:

(describe 'human-powered-conveyance)

; COMMON-LISP-USER::HUMAN-POWERED-CONVEYANCE
;  [symbol]
;
; HUMAN-POWERED-CONVEYANCE names the standard-class #<STANDARD-CLASS
;                                                    HUMAN-POWERED-CONVEYANCE>:
;  Documentation:
;    A human powered conveyance
;  Direct superclasses: STANDARD-OBJECT
;  Direct subclasses: UNICYCLE, BICYCLE, CANOE
;  Not yet finalized.
;  Direct slots:
;    VELOCITY
;      Readers: VELOCITY
;      Writers: (SETF VELOCITY)
;    AVERAGE-EFFICIENCY
;      Readers: AVERAGE-EFFICIENCY
;      Writers: (SETF AVERAGE-EFFICIENCY)

;;; Note the reflective behavior available. CL was designed to be an
;;; interactive system

;;; To define a method, let's find out what our circumference of the
;;; bike wheel turns out to be using the equation: C = d * pi

(defmethod circumference ((object bicycle))
  (* pi (wheel-size object)))

;;; PI is defined as a built-in in CL

;;; Let's suppose we find out that the efficiency value of the number
;;; of rowers in a canoe is roughly logarithmic. This should probably be set
;;; in the constructor/initializer.

;;; To initialize your instance after CL gets done constructing it:

(defmethod initialize-instance :after ((object canoe) &rest args)
  (setf (average-efficiency object)  (log (1+ (number-of-rowers object)))))

;;; Then to construct an instance and check the average efficiency...

(average-efficiency (make-instance 'canoe :number-of-rowers 15))
; => 2.7725887


;;;-----------------------------------------------------------------------------
;;; 8. Macros
;;;-----------------------------------------------------------------------------

;;; Macros let you extend the syntax of the language. CL doesn't come
;;; with a WHILE loop, however, it's trivial to write one. If we obey our
;;; assembler instincts, we wind up with:

(defmacro while (condition &body body)
    "While `condition` is true, `body` is executed.
`condition` is tested prior to each execution of `body`"
    (let ((block-name (gensym)) (done (gensym)))
        `(tagbody
           ,block-name
           (unless ,condition
               (go ,done))
           (progn
           ,@body)
           (go ,block-name)
           ,done)))

;;; Let's look at the high-level version of this:

(defmacro while (condition &body body)
    "While `condition` is true, `body` is executed.
`condition` is tested prior to each execution of `body`"
  `(loop while ,condition
         do
         (progn
            ,@body)))

;;; However, with a modern compiler, this is not required; the LOOP form
;;; compiles equally well and is easier to read.

;;; Note that  is used, as well as `,` and `@`.  is a quote-type operator
;;; known as quasiquote; it allows the use of `,` . `,` allows "unquoting"
;;; variables. @ interpolates lists.

;;; GENSYM creates a unique symbol guaranteed to not exist elsewhere in
;;; the system. This is because macros are expanded at compile time and
;;; variables declared in the macro can collide with variables used in
;;; regular code.

;;; See Practical Common Lisp and On Lisp for more information on macros.


#+end_src
*** CS325
- [[https://gitlab.com/criesbeck/cs325][GitLab repo]]
**** Simple Server
- [[https://gitlab.com/criesbeck/simple-server][GitLab repo]]


Simple  Server  provides  a  small  common  API  on  top  of  AllegroServe  and
Hunchentoot. It is documented at:
- http://www.cs.northwestern.edu/academics/courses/325/readings/web-services.php#simple-server
*** AllegroServe
- https://franz.com/support/tutorials/index.lhtml
*** RegExp2 Tutorial
"The regexp2  module is Allegro  CL's fast, Perl-compatible  regular expression
module. It is documented in regexp.htm."

- https://franz.com/support/tutorials/regexp2-tutorial.htm
*** Paradigms of Artificial Intelligence Programming
Lisp code for the textbook "Paradigms of Artificial Intelligence Programming"

- [[https://github.com/norvig/paip-lisp][Code and Text on GitHub]]

** Planet SBCL
 http://planet.sbcl.org

 "Planet SBCL is a meta blog that collects the contents of various
 SBCL-related blogs. It was inspired by Planet Lisp."
** Common Lisp Blogs
*** Lispology
 "RANDOM THOUGHTS ABOUT COMMON LISP"
 - http://www.lispology.com/
** Common Lisp Application Software
https://github.com/azzamsa/awesome-cl-software

This is a list of awesome application software built with Common Lisp.

*** CL-Ledger
https://github.com/ledger/cl-ledger

CL-Ledger is a Common Lisp port of the [[http://ledger-cli.org/][Ledger]] double-entry accounting
system.
*** Brain
- http://www.aiai.ed.ac.uk/project/pub/packages/lisp/random/coherent.l

** CMU Common Lisp Repository
- http://www.cs.cmu.edu/afs/cs.cmu.edu/project/ai-repository/ai/lang/lisp/0.html

** Roswell
- https://github.com/roswell/roswell

** Common Lisp Databases
 - https://www.cliki.net/Database
*** CLSQL
 CLSQL is  a Common  Lisp interface to  SQL databases. A  number of  Common Lisp
 implementations and SQL databases are supported. The general structure of CLSQL
 is based on the CommonSQL package by LispWorks Ltd.

 CLSQL  is a  Database  interface that  can  access a  number  of different  SQL
 database  engines. It  also includes  a  CLOS ORM.  It is  maintained by  Kevin
 Rosenberg.  CLSQL now includes the CommonSQL API interface.

 #+attr_texinfo: :author Bill Clementson
 #+begin_quote
 In summary, the CLSQL package is quite easy  to work with and allows you to use
 a mixture of  functional and OO approaches in working  with relational data. It
 provides high-performing native access to  the underlying databases (as well as
 ODBC access as either an alternative or as a means to access databases that are
 not supported with a native API).  Kevin Rosenberg (and contributors) are to be
 commended for an excellent package!

 - https://web.archive.org/web/20130601122551/http://bc.tech.coop/blog/040608.html
 #+end_quote

 #+attr_texinfo: :author Randall Squared
 #+begin_quote
 CLSQL is the gold  standard of SQL interface libraries on  Common Lisp, and is,
 as you'd expect, large and complex, with various embedded languages. I'd rather
 not carry around  all the extra code  this implies with my  system. Further, it
 doesn't support CMUCL/PPC, because CMUCL on PPC doesn't have multiprocessing.

 - https://web.archive.org/web/20060715192939/http://www.randallsquared.com/download/sqlite/cmucl-sqlite3/cs-docs.txt
 #+end_quote

 - [[https://www.cliki.net/CLSQL][CLSQL on CLiki]]
 - [[http://clsql.kpe.io/documentation.html][CLSQL Documentation]]
 - [[https://web.archive.org/web/20150509221006/http://clsql.b9.com/manual/index.html][CLSQL Users' Guide]]
 - [[http://git.kpe.io/?p=clsql.git][CLSQL Source]]

**** Bill Clementson has written two entries about CLSQL
 - [[https://web.archive.org/web/20130719003355/http://bc.tech.coop/blog/040606.html][CLSQL - Part 1]]
 - [[https://web.archive.org/web/20130601122551/http://bc.tech.coop/blog/040608.html][CLSQL - Part 2]]

**** CommonSQL Tutorials
 - https://web.archive.org/web/20130730032324/http://clsql.b9.com/manual/csql.html

 - [[https://web.archive.org/web/20130512060807/http://www.ravenbrook.com/doc/2002/09/13/common-sql/][Common SQL]][fn:10]
 /Common SQL/ is  the name of LispWorks' interface to  relational databases. The
 interface dates back to  the very early 1990's, when it  was written to support
 Watson, Harlequin's emerging "intelligent  database application". The interface
 ships as standard with LispWorks on the "commercial unix" platforms, and in the
 "Enterprise" editions for Windows and Linux

 The intended audience  for the tutorial is anybody with  a working knowledge of
 lisp and at  least some knowledge of  SQL, who is interested in  seeing how the
 two  can be  combined.  On the  other  hand  most of  this  material should  be
 accessible to people with little or no SQL experience.

 - [[http://clsql.kpe.io/manual/csql.html][CommonSQL Tutorial]]
 "Based on the UncommonSQL Tutorial"

 The goal  of this  tutorial is  to guide a  new developer  thru the  process of
 creating  a set  of  CLSQL  classes providing  a  Object-Oriented interface  to
 persistent data stored in an SQL database.

**** History
 The CLSQL  project was  started by Kevin  M. Rosenberg in  2001 to  support SQL
 access  on multiple  Common Lisp  implementations using  the UFFI  library. The
 initial  code was  based  substantially  on Pierre  R.  Mai's excellent  MaiSQL
 package. In  late 2003,  the UncommonSQL  library was  orphaned by  its author,
 onShore Development, Inc.  In April 2004, Marcus Pearce  ported the UncommonSQL
 library to CLSQL.  The UncommonSQL library provides  a CommonSQL-compatible API
 for CLSQL.

**** iterate-clsql
 This extensions adds ability to iterate over results of queries to databases via CLSQL.

 - https://common-lisp.net/project/iterate-clsql/
*** CL-DBI
 "Database independent interface for Common Lisp"

 [[https://8arrow.org/cl-dbi/][CL-DBI]] is intended to provide the same SQL interface for each database.

 - SQLite3
 - PostgreSQL
 - MySQL


 [[https://github.com/fukamachi/cl-dbi][CL-DBI on GitHub]]

 This library is especially convenient when  you want to use different databases
 in different  environments. For example,  you might  use MySQL as  a production
 database,  but use  SQLite3  on  your development  system.  To switch  database
 backends you need only change the arguments to dbi:connect.
**** Installation

 This library is available on Quicklisp.

 : CL-USER> (ql:quickload :cl-dbi)

**** Usage---DBI Connections

***** SQLite connect
 #+begin_src lisp
 (defvar *connection*
   (dbi:connect :sqlite3
		:database-name "/home/gt/test.sqlite3"))
 #+end_src

***** MySQL connect
 #+begin_src lisp
 (defvar *connection*
   (dbi:connect :mysql
		:database-name "test"
		:username "nobody"
		:password "1234"))
 #+end_src

***** Usage---with-connection
 #+begin_src lisp
 (dbi:with-connection (conn :sqlite3 :database-name "/home/fukamachi/test.db")
   (let* ((query (dbi:prepare conn "SELECT * FROM People"))
          (query (dbi:execute query)))
     (loop for row = (dbi:fetch query)
           while row
           do (format t "~A~%" row))))
 #+end_src

***** Executing a Query
 #+begin_src lisp
 (let* ((query (dbi:prepare *connection*
                            "SELECT * FROM somewhere WHERE flag = ? OR updated_at > ?"))
	(query (dbi:execute query (list 0 "2011-11-01"))))
   (loop for row = (dbi:fetch query)
         while row
         ;; process "row".
         ))

 ;; Do it all at once
 (dbi:fetch-all (dbi:execute (dbi:prepare *connection* "SELECT * FROM somewhere WHERE flag = ? OR updated_at > ?")
                             (list 0 "2011-11-01")))
 #+end_src

 ~dbi:do-sql~ is another  option that prepares and executes  a single statement.
 It returns  the number  of rows  affected. It's  typically used  for non-SELECT
 statements.
 #+begin_src lisp
 (dbi:do-sql *connection*
             "INSERT INTO somewhere (flag, updated_at) VALUES (?, NOW())"
             (list 0))
 ;=> 1
 #+end_src

**** API

***** User-Level API
 - connect [driver-name & params] => <dbi-connection>
 - connect-cached [driver-name & params] => <dbi-connection>
 - disconnect [<dbi-connection>] => T or NIL
 - prepare [conn sql] => <dbi-query>
 - execute [query &optional params] => something
 - fetch [result] => a row data as plist
 - fetch-all [result] => a list of all row data
 - do-sql [conn sql &optional params]
 - list-all-drivers [] => (<dbi-driver> ..)
 - find-driver [driver-name] => <dbi-driver>
 - with-transaction [conn]
 - begin-transaction [conn]
 - commit [conn]
 - rollback [conn]
 - ping [conn] => T or NIL
 - row-count [conn] => a number of rows modified by the last executed
   INSERT/UPDATE/DELETE
 - with-connection [connection-variable-name &body body]

***** Driver-Level API

 - <dbi-driver>
 - <dbi-connection>
 - make-connection [driver params]
 - disconnect [<dbi-connection>] => T or NIL
 - prepare [conn sql] => <dbi-query>
 - fetch-using-connection [conn result] => a row data as plist
 - do-sql [conn sql &optional params]
 - execute-using-connection => something
 - escape-sql => string
 - begin-transaction [conn]
 - commit [conn]
 - rollback [conn]
 - ping [conn] => T or NIL
 - row-count [conn] => a number of rows modified by the last executed INSERT/UPDATE/DELETE
 - free-query-resources [query] free resources associated with a prepared query (this is required only for sqlite3 driver at the moment)

***** Hook of SQL execution
 CL-DBI  provides  ~dbi:*sql-execution-hooks*~,  a  hook to  run  for  each  SQL
 execution, particularly used for logging.

 The hook function takes these 4 values:

 - SQL (string)
 - placeholder parameters (list)
 - Row count of the results (integer or null)
 - Took time in miliseconds (integer or null)

   The row  count and its execution  time can be  null, if those values  are not
   available for the driver for some reason.

 ~dbi:simple-sql-logger~ is also provided for  printing those values directly to
 *standard-output*. It can be enabled as so:

 : (push #'dbi:simple-sql-logger dbi:*sql-execution-hooks*)

*** cl-sqlite
 CL-SQLITE package is an interface to the SQLite embedded relational database
 engine.

 - https://common-lisp.net/project/cl-sqlite/
 - https://github.com/TeMPOraL/cl-sqlite
**** cl-sqlite Usage
***** Connect
  - connect :: connects to the database
  - disconnect :: disconnects from the database
  - with-open-database ::  macro that opens the  database and ensures that  it is
    properly closed after the code is run
***** Queries
  - execute-non-query ::
  - execute-single ::
  - execute-one-row-m-v ::
  - execute-to-list ::
  - execute-to-list/named :: macro is used to execute code within transaction.
  - Support for  ITERATE is  provided :: This  clause will bind  vars (a  list of
    variables) to the values of the columns of query.
    : (for (vars) in-sqlite-query sql on-database db &optional with-parameters (&rest parameters))


  Positional and named parameters in queries are supported. Positional parameters
  are denoted by question  mark in SQL code, and named  parameters are denoted by
  prefixing color (:), at sign (@) or dollar sign ($) before parameter name.

***** Prepared Statement API
  Additionally, it  is possible  to use  the prepared  statements API  of sqlite.
  Create  the prepared  statement with  ~prepare-statement~, bind  its parameters
  with  ~bind-parameter~, step  through  it with  ~step-statement~, retrieve  the
  results with  ~statement-column-value~, and finally  reset it to be  used again
  with ~reset-statement~ or dispose of it with ~finalize-statement~.

***** Supported Types
  Following types are supported:

  - Integer. Integers are stored as 64-bit integers.
  - Float.  Stored as  double.  Single-float, double-float  and  rational may  be
    passed as a parameter, and double-float will be returned.
  - String. Stored as an UTF-8 string.
  - Vector of bytes. Stored as a blob.
  - Null. Passed as NIL to and from database.
*** clisp-sqlite
 clisp-sqlite is an interface to the sqlite SQL database by Scott Williams.

 - https://github.com/juancolarte/colarte-dev/tree/master/lisp/clisp/sqlite

*** SQLite Lisp Interface
*** cl-mongo
 "lisp interface to mongo db"

 - [[https://github.com/fons/cl-mongo][cl-mongo on GitHub]]


 ~cl-mongo~  provides  the  ability  to insert,  update  and  delete  documents,
 indexing, searching using regexs etc. In addition it supports javascript in the
 repl (using a commonly available lisp  to javascript compiler). This allows you
 to do use mongodb's ~map-reduce~ from the lisp repl.

 Install using QuickLisp:

 : #<SYSTEM cl-mongo / cl-mongo-20160531-git / quicklisp 2020-10-16>

 #+begin_quote
 CL-USER> (ql:quickload "cl-mongo")
 To load "cl-mongo":
   Load 5 ASDF systems:
     alexandria asdf babel lisp-unit split-sequence
   Install 12 Quicklisp releases:
     anaphora bordeaux-threads cl-mongo cl-ppcre cl-who
     documentation-template ironclad named-readtables
     parenscript trivial-utf-8 usocket uuid
 #+end_quote

 To run the quick test, do this:

 : (use-package :cl-mongo-test) (quick-test) # did not work
 : (ql:quickload "cl-mongo-test)(cl-mongo-test::quick-test) # worked
*** berkeley-db
** Lisp for the Web
- [[https://www.adamtornhill.com/articles/lispweb.htm][LispWeb]]
- [[https://leanpub.com/lispweb][On LeanPub]]

** awesome-cl
"A curated list of awesome Common Lisp frameworks, libraries and other shiny
stuff."

- https://awesome-cl.com
- [[https://github.com/CodyReichert/awesome-cl][awesome-cl on GitHub]]


All libraries listed here are available from Quicklisp unless stated otherwise.
The ones  marked with  a :star: are  so widespread and  solid that  they became
community  standards. You  can’t  be wrong  with  them. This  is  the case  for
Quicklisp, BordeauxThreads and  such. Libraries denoted with a 👍  are the ones
we like  and want to  promote here at the  Awesome-cl list. They  proved solid,
they may solve  a problem better than  a community standard but  they aren’t as
widespread, or not considered as stable.  For example, we prefer Spinneret over
Cl-Who.
** Acceleration
- https://github.com/AccelerationNet


101 repositories

** Alexandria
- https://common-lisp.net/project/alexandria/
- [[https://common-lisp.net/project/alexandria/draft/alexandria.html][Documentation as HTML]]
- [[https://common-lisp.net/project/alexandria/draft/alexandria.pdf][Documentation as PDF]]
- [[https://gitlab.common-lisp.net/alexandria/alexandria][GitLab Repo]]
- [[https://gitlab.common-lisp.net/alexandria/alexandria][git clone ...]]

Alexandria is  a collection of portable  public domain utilities that  meet the
following constraints:

- /Utilities,  not   extensions/:  Alexandria   will  not   contain  conceptual
  extensions to  Common Lisp,  instead limiting itself  to tools  and utilities
  that  fit   well  within  the   framework  of  standard  ANSI   Common  Lisp.
  Test-frameworks,  system   definitions,  logging   facilities,  serialization
  layers, etc.  are all outside  the scope of  Alexandria as a  library, though
  well within the scope of Alexandria as a project.
- /Conservative/:  Alexandria limits  itself to  what project  members consider
  conservative utilities.  Alexandria does not  and will not  include anaphoric
  constructs, loop-like binding macros, etc.
- /Portable/: Alexandria limits  itself to portable parts of  Common Lisp. Even
  apparently conservative  and usefull  functions remain  outside the  scope of
  Alexandria  if  they cannot  be  implemented  portably. Portability  is  here
  defined as  portable within a conforming  implementation: implementation bugs
  are not considered portability issues.
- /Team player/: Alexandria  will not (initially, at least)  subsume or provide
  functionality  for which  good-quality special-purpose  packages exist,  like
  split-sequence. Instead, third party packages such as that may be "blessed".
** Anorpha
- https://common-lisp.net/project/anaphora/
- [[https://github.com/tokenrove/anaphora][Anorpha on GitHub]]
- [[https://common-lisp.net/project/anaphora/anaphora.htmly][Anorpha Documentation]]


Anaphoric macros  provide implicit  bindings for various  operations. Extensive
use of anaphoric macros  is not good style, and probably makes  you go blind as
well — there's a reason why Anaphora claims to be from Hell.

Installation via ~quicklisp~:
: (ql:quickload "anaphora")
** Collectors
- https://github.com/AccelerationNet/collectors


A small collection of common lisp macros to make collecting values easier.
** The Allegro Common Lisp Open Source Center
- http://opensource.franz.com
- [[https://github.com/franzinc][on GitHub]]
*** AllegroServe Webserver
"AllegroServe, a web server written in Common Lisp"

- https://github.com/franzinc/aserve
- [[https://franz.com/support/documentation/current/doc/aserve/aserve.html][Documentation]]
*** imap
"POP, IMAP and SMTP client support  for Common Lisp---A common lisp library for
sending and receiving email."

- https://github.com/franzinc/imap
** Common Lisp Text Processing
- https://cliki.net/Text

*** Regular Expression Libraries
- https://cliki.net/regular%20expression

**** CL-PPCRE
"Portable Perl-compatible regular expressions for Common Lisp"

- https://edicl.github.io/cl-ppcre/
- [[https://github.com/edicl/cl-ppcre/][on GitHub]]

**** Regex
- https://github.com/michaelw/regex
- http://www.foldr.org/~michaelw/lisp/clawk/#regex

**** The RegEx Coach
"Interactive Regular Expressions"

- http://weitz.de/regex-coach/


The Regex  Coach is a  graphical application for Windows  which can be  used to
experiment with (Perl-compatible) regular expressions interactively. It has the
following features:

- It shows whether a regular expression matches a particular target string.
- It can  also show  which parts  of the target  string correspond  to captured
  register groups or to arbitrary parts of the regular expression.
- It can "walk" through the target string one match at a time.
- It can simulate Perl's split and s/// (substitution) operators.
- It tries to describe the regular expression in plain English.
- It  can show  a graphical  representation of  the regular  expression's parse
  tree.
- It can  single-step through the  matching process  as performed by  the regex
  engine.
- Everything  happens  in "real  time",  i.e.  as soon  as  you  make a  change
  somewhere in the application all other parts are instantly updated.
*** AWK
**** CLAWK
CLAWK is an AWK implementation embedded into Common Lisp.

- http://www.foldr.org/~michaelw/lisp/clawk/#regex
*** Parsers---Lexers
*** String Processing
*** Text
**** Literate Lisp
A literate programming tool to write common lisp codes in org mode.

- https://github.com/jingtaozf/literate-lisp/
- [[https://github.com/jingtaozf/literate-lisp/blob/master/literate-lisp.org][Documentation]]


literate-lisp provides  an easy way to  use literal programming in  Common Lisp
language. It extends the Common Lisp reader  syntax so a Common Lisp vendor can
read org files as Common Lisp source files.

By using  this package(literate-lisp),  Emacs org mode  and Emacs  Lisp library
polymode, literate programming can be very easy in one org file containing both
documentation and source codes, and this org file can interact well with SLIME.
**** Loggers
- [[https://github.com/jingtaozf/log4cl][log4cl]] : Common Lisp logging framework, modeled after Log4J

*** Streams

** Common Lisp Libraries by Edi Weitz
- https://github.com/edicl

** Common Lisp Repos
- https://github.com/common-lisp-repos
- [[https://github.com/takagi/lake][lake]] :: like ~make~
- [[https://github.com/Rudolph-Miller/jonathan][jonathon]] :: High performance JSON encoder and decoder. Currently support:
  SBCL, CCL.
- [[https://github.com/fourier/awesome-lispworks][awesome-lispworks]] :: A curated list of awesome LispWorks extensions.
- [[https://github.com/slburson/fset][fset]] :: FSet, the functional collections library for Common Lisp.
- [[https://github.com/dlowe-net/local-time][local-time]] :: Time manipulation library for Common Lisp
- [[https://github.com/dlowe-net/clock][clock]] :: A Common Lisp date/time library
- [[https://github.com/dlowe-net/stencl][stencl]] :: A lightweight templating library for Common Lisp
- [[https://github.com/dlowe-net/cl-sort][cl-sort]] :: A collection of sorting routines written in Common Lisp
- [[https://github.com/dlowe-net/printf][printf]] :: A printf implementation in Common Lisp
- [[https://github.com/tuscland/heroku-buildpack-cl][heroku-buildpack-cl]] :: A Buildpack that allows you to deploy Common Lisp
  applications on the Heroku infrastructure.
- [[https://github.com/adlai/event-emitter][event-emitter]] :: Event mechanism for Common Lisp objects.
- [[https://github.com/coleslaw-org/coleslaw][coleslaw]] :: Flexible Lisp Blogware
- [[https://github.com/kingcons/study-group/tree/master/sicp-july-2018][SICP Study Group]] :: SICP exercises (a few)
- [[https://github.com/mbattyani/cl-pdf][cl-pdf]] :: CL-PDF is a cross-platform Common Lisp library for generating PDF
  files.
- [[https://github.com/mbattyani/cl-typesetting][cl-typesetting]] :: CL-TYPESETTING is  a cross-platform Common Lisp typesetting
  library for all kind of typesetting applications.
- [[https://github.com/fukamachi/fast-http][fast-http]] :: A fast HTTP request/response parser for Common Lisp.
- [[https://github.com/hackinghat/cl-mysql][cl-mysql]] :: Common Lisp MySQL library
- [[https://github.com/eudoxia0/docparser][docparser]] :: Extract documentation from Common Lisp systems
- [[https://github.com/fukamachi/cl-dbi][cl-dbi]] :: Database independent interface for Common Lisp
- [[https://github.com/snmsts][snmsts]] :: Lisp repositories
- [[https://github.com/guicho271828/eazy-process][eazy-process]] :: Yet Another Portable Library for Process Handling / Subshell
  Invokation
- [[https://github.com/guicho271828/eazy-documentation][eazy-documentation]] :: One-shot solution to the CL library documentation
  generator.
- [[https://github.com/guicho271828/data-structures-in-common-lisp][data structures in common lisp]] :: A survey of data structure availability /
  quality in common lisp
- [[https://borretti.me/portfolio/][boretti cl]] ::
- [[https://github.com/luismbo/cl-travis][cl-travis]] :: Travis-CI scripts for testing Common Lisp software
- [[https://borretti.me/article/lisp-travis-coveralls][CL with Travis]] ::
- [[https://borretti.me/article/common-lisp-sotu-2015][CL Ecosystem 2015]] ::
- [[https://github.com/fukamachi/woo][Woo]] :: A fast non-blocking HTTP server on top of libev
- [[https://github.com/fukamachi/clack][Clack]] :: Web server abstraction layer for Common Lisp
- [[https://github.com/eudoxia0/clack-errors][clack-errors]] :: Error page middleware for Clack.
- [[http://8arrow.org/caveman/][caveman]] :: Web Framework
- [[https://github.com/fukamachi/datafly][datafly]] :: A lightweight database library for Common Lisp.
- [[https://edicl.github.io/cl-who/][cl-who]] :: Yet another Lisp markup language
- [[https://www.common-lisp.net/project/cl-emb/][cl-emb]] :: Embedded Common Lisp and template system
- [[https://marijnhaverbeke.nl/postmodern/][postmodern]] :: Common Lisp library for interacting with PostgreSQL databases.
- [[http://8arrow.org/ningle/][ningle]] :: A lightweight web application framework for Common Lisp
- [[https://github.com/fukamachi/sxql][sxql]] :: An SQL generator for Common Lisp.
- [[https://github.com/fukamachi/envy][envy]] :: Configuration switcher by an environment variable inspired by Perl's
  Config::ENV.
- [[https://github.com/sile/cl-mine][cl-mine]] :: A console based mine-sweeper
- [[https://github.com/sile/tiny-http][tiny-http]] :: A tiny Common Lisp HTTP client
- [[https://github.com/sile/array-merge-sort][in-place merge sort]] :: in-place merge sort for array
- [[https://github.com/sile/merge-sort][merge-sort]] :: n-place merge sort for list
- [[https://github.com/sile/dic-lisp][dic-lisp]] :: A command line dictionary implemented in common lisp
- [[https://github.com/sile/aio][aio]] :: asynchronous I/O package for SBCL
- [[https://github.com/sile/snif][snif]] :: packet capture
- [[https://github.com/sile/pofo][pofo]] :: port forwarding package
- [[https://github.com/sile/traceroute][traceroute]] :: traceroute
- [[https://github.com/sile/ping][ping]] :: ping
- [[https://github.com/sile/ping][mqsort]] :: multikay quicksort
- [[https://github.com/sile/fifo][fifo]] :: First in First out queue
- [[https://www.lrde.epita.fr/~didier/software/lisp/clon.php#.X8Q1cy2cbAI][clon]] :: the Command-Line Options Nuker
  - https://github.com/didierverna/clon
- [[https://github.com/didierverna/tfm][tfm]] :: A TeX Font Metrics library for Common Lisp
- [[https://github.com/didierverna/declt][dclt]] :: Reference manual generator for Common Lisp libraries
- [[https://github.com/didierverna/el-rcfiles][el-rcfiles]] :: Unix-like RC files for Emacs Lisp libraries
- [[https://gitlab.common-lisp.net/quickref/quickref][quickref]] :: a global documentation project for Common Lisp
- [[https://github.com/didierverna/milonga][milonga]] :: Tango-based customizable theme for Emacs

** Lisp Resources on the Way Back Machine
- https://web.archive.org/web/20070602152438/http://eksl-www.cs.umass.edu/lisp-resources/index.html

** Programming in Lisp
- https://www.iiia.csic.es/~puyol/TAPIA/

* Common Lisp IO and Formatting
#+texinfo: @heading File System Concepts
This section  discusses the Common  Lisp interface  to file systems.  The model
used by this interface assumes that:

- files are named by filenames ([[a-file][files)]]
- a filename can be represented by a pathname object ([[a-filename][filename)]] ([[pathname--class][pathname]])
- given a pathname, a  stream can be constructed that connects  to a file whose
  filename it represents ([[a-stream][stream)]].


Pathnames and  namestrings[fn:6] are two  kinds of objects that  substitute for
filenames in Common Lisp ([[pathname--class][pathname class]])

** Files and Filenames

#+texinfo: @heading Files
A  ~file~   <<a-file>>  is  a  named   entry  in  a  file   system,  having  an
implementation-defined nature.

#+texinfo: @heading Filenames
#+cindex:filename
#+attr_texinfo: :options Handle filename
#+begin_deftp
<<a-filename>>
A  ~filename~ is  a handle,  not necessarily  ever directly  represented as  an
object, that can be used to refer to a file in a file system ([[a-file][file]])
#+end_deftp

<<truename-function>>
#+attr_texinfo: :options truename filespec => truename
#+begin_defun
~truename~ tries to  find the file indicated  by @@texinfo:@var{filespec}@@ and
returns its @@texinfo:@var{truename}@@.  If the filespec designator  is an open
stream, its associated file is used.

- ~FILESPEC~  ::   a  pathname  designator.  If filespec  is  a  /pathname/  it
  represents the name used to open the file

- ~TRUENAME~ :: a physical pathname
#+end_defun

*** Reading File Streams
    #+cindex:stream, file
    #+findex:open
The most basic file I/O task is to read the contents of a file.  To do so, you
obtain a stream from which you can read a file's contents.  You do this with
the ~open~ function.
#+caption:The Open Function
#+name:open
#+attr_texinfo: :options open filespec &key direction element-type if-exists if-does-not-exist external-format
#+begin_defun
~Open~ returns a character-based input stream that can be passed along to other
functions that read characters of text.

- ~FILESPEC~  ::   The name  of the file to read.  This can be  one of a string
  ("namestring"),  a pathname  object,  or a  stream  object, all  collectively
  called /pathname designators/. Pathnames  represent filenames in a structured
  way that  makes them easy  to manipulate without  tying them to  a particular
  filename syntax.

#+end_defun

** Pathnames and Pathspecs

#+cindex:pathname
<<pathname--class>>
#+attr_texinfo: :options {Structured Object} pathname
#+begin_deftp
A /pathname/ is a structured object which represents a filename.

There are two kinds of pathnames:

- physical pathnames ([[physical-pathname][physical pathname]])
- logical pathnames ([[logical-pathname][logical pathname]])
#+end_deftp

#+cindex:logical pathname
<<logical-pathname>>
#+attr_texinfo: :options Pathname {logical pathname}
#+begin_deftp
An object of type ~logical-pathname~.

A    /pathname/     that    uses     a    /namestring/    syntax     that    is
implementation-independent,   and   that   has  component   values   that   are
implementation-independent.  Logical   pathnames  do  not  refer   directly  to
filenames.
#+end_deftp

#+cindex:physical pathname
<<physical-pathname>>
#+attr_texinfo: :options Pathname {physical pathname}
#+begin_deftp
A pathname that is not a logical pathname.

An object of  type ~pathname~ is a  structured representation of the  name of a
file. A pathname has six components:

- host
- device
- directory
- name
- type
- version
#+end_deftp

#+attr_texinfo: :options pathname pathspec => pathname
#+begin_defun
Returns the @@texinfo:@var{pathname}@@ denoted by @@texinfo:@var{pathspec}@@.

- PATHSPEC ::  If the  @@texinfo:@var{pathspec}@@ designator  is a  file stream
  created   by   opening   a   logical  pathname,   a   logical   pathname   is
  returned.

- PATHNAME  ::  the  @@texinfo:@var{pathname}@@  returned  corresponds  to  the
  filename used to open the file.
#+end_defun

#+cindex:pathname designator
<<pathname-designator>>
#+attr_texinfo: :options Object {pathname designator} pathspec
#+begin_deftp
A designator for a pathname; that is, an object that denotes a pathname and
that is one of:

- pathname namestring[fn:6] (denoting the corresponding pathname)
- a stream associated with a file (denoting the pathname used to open the file)
- pathname (denoting itself)
#+end_deftp

** Streams
<<a-stream>>
#+attr_texinfo: :options Object stream
#+begin_deftp
A ~stream~ is  an object that can be  used with an input or  output function to
identify  an  appropriate source  or  sink  of  characters  or bytes  for  that
operation.

A stream can be a:

- character stream :: A character stream is a source or sink of characters.

- binary stream :: A binary stream is a source or sink of bytes.



A stream can be a/n:

- input stream :: source of data
- output stream :: sink for data
- bidirectional stream :: a stream that is both an input and an output stream.
- neither :: when =:direction-probe= is given to ~open~


A stream associated with a file is either:

- a file stream :: an object of class /file stream/ is used to represent a file
  stream. The  basic operation for  opening a  file is ~open~,  which typically
  returns a /file stream/. The basic operation for closing a stream is ~close~.

  #+findex:with-open-file
  The macro ~with-open-file~ is useful to express the common idiom of opening a
  file  for the  duration  of a  given  body  of code,  and  assuring that  the
  resulting stream is closed upon exit from that body.

- a synonym stream :: whose target is a stream associated with a file.


Such streams can be used as pathname designators (see
[[pathname-designator][pathname designator]]).

Normally,  when  a  stream  associated  with  a file  is  used  as  a  pathname
designator, it denotes the pathname used to  open the file; this may be, but is
not required to be, the actual name of the file.

Some  functions,  such  as  ~truename~ and  ~delete-file~,  coerce  streams  to
pathnames in a  different way that involves referring to  the *actual file that
is open*, which might or might not be the file whose name was opened originally
([[truename-function][truename function]]).

Streams are either:

- open ::  in general, operations that create and return streams return open
  streams.

- closed :: the action of closing a stream marks the end of its use as a source
  or sink of  data, permitting the implementation to reclaim  its internal data
  structures, and to  free any external resources which might  have been locked
  by the stream when it was opened.

  Coercion of streams to pathnames is permissible for closed streams;

#+end_deftp

*** Stream Subclasses
The class /stream/ has a number of subclasses defined by this specification.
The following are subclasses of /stream/.

- /broadcase-stream/ ::

  - ~make-broadcase-string~

  - ~broadcast-stream-streams~

- /concatenated-stream/ ::

  - ~make-concatenated-stream~

  - ~concatenated-stream-streams~

- /echo-stream/ ::

  - ~make-echo-stream~

  - ~echo-stream-input-stream~

  - ~echo-stream-output-stream~

- /string-stream/ ::

  - ~make-string-input-stream~

  - ~with-input-from-string~

  - ~make-string-output-stream~

  - ~with-output-to-string~

  - ~get-output-stream-string~

- /synonym-string/ ::

  - ~make-synonym-stream~

  - ~synonym-stream-symbol~

- /two-way-stream/ ::

  - ~make-two-way-stream~

  - ~two-way-stream-input-stream~

  - ~two-way-stream-output-stream~

*** Predefined Streams---Stream Variables

#+texinfo: @heading The Standardized I/O Customization Variables

#+cindex:stream variables
Variables whose values must be streams are sometimes called /stream variables/.

#+cindex:standardized i/o customization variables
These  variables are  collectively called  the /standardized  I/O customization
variables/.  They can  be bound  or  assigned in  order to  change the  default
destinations for input and/or output used by various standardized operators and
facilities.

  #+cindex:standard input
  #+vindex:*standard-input*
- =*standard-input*= ::

  implementation-dependent,  but it  must  be  an open  stream  that  is not  a
  generalized synonym stream  to an I/O customization variables  but that might
  be  a generalized  synonym  stream to  the value  of  some I/O  customization
  variable.

  The value of =*standard-input*=, called /standard input/, is a stream that is
  used by many  operators as a default  source of input when  no specific input
  stream is explicitly supplied.

  #+cindex:standard output
  #+vindex:*standard-output*
- =*standard-output*= ::

  The value of =*standard-output*=, called  /standard output/, is a stream that
  is  used by  many  operators as  a  default destination  for  output when  no
  specific output stream is explicitly supplied.

  #+cindex:error output
  #+vindex:*error-output*
- =*error-output*= ::

  The value  of =*error-output*=, called /error  output/, is a stream  to which
  warnings and non-interactive error messages should be sent.

  #+cindex:query i/o
  #+vindex:*query-io*
- =*query-io*= ::

  The value of  =*query-io*=, called /query I/O/, is a  bidirectional stream to
  be used when asking  questions of the user. The question  should be output to
  this stream, and the answer read from it.

  #+cindex:debug i/o
  #+vindex:*debug-io*
- =*debug-io*= ::

  The value  of =*debug-io*=, called  /debug I/O/, is a  stream to be  used for
  interactive debugging purposes.

*** Redirecting the Standard Output of your Program
    :PROPERTIES:
    :source:   http://cl-cookbook.sourceforge.net/io.html#bulk
    :END:

#+cindex:standard output, redirect
#+cindex:redirect standard output
To redirect the standard output of your program:

#+begin_src lisp
  (let ((*standard-output* <some form generating a stream>))
    ...)
#+end_src

#+cindex:dynamic variable
#+cindex:variable, dynamic
#+attr_texinfo: :author The Common Lisp Cookbook---I/O
#+begin_quote
Because  =*STANDARD-OUTPUT*= is  a  *dynamic variable*,  all  references to  it
during execution  of the body of  the =LET= form  refer to the stream  that you
bound it to. After exiting the =LET= form, the old value of =*STANDARD-OUTPUT*=
is restored,  no matter if  the exit was  by normal execution,  a =RETURN-FROM=
leaving  the  whole  function,  an   exception,  or  what-have-you.  (This  is,
incidentally, why global variables lose much of their brokenness in Common Lisp
compared to  other languages: since  they can be bound  for the execution  of a
specific form without the risk of losing  their former value after the form has
finished, their  use is quite  safe; they  act much like  additional parameters
that are passed to every function.)
#+end_quote

#+findex:with-open-file
To send the output to a file:

#+begin_src lisp
  (with-open-file (*standard-output* "somefile.dat" :direction :output
				     :if-exists :supersede)
    ...)
#+end_src

#+attr_texinfo: :author The Common Lisp Cookbook---I/O
#+begin_quote
~WITH-OPEN-FILE~  opens  the  file  ---  creating it  if  necessary  ---  binds
=*STANDARD-OUTPUT*=,  executes   its  body,  closes  the   file,  and  restores
=*STANDARD-OUTPUT*= to its  former value. It doesn't get  more comfortable than
this!
#+end_quote

#+attr_texinfo: :options with-open-file (stream filespec options*) declaration* form* => results
#+begin_defun
Uses   ~open~   to   create   a   /file    stream/   to   a   file   named   by
@@texinfo:@var{@@filespec@@texinfo:}@@.  When control  leaves the  body, either
normally or abnormally  (such as by use of ~throw~),  the file is automatically
closed. If a  new output file is being written,  and control leaves abnormally,
the file is aborted and the file system  is left, so far as possible, as if the
file had never been opened.

The keyword arguments to ~open~ specify  the characteristics of the file stream
that is returned, and how to handle errors.

- STREAM :: The stream object to which the stream variable is bound has dynamic
  extent; its extent ends when the form is exited.

- FILESPEC :: Filespec is the name of the file to be opened.

- OPTIONS    ::   are used as  keyword arguments to  ~open~:
  - =:direction= ::  one of =:input=, =:output=, =:io=, or =:probe=. The default
    is =:input=.

  - =:if-exists=    ::    one    of   =:error=,    =:new-version=,    =:rename=,
    =:rename-and-delete=, =:overwrite=, =:append=, =:supersede=, or =nil=.

  - =:if-does-not-exist=  :: one of =:error=,  =:create=, or =nil=. The default
    is:
    - =:error=  if direction  is  =:input= or  =if-exists=  is =:overwrite=  or
      =:append=;
    - =:create= if direction is =:output= or =:io=, and =if-exists= is neither =:overwrite=
       nor =:append=; or
    - =nil= when direction is =:probe=.

  - =:element-type= :: The default is =character=.

  - =:external-format= :: default is =:default=

- DECLARATION :: a declare expression; not evaluated.

- FORMS    ::    The  forms   are  evaluated  as   an  implicit   ~progn~  with
  @@texinfo:@var{@@stream@@texinfo:}@@ bound to the value returned by ~open~.

- RESULTS :: the values returned by the forms.
#+end_defun


#+texinfo:@heading Example

#+begin_lisp
(setq p (merge-pathnames "test"))
=>  #<PATHNAME :HOST NIL :DEVICE device-name :DIRECTORY directory-name
    :NAME "test" :TYPE NIL :VERSION :NEWEST>

 (with-open-file (s p :direction :output :if-exists :supersede)
    (format s "Here are a couple~%of test data lines~%")) =>  NIL

 (with-open-file (s p)
    (do ((l (read-line s) (read-line s nil 'eof)))
        ((eq l 'eof) "Reached end of file.")
     (format t "~&*** ~A~%" l)))

>>  *** Here are a couple
>>  *** of test data lines
=>  "Reached end of file."
#+end_lisp

*** Reading Lines of a File using Standard Input
    :PROPERTIES:
    :source:   http://cl-cookbook.sourceforge.net/files.html#line
    :END:
~READ-LINE~ will  read one  line from  a stream  (which defaults  to =*STANDARD
INPUT*=) the end  of which is determined  by either a newline  character or the
end of  the file. It  will return  this line as  a string without  the trailing
newline character.  (Note that ~READ-LINE~ has  a second return value  which is
=true= if there was no trailing newline, i.e. if the line was terminated by the
end of the file.) ~READ-LINE~ will by default signal an error if the end of the
file  is  reached. You  can  inhibit  this by  supplying  =NIL=  as the  second
argument. If you do  this, ~READ-LINE~ will return =NIL= if  it reaches the end
of the file.


#+findex: with-open-file
#+findex:read-line
#+begin_src lisp
  (with-open-file (stream "/etc/passwd")
      (do ((line (read-line stream nil)
		 (read-line stream nil)))
	  ((null line))
	(print line)))
#+end_src

You can  also supply  a third  argument which will  be used  instead of  NIL to
signal the end of the file:

#+begin_src lisp
  (with-open-file (stream "/etc/passwd")
    (loop for line = (read-line stream nil 'foo)
	  until (eq line 'foo)
	  do (print line)))
#+end_src

#+attr_texinfo: :options read-line &optional input-stream eof-error-p eof-value recursive-p => line
#+begin_defun
Reads from  @@texinfo:@var{@@input-stream@@texinfo:}@@ a  line of text  that is
terminated by a  newline or end of  file. Two values are  returned: the primary
value is the line that was read, while the secondary value is a boolean that is
=false= if  the line was  terminated by  a newline, or  =true= if the  line was
terminated  by  the end  of  file  for input-stream  (or  if  the line  is  the
eof-value).

- INPUT-STREAM   ::    an   input    stream   designator.   The    default   is
  =*STANDARD-INPUT*=.

- EOF-ERROR-P    ::    If an end of  file occurs before any characters are read
  in  the  line,   an  error  is  signaled  if  =eof-error-p=   is  =true=.  If
  =eof-error-p= is  =false= and the end  of file for =input-stream=  is reached
  before any characters are read, =eof-value= is returned as the line.

- EOF-VALUE :: an object. The default is =nil=.

= RECURSIVE-P :: A boolean.  The default is =false=.

- RETURN :: =LINE= is  the line that is read, represented  as a string (without
  the trailing newline, if any).
#+end_defun

#+begin_example
 (setq a "line 1
 line2")
=>  "line 1
 line2"
 (read-line (setq input-stream (make-string-input-stream a)))
=>  "line 1", false
 (read-line input-stream)
=>  "line2", true
 (read-line input-stream nil nil)
=>  NIL, true
#+end_example

*** Stream Functions
Some operations may be performed on any kind of stream; the following is a list
of standardized operations that are potentially useful with any kind of stream.

#+texinfo: @heading Some General-Purpose Stream Operations

- ~close~
- ~input-stream-p~
- ~output-stream-p~
- ~interactive-stream-p~
- ~stream-element-type~
- ~streamp~
- ~with-open-stream~

#+attr_texinfo: :options close stream &key abort => result
#+begin_defun
~close~ closes stream.  Closing a stream means  that it may no longer  be used in
input  or  output  operations. The  act  of  closing  a  file stream  ends  the
association between  the stream and  its associated file; the  transaction with
the file system  is terminated, and input/output may no  longer be performed on
the stream.

- STREAM :: a stream (either open or closed).

- ABORT ::  a boolean  with a  =false= default  value. If  abort is  =true=, an
  attempt is  made to clean  up any side effects  of having created  stream. If
  stream  performs output  to  a file  that  was created  when  the stream  was
  created,  the  file is  deleted  and  any  previously  existing file  is  not
  superseded.

#+end_defun

#+attr_texinfo: :options input-stream-p stream => boolean
#+begin_defun
#+texinfo: @defunx output-stream-p stream => boolean

~input-stream-p~ returns  =true= if stream is an input  stream; otherwise, returns
=false=.

~output-stream-p~ returns =true= if stream is an output stream; otherwise, returns
=false=.

#+end_defun

#+attr_texinfo: :options interactive-stream-p stream => boolean
#+begin_defun
Returns =true= if stream is an interactive stream[fn:7]; otherwise, returns
=false=.
#+end_defun

#+attr_texinfo: :options stream-element-type stream => typespec
#+begin_defun
~stream-element-type~  returns a  type specifier  that indicates  the types  of
objects that may be  read from or written to stream.  Streams created by ~open~
have an element type restricted to integer or a subtype of type character.
#+end_defun

#+attr_texinfo: :options streamp object => boolean
#+begin_defun
Returns =true= if object is of type stream; otherwise, returns =false=.
#+end_defun

#+attr_texinfo: :options with-open-stream (var stream) declaration* form* => results
#+begin_defun
~with-open-stream~ performs a series of operations on @@texinfo:@var{stream}@@,
returns a value, and then closes  the stream. @@texinfo:@var{Var}@@ is bound to
the  value of  @@texinfo:@var{stream}@@, and  then @@texinfo:@var{form}@@s  are
executed as an implicit ~progn~.

- VAR :: a variable name; bound to @@texinfo:@var{stream}@@.

- STREAM  :: a  form; evaluated  to produce  a stream.  The stream  has dynamic
  extent; its extent ends when the form is exited.

- DECLARATION :: a ~declare~ expression; not evaluated.

- FORM :: an implicit ~progn~.

- RESULTS :: the values returned by the @@texinfo:@var{form}@@s.


#+caption:Example of ~with-open-stream~
#+name:example-with-open-stream
#+begin_src lisp
(with-open-stream (s (make-string-input-stream "1 2 3 4"))
    (+ (read s) (read s) (read s))) =>  6
#+end_src
#+end_defun

*** Input Stream Functions
The following are operators relating to input streams:

- ~clear-input~
- ~listen~
- ~peek-char~
- ~read~
- ~read-byte~
- ~read-char~
- ~read-char-no-hang~
- ~read-delimited-list~
- ~read-from-string~
- ~read-line~
- ~read-preserving-whitespace~
- ~unread-char~

*** Output Stream Functions
The following are operators relating to output streams:

- ~clear-output~
- ~finish-output~
- ~force~output~
- ~format~
- ~fresh-line~
- ~pprint~
- ~prin1~
- ~prin1-to-string~
- ~princ~
- ~princ-to-string~
- ~print~
- ~terpri~
- ~write~
- ~write-byte~
- ~write-char~
- ~write-line~
- ~write-string~
- ~write-to-string~

*** Bidirectional Functions
Any of the operators listed above under *Input Stream Functions* and *Output
Stream Functions* can be used on bidirectional streams.  In addition, the
following operators relate specifically to bidirectional streams:

- ~y-or-n-p~
- ~yes-or-no-p~

*** Functions Taking Stream Arguments
**** Either Open or Closed Streams
These operators accept stream arguments that might be either open or closed
streams.

- ~broadcast-stream-streams~
- ~close~
- ~compile-file~
- ~compile-file-pathname~
- ~concatenated-stream-streams~
- ~delete-file~
- ~directory~
- ~directory-namestring~
- ~dribble~
- ~echo-stream-input-stream~
- ~echo-stream-ouput-stream~
- ~ed~
- ~enough-namestring~
- ~file-author~
- ~file-namestring~
- ~file-write-date~
- ~host-namestring~
- ~load~
- ~logical-pathname~
- ~merge-pathnames~
- ~namestring~
- ~open~
- ~open-stream-p~
- ~parse-namestring~
- ~pathname~
- ~pathname-match-p~
- ~pathnamep~
- ~probe-file~
- ~rename-file~
- ~streamp~
- ~synonym-stream-symbol~
- ~translate-logical-pathname~
- ~translate-pathname~
- ~truename~
- ~two-way-stream-input-stream~
- ~two-way-stream-output-stream~
- ~wild-pathname-p~
- ~with-open-file~

**** Open Streams
These opertors require open streams:

- clear-input
- clear-output
- file-length
- file-position
- file-string-length
- finish-output
- force-output
- format
- fresh-line
- get-output-stream-string
- input-stream-p
- interactive-stream-p
- listen
- make-broadcast-stream
- make-concatenated-stream
- make-echo-stream
- make-synonym-stream
- make-two-way-stream
- output-stream-p
- peek-char
- pprint
- pprint-fill
- pprint-indent
- pprint-linear
- pprint-logical-block
- pprint-newline
- pprint-tab
- pprint-tabular
- prin1
- princ
- print
- print-object
- print-unreadable-object
- read
- read-byte
- read-char
- read-char-no-hang
- read-delimited-list
- read-line
- read-preserving-whitespace
- stream-element-type
- stream-external-format
- terpri
- unread-char
- with-open-stream
- write
- write-byte
- write-char
- write-line
- write-string
- y-or-n-p
- yes-or-no-p

** Common Lisp Formatting
 ~format~ produces three kinds of formatting:

 1. printing tables of data as text
    not used much anymore

 2. pretty-printing s-expressions

    a customizable  system for printing  block-structured data such  as--but not
    limited to--s-expressions  while varying indentation and  dynamically adding
    line breaks as needed.

 3. generating human-readable messages with interpolated values

*** format Function
 #+attr_texinfo: :options format @var{destination} @var{control-string} &rest @var{format-args}
 #+begin_defun

 Takes two required arguments:

 1. @@texinfo:@var{@@destination@@texinfo:}@@ for output

    - =t= : the =*standard-output*= stream;
    - =nil= : ~format~ generates a string and returns it;
    - a stream : output written to this stream;
    - string with fill-pointer :  ougtput is added to the end  of the string and
      the fill pointer is adjusted;

 2. @@texinfo:@var{@@control-string@@texinfo:}@@ that  contains literal text and
    embedded directives;

 3. additional optional  @@texinfo:@var{@@format-args@@texinfo:}@@ provide  the
   values used by the directives in  the control string that interpolate values
   into the output.

 ~format~  returns =nil=  except when  destination is  =nil=, in  which case  it
 returns the newly-generated string.

 #+end_defun

*** format Directives
 All directives start with a tilde (=~=) and end with a single character (upper-
 or  lowercase) that  identifies  the directive.

 : (format t "~A" pi) ==> 3.14

 #+texinfo: @heading Prefix Parameters

 Some  directives  take  /prefix  parameters/,  which  are  written  immediately
 following the  tilde, separated by commas,  and used to control  things such as
 how many digits to print after the decimal point when printing a floating-point
 number.

 : (format t "~$" pi)  ==> 3.14
 : (format t "~5$" pi) ==> 3.14159
 :             ^

 The  values of  prefix parameters  are either  decimal numbers,  or characters,
 written as a single quote followed by the desired character.  The value of a
 prefix parameter can also be derived from the format arguments in two ways:

 1. a prefix parameter of =v= causes ~format~ to consume one format argument and
    use its value for the prefix parameter;
 2. a  prefix parameter  of =#=  will be  evaluated as  the number  of remaining
    format arguments;

 : (format t "~v$" 3 pi) ==> 3.142
 : (format t "~#$" pi)   ==> 3.1
 :             ^

 You  can omit  prefix  arguments, but  if there  are  multiple possible  prefix
 arguments, then you must use a comma to skip ones that come before the ones you
 want to use.

 : (format t "~,5F" pi) ==> 3.14159
 :             ^

 #+texinfo: @heading Modifiers

 You can also  modify the behavior of  some directives with a  colon and at-sign
 /modifiers/,  which are  placed  after  any prefix  parameters  and before  the
 directive's identifying character.  These modifiers change the  behavior of the
 directive in small  ways. In some cases  you can combine the  colon and at-sign
 modifiers to get both modifications.

 : (format t "~D" 1000000)   ==> 1000000
 : (format t "~:D" 1000000)  ==> 1,000,000
 : (format t "~@D" 1000000)  ==> +1000000
 : (format t "~:@D" 1000000) ==> +1,000,000
 :             ^

*** Basic Formatting
**** General Directives
 - =~A= :: The most general-purpose directive is =~A=, which consumes one format
   argument  of any  type and  outputs  it in  aesthetic (human-readable)  form:
   strings are output without quotation  marks or escape characters, and numbers
   are output in a natural way for the type of number.

 - =~S= :: =~S= tries  to generate output that can be read  back in with ~READ~.
   Thus,  strings  will  be  enclosed   in  quotation  marks,  symbols  will  be
   package-qualified when necessary, and so on.

 - =~:A=, =~:S= :: With a colon modifier, both the =~A= and =~S= directives emit
   =NIL= as =()= rather than =NIL=.

 - Prefix Parameters  :: Both the =~A= and  =~S= directives also take up to four
   prefix parameters,  which can  be used  to control  whether padding  is added
   after (or before  with the at-sign modifier) the value,  but those parameters
   are only really useful for generating tabular data.

 - =~%= :: emits a newline

 - =~&= ::   emits  a fresh line.  The  difference between the two  is that =~%=
   always emits a newline, while =~&= emits  one only if it's not already at the
   beginning  of a  line.

 - Prefix  Parameters ::  Both  of these  directives can  take  a single  prefix
   parameter that specifies the number of newlines to emit.

 - =~~= :: causes FORMAT to emit a literal tilde.  Also takes a prefix parameter
   to determine how many to print.

**** Character and Integer Directives
 ~FORMAT~  supports several  directives  that  can be  used  to  emit values  of
 specific types in particular ways.

***** Character Directives

 - =~C= ::  used  to emit characters.  It  takes no prefix arguments  but can be
   modified with the  colon and at-sign modifiers.  Unmodified,  its behavior is
   no different from =~A= except that it works only with characters.

 - =~:C= ::  outputs  nonprinting characters such as space, tab,  and newline by
   name.  This is  useful if you want to  emit a message to the  user about some
   character.

   : (format t "Syntax error. Unexpected character: ~:c" char)
   : ==> Syntax error. Unexpected character: Space

 - =~:@C= ::  With both the colon  and at-sign modifiers, the =~C= directive can
   print extra information  about how to enter the character  at the keyboard if
   it requires special key combinations.

***** Number Directives
 While you  can use the =~A=  and =~S= directives  to emit numbers, if  you want
 fine  control  over   how  they're  printed,  you  need  to   use  one  of  the
 number-specific directives.

 The numeric  directives can be  divided into two subcategories:  directives for
 formatting integer values and directives for formatting floating-point values.

****** Integer Directives
 Five closely related directives format  integer values: =~D=, =~X=, =~O=, =~B=,
 and =~R=.

 - =~D= :: the ~D directive outputs integers in base 10.

 - =~:D= :: with a colon modifier it adds commas.

 - =~@D= :: And with an at-sign modifier, it always prints a sign.

 - =~:@D= :: the two modifiers can be combined.

 - =~#D=  :: The  first prefix  parameter can  specify a  minimum width  for the
   output

 - =~#,'#D= :: the second parameter can specify a padding character to use.

 - =~,,'.D=  ::  the third  parameter  specifies  the  character  to use  as  the
   separator between groups and digits (defaults to a comma)

 - =~,,,4D= :: the fourth parameter specifies the number of digits per group (defaults
   to 3)

   Thus, you  can use  the directive  =~:D= without  parameters to  output large
   integers in standard format for the United States but can change the comma to
   a period and the grouping from 3 to 4 with =~,,'.,4D=.

 - =~X= =~O= =~B= :: work just like  the =~D= directive except they emit numbers
   in hexadecimal (base 16), octal (base 8), and binary (base 2).

   #+begin_example
   (format nil "~x" 1000000) ==> "f4240"
   (format nil "~o" 1000000) ==> "3641100"
   (format nil "~b" 1000000) ==> "11110100001001000000"
   #+end_example

 - =~R=   :: the  general radix  directive.  It is  a  number between  2 and  36
   (inclusive) that indicates what base to use. The remaining parameters are the
   same as the  four parameters accepted by  the ~D, ~X, ~O,  and ~B directives,
   and the colon and at-sign modifiers modify its behavior in the same way.

****** Floating-Point Directives
 Four directives format  floating-point values: =~F=, =~E=, =~G=,  and =~$=. You
 can  use the  =~F=, =~E=,  and  =~$= directives  to interpolate  floating-point
 values into text. The =~G=, or  general, floating-point directive, on the other
 hand, combines  aspects of  the =~F=  and =~E=  directives in  a way  that only
 really makes sense for generating tabular output.

 - =~F= ::    emits  its argument, which should be a  number, in decimal format,
   possibly controlling  the number  of digits  after the  decimal point.  It is
   allowed to use computerized scientific notation if the number is sufficiently
   large or small.  The second parameter controls the number  of digits to print
   after the decimal point. Use the @-sign modifier to print a sign.

   : (format nil "~f" pi)   ==> "3.141592653589793d0"
   : (format nil "~,4f" pi) ==> "3.1416"

 - =~E= ::  always emits  numbers in computerized  scientific notation.  Use the
   @-sign modifier to print a sign.

   : (format nil "~e" pi)   ==> "3.141592653589793d+0"
   : (format nil "~,4e" pi) ==> "3.1416d+0"

 - =~$=   ::  monetary,  directive is similar to =~F=. With  no parameters, it's
   basically equivalent to =~,2F=. To modify  the number of digits printed after
   the decimal  point, you use the  first parameter, while the  second parameter
   controls the minimum number of digits  to print before the decimal point. Use
   the @-sign modifier to print a sign.

   : (format nil "~$" pi)    ==> "3.14"
   : (format nil "~2,4$" pi) ==> "0003.14"

**** English Language Directives
 These directives  allow you to  emit numbers as  English words, to  emit plural
 markers based on the value of a  format argument, and to apply case conversions
 to sections of FORMAT's output.

 - =~R= :: when used with no base  specified, prints numbers as English words or
   Roman numerals

   When used with no  prefix parameter and no modifiers, it  emits the number in
   words as a cardinal  number

   With the  colon modifier,  it emits  the number  as an  ordinal

   And with an  at-sign modifier, it emits  the number as a  Roman numeral; with
   both an  at-sign and a  colon, it emits  "old-style" Roman numerals  in which
   fours and nines are written as IIII and VIIII instead of IV and IX.

 - =~P= :: simply emits an s  unless the corresponding argument is 1. Typically,
   however, you'll use ~P with the  colon modifier, which causes it to reprocess
   the previous format argument.

   : (format nil "~r file~:p" 10) ==> "ten files"

   With the  at-sign modifier, which  can be  combined with the  colon modifier,
   =~P= emits either =y= or =ies=.

   : (format nil "~r famil~:@p" 10) ==> "ten families"

 - =~(= :: allows you to control the case  of text in the output. all the output
   generated by the  portion of the control string between  the two markers will
   be converted to all lowercase.

   You can modify ~(  with an at sign to make it capitalize  the first word in a
   section of text

   with a colon to make it to capitalize all words,

   with both modifiers to convert all text to uppercase.

   #+begin_example
   (format nil "~(~a~)" "tHe Quick BROWN foX")   ==> "the quick brown fox"
   (format nil "~@(~a~)" "tHe Quick BROWN foX")  ==> "The quick brown fox"
   (format nil "~:(~a~)" "tHe Quick BROWN foX")  ==> "The Quick Brown Fox"
   (format nil "~:@(~a~)" "tHe Quick BROWN foX") ==> "THE QUICK BROWN FOX"
   #+end_example

*** Controlled Formatting
 FORMAT  provides several  directives that  implement simple  control constructs
 within the control string.

**** Conditional Directive

 - =~[...~;...~:;...~]= ::  This directive is closed  by a corresponding =~]=,  and in
   between  are a  number of  clauses separated  by =~;=.  The job  of the  =~[=
   directive is to pick one of the clauses, which is then processed by ~FORMAT~

   With no modifiers or parameters, the clause is selected by numeric index; the
   =~[= directive  consumes a  format argument,  which should  be a  number, and
   takes the =nth=  (zero-based) clause where =N= is the  value of the argument.
   If the value of  the argument is greater than the  number of clauses, nothing
   is printed. However,  if the last clause separator is  =~:;= instead of =~;=,
   then the last clause serves as a default clause.

   #+begin_example
   (format nil "~[cero~;uno~;dos~]" 0) ==> "cero"
   (format nil "~[cero~;uno~;dos~]" 1) ==> "uno"
   (format nil "~[cero~;uno~;dos~]" 2) ==> "dos"
   (format nil "~[cero~;uno~;dos~]" 3) ==> ""
   (format nil "~[cero~;uno~;dos~:;mucho~]" 3)   ==> "mucho"
   (format nil "~[cero~;uno~;dos~:;mucho~]" 100) ==> "mucho"
   #+end_example

 - =~#[...~;...~:;...~]= ::    It's also  possible to specify  the clause  to be
   selected using a  prefix parameter. =#= used as a  prefix parameter means the
   number of arguments remaining to be processed.

   : (defparameter *list-etc*
   :    "~#[NONE~;~a~;~a and ~a~:;~a, ~a~]~#[~; and ~a~:;, ~a, etc~].")

 - =~:[...~]= :: With  a colon modifier, the =~[= can  contain only two clauses;
   the directive  consumes a single argument  and processes the first  clause if
   the argument is NIL and the second clause is otherwise.

   : (format t "~:[FAIL~;pass~]" test-result)

 - =~@[...~]= ::  Finally, with an at-sign modifier, the =~[= directive can have
   only one  clause. The directive consumes  one argument and, if  it's non-NIL,
   processes the  clause after backing up  to make the argument  available to be
   consumed again.

   #+begin_example
   (format nil "~@[x = ~a ~]~@[y = ~a~]" 10 20)   ==> "x = 10 y = 20"
   (format nil "~@[x = ~a ~]~@[y = ~a~]" 10 nil)  ==> "x = 10 "
   (format nil "~@[x = ~a ~]~@[y = ~a~]" nil 20)  ==> "y = 20"
   (format nil "~@[x = ~a ~]~@[y = ~a~]" nil nil) ==> ""
   #+end_example

**** Iteration Directive

 - =~{...~}= :: This directive tells ~FORMAT~  to iterate over the elements of a
   list or over the implicit list of  the format arguments. The text between the
   two markers is processed as a  control string, which draws its arguments from
   the list  consumed by  the =~{= directive.  ~FORMAT~ will  repeatedly process
   this control string for as long as  the list being iterated over has elements
   left.

 - =~{...~^...~}= ::  Within  the body of a =~{= directive,  the =~^= causes the
   iteration to  stop immediately,  without processing the  rest of  the control
   string, when  no elements  remain in  the list. Thus,  to avoid  printing the
   comma and space after the last element of a list, you can precede them with a
   =~^=.

   : (format nil "~{~a~^, ~}" (list 1 2 3)) ==> "1, 2, 3"

 - =~@{...~}= ::  With an at-sign modifier, =~@{= processes the remaining format
   arguments as a list.

   : (format nil "~@{~a~^, ~}" 1 2 3) ==> "1, 2, 3"

 - =~{...~#[...~]...~}=  ::   Within the body of a =~{...~}=, the special prefix
   parameter =#= refers to the number of  items remaining to be processed in the
   list rather than the number of  remaining format arguments. You can use that,
   along with the =~[= directive, to  print a comma-separated list with an "and"
   before the last item like this:

   : (format nil "~{~a~#[~;, and ~:;, ~]~}" (list 1 2 3)) ==> "1, 2, and 3"

   However, that doesn't really work right if the list is two items long because
   it adds an extra comma.

 - =~{...~@{...~}...~}= ::   The following  takes advantage  of the  behavior of
   =~@{= when  nested inside another  =~{= or =~@{= directive--it  iterates over
   whatever items remain in the list being  iterated over by the outer =~{=. You
   can combine that with a =~#[=  directive to make the following control string
   for formatting lists according to English grammar:

   : (defparameter *english-list*
   :    "~{~#[~;~a~;~a and ~a~:;~@{~a~#[~;, and ~:;, ~]~}~]~}")

 - =<empty>= ::  If you wanted to print something special such as =<empty>= when
   the list was empty,  you have a couple ways to do it.  Perhaps the easiest is
   to put the  text you want into  the first (zeroth) clause of  the outer =~#[=
   and then add a colon modifier to the closing =~}= of the outer iteration--the
   colon forces  the iteration  to be  run at least  once, even  if the  list is
   empty, at which point ~FORMAT~ processes the zeroth clause of the conditional
   directive.

   : (defparameter *english-list*
   :    "~{~#[<empty>~;~a~;~a and ~a~:;~@{~a~#[~;, and ~:;, ~]~}~]~:}")

 - Additional =~{=  ::   The =~{=  directive provides even more  variations with
   different combinations  of prefix  parameters and modifiers.  You can  use an
   integer prefix parameter to limit the  maximum number of iterations and that,
   with a colon modifier, each element of the list (either an actual list or the
   list constructed by the =~@{= directive) must itself be a list whose elements
   will  then be  used as  arguments  to the  control string  in the  =~:{...~}=
   directive.

**** Jump Directive
 - =~*= :: The =~*=  directive, allows you to jump around in  the list of format
   arguments. In  its basic form,  without modifiers,  it simply skips  the next
   argument, consuming it  without emitting anything.

 - =~:*= :: More  often, however, it's used with a  colon modifier, which causes
   it to move backward, allowing the same argument to be used a second time. You
   can use =~:*= to print a numeric argument once as a word and once in numerals
   like this:

   : (format nil "~r ~:*(~d)" 1) ==> "one (1)"

   Or you could  implement a directive similar to =~:P=  for an irregular plural
   by combing =~:*= with =~[=.

   #+begin_example
   (format nil "I saw ~r el~:*~[ves~;f~:;ves~]." 0) ==> "I saw zero elves."
   (format nil "I saw ~r el~:*~[ves~;f~:;ves~]." 1) ==> "I saw one elf."
   (format nil "I saw ~r el~:*~[ves~;f~:;ves~]." 2) ==> "I saw two elves."
   #+end_example

 - =~{...~*...= ::   Within an =~{= directive,  =~*= skips or backs  up over the
   items in  the list. For instance,  you could print  only the keys of  a plist
   like this:

   : (format nil "~{~s~*~^ ~}" '(:a 10 :b 20)) ==> ":A :B"

 - =~<p>*= ::

   The =~*= directive can also be given a prefix parameter.

   With no  modifiers or with the  colon modifier, this parameter  specifies the
   number of arguments to move forward or  backward and defaults to one

 - =~<p>@*=  :: With  an at-sign  modifier,  the prefix  parameter specifies  an
   absolute, zero-based  index of the argument  to jump to, defaulting  to zero.
   The  at-sign variant  of =~*=  can be  useful if  you want  to use  different
   control strings to generate different messages  for the same arguments and if
   different messages need to use the arguments in different orders.

* Common Lisp Packages
Avoiding name  conflicts between  independently developed  pieces of  code.  In
Common Lisp the  namespace problem boils down to a  question of controlling how
the reader translates  textual names into symbols: if you  want two occurrences
of the same name  to be considered the same by the evaluator,  you need to make
sure the  reader uses the same  symbol to represent each  name.  Conversely, if
you want two names  to be considered distinct, even if they  happen to have the
same textual name, you need the reader to create different symbols to represent
each name.

** QuickLisp Library Manager
- [[https://www.quicklisp.org/beta/][QuickLisp Home]]
- [[http://blog.quicklisp.org][Quicklisp News]]


It works  with your existing  Common Lisp implementation to  download, install,
and load any of over 1,500 [[https://www.quicklisp.org/beta/releases.html][libraries]] with a few simple commands.[fn:5] It works
with:

- ABCL,
- Allegro CL,
- Clasp,
- Clozure CL,
- CLISP,
- CMUCL,
- ECL,
- LispWorks,
- MKCL,
- SBCL, and
- Scieneer CL, on
- Linux,
- Mac OS X, and
- Windows.


QuickLisp depends on ASDF files to define Lisp "systems." A Lisp system is what
other languages call a  library or module, i.e., a set of files,  and a list of
any other systems that this system depends on.<

*** QuickLisp Installation and Setup
 To get started with the Quicklisp beta, download and load:
 : https://beta.quicklisp.org/quicklisp.lisp

 Then, to install and configure SLIME for QuickLisp:
 : (ql:quickload "quicklisp-slime-helper")

 The  following shell  script will  install ~quicklisp~  for your  user account
 using Clozure Common Lisp (CCL), update its init file, and configure it to use
 SLIME[fn::Other  implementations  will  have  slightly  different  commandline
 requirements.]:

 #+caption: Shell Script to Install Quicklisp Using CCL
 #+name:ccl-quicklisp-install
 #+header: :dir ~
 #+begin_src sh :exports code :results verbatim output
   [[ ! -d ".quicklisp" ]] && { \
   echo "Installing quicklisp...";
   mkdir -v ./.quicklisp;
   curl -O https://beta.quicklisp.org/quicklisp.lisp;
   # The installation script is expecting the user to hit the <RETURN> key;
   # as well, the @@texinfo:@opt{@@--batch@@texinfo:}@@ expects an EOF marker.
   # The use of ~echo~ seems to satisfy both requirements.
   echo | \
   ccl -Q --batch \
          --load  quicklisp.lisp \
          --eval '(quicklisp-quickstart:install :path "./.quicklisp")' \
          --eval '(ql:add-to-init-file)' \
          --eval '(ql:quickload "quicklisp-slime-helper")';
   rm quicklisp.lisp;
   echo "Done installing.";
   } || { echo "Quicklisp is already installed."; }
 #+end_src

 #+RESULTS: ccl-quicklisp-install
 #+begin_example
 Installing quicklisp...
 mkdir: created directory './.quicklisp'

   ==== quicklisp quickstart 2015-01-28 loaded ====

     To continue with installation, evaluate: (quicklisp-quickstart:install)

     For installation options, evaluate: (quicklisp-quickstart:help)

 ; Fetching #<URL "http://beta.quicklisp.org/client/quicklisp.sexp">
 ; 0.82KB
 ==================================================
 838 bytes in 0.00 seconds (897.32KB/sec)
 ; Fetching #<URL "http://beta.quicklisp.org/client/2020-01-04/quicklisp.tar">
 ; 250.00KB
 ==================================================
 256,000 bytes in 0.04 seconds (5591.84KB/sec)
 ; Fetching #<URL "http://beta.quicklisp.org/client/2015-09-24/setup.lisp">
 ; 4.94KB
 ==================================================
 5,054 bytes in 0.00 seconds (6434.87KB/sec)
 ; Fetching #<URL "http://beta.quicklisp.org/asdf/2.26/asdf.lisp">
 ; 194.07KB
 ==================================================
 198,729 bytes in 0.05 seconds (4305.33KB/sec)
 ; Fetching #<URL "http://beta.quicklisp.org/dist/quicklisp.txt">
 ; 0.40KB
 ==================================================
 408 bytes in 0.00 seconds (543.57KB/sec)
 Installing dist "quicklisp" version "2020-10-16".
 ; Fetching #<URL "http://beta.quicklisp.org/dist/quicklisp/2020-10-16/releases.txt">
 ; 468.69KB
 ==================================================
 479,939 bytes in 0.07 seconds (6496.51KB/sec)
 ; Fetching #<URL "http://beta.quicklisp.org/dist/quicklisp/2020-10-16/systems.txt">
 ; 341.59KB
 ==================================================
 349,788 bytes in 0.05 seconds (6902.90KB/sec)

   ==== quicklisp installed ====

     To load a system, use: (ql:quickload "system-name")

     To find systems, use: (ql:system-apropos "term")

     To load Quicklisp every time you start Lisp, use: (ql:add-to-init-file)

     For more information, see http://www.quicklisp.org/beta/

 I will append the following lines to #P"/Users/minilolh/.ccl-init.lisp":

   ;;; The following lines added by ql:add-to-init-file:
   #-quicklisp
   (let ((quicklisp-init (merge-pathnames ".quicklisp/setup.lisp" (user-homedir-pathname))))
     (when (probe-file quicklisp-init)
       (load quicklisp-init)))

 Press Enter to continue.
 To load "quicklisp-slime-helper":
   Load 1 ASDF system:
     asdf
   Install 3 Quicklisp releases:
     alexandria quicklisp-slime-helper slime
 ; Fetching #<URL "http://beta.quicklisp.org/archive/slime/2020-09-25/slime-v2.26.tgz">
 ; 802.88KB
 ==================================================
 822,146 bytes in 0.11 seconds (7054.23KB/sec)
 ; Fetching #<URL "http://beta.quicklisp.org/archive/alexandria/2020-09-25/alexandria-20200925-git.tgz">
 ; 53.45KB
 ==================================================
 54,730 bytes in 0.02 seconds (3438.89KB/sec)
 ; Fetching #<URL "http://beta.quicklisp.org/archive/quicklisp-slime-helper/2015-07-09/quicklisp-slime-helper-20150709-git.tgz">
 ; 2.16KB
 ==================================================
 2,211 bytes in 0.00 seconds (2898.23KB/sec)
 ; Loading "quicklisp-slime-helper"
 [package swank-loader]............................
 [package swank/backend]...........................
 [package swank/rpc]...............................
 [package swank/match].............................
 [package swank-mop]...............................
 [package swank]...................................
 [package swank-monitor]...........................
 [package swank/ccl]...............................
 [package cross-reference].........................
 [package swank/gray]..............................
 ...............................
 ;Compiling "/Users/minilolh/.quicklisp/dists/quicklisp/software/slime-v2.26/contrib/swank-util.lisp".....
 ;Compiling "/Users/minilolh/.quicklisp/dists/quicklisp/software/slime-v2.26/contrib/swank-repl.lisp"....................
 [package swank-repl]...
 ;Compiling "/Users/minilolh/.quicklisp/dists/quicklisp/software/slime-v2.26/contrib/swank-c-p-c.lisp".....
 ;Compiling "/Users/minilolh/.quicklisp/dists/quicklisp/software/slime-v2.26/contrib/swank-arglists.lisp"............................
 ...
 ;Compiling "/Users/minilolh/.quicklisp/dists/quicklisp/software/slime-v2.26/contrib/swank-fuzzy.lisp".......
 ;Compiling "/Users/minilolh/.quicklisp/dists/quicklisp/software/slime-v2.26/contrib/swank-fancy-inspector.lisp".................
 ;Compiling "/Users/minilolh/.quicklisp/dists/quicklisp/software/slime-v2.26/contrib/swank-presentations.lisp".....
 ;Compiling "/Users/minilolh/.quicklisp/dists/quicklisp/software/slime-v2.26/contrib/swank-presentation-streams.lisp".....
 ;Compiling "/Users/minilolh/.quicklisp/dists/quicklisp/software/slime-v2.26/contrib/swank-asdf.lisp".........
 ;Compiling "/Users/minilolh/.quicklisp/dists/quicklisp/software/slime-v2.26/contrib/swank-package-fu.lisp"...
 ;Compiling "/Users/minilolh/.quicklisp/dists/quicklisp/software/slime-v2.26/contrib/swank-hyperdoc.lisp"....
 ;Compiling "/Users/minilolh/.quicklisp/dists/quicklisp/software/slime-v2.26/contrib/swank-mrepl.lisp".....................
 [package swank-api]...............................
 [package swank-mrepl]..
 ;Compiling "/Users/minilolh/.quicklisp/dists/quicklisp/software/slime-v2.26/contrib/swank-trace-dialog.lisp"..............................
 [package swank-trace-dialog]..
 ;Compiling "/Users/minilolh/.quicklisp/dists/quicklisp/software/slime-v2.26/contrib/swank-macrostep.lisp".......................
 [package swank-macrostep]..
 ;Compiling "/Users/minilolh/.quicklisp/dists/quicklisp/software/slime-v2.26/contrib/swank-quicklisp.lisp"...
 .......................
 [package alexandria]..............................
 ..................................................
 ..................................................
 [package alexandria-2]............................
 [package quicklisp-slime-helper]
 slime-helper.el installed in "/Users/minilolh/.quicklisp/slime-helper.el"

 To use, add this to your ~/.emacs:

   (load (expand-file-name "~/.quicklisp/slime-helper.el"))
   ;; Replace "sbcl" with the path to your implementation
   (setq inferior-lisp-program "sbcl")


 Done installing.
 #+end_example

*** QuickLisp Load

 To load Quicklisp into your Common Lisp session after the initial installation,
 (unless ~add-to-init-file~ has been run) load the file ~setup.lisp~:

 : (load "~/quicklisp/setup.lisp")

 To load software, use:

 : (ql:quickload "system-name")

 Quicklisp will automatically download any  supporting software it needs to load
 the system.

 By default, ~ql:quickload~ hides most compilation and loading output, including
 warnings, and shows progess as a series  of dots. You can show full compilation
 and loading output by passing =:verbose t= as arguments to ~ql:quickload~. This
 output can be especially helpful when reporting and troubleshooting problems.
 There is also a =:silent t= mode.

 : (ql:quickload “system-name” :verbose t)
 : (ql:quickload "system-name" :silent t)

 #+texinfo: @heading ASDF Manifest File

 : (ql:write-asdf-manifest-file)
 now includes systems from the local-projects directories.

*** Quicklisp Updates
 To get updated software, use ~ql:update-dist~.

 Be sure to first start ~slime~:
 #+begin_src lisp :results output
 (ql:update-dist "quicklisp")
 #+end_src

 #+RESULTS:
 : You already have the latest version of "quicklisp": 2020-10-16.

 To update the Quicklisp client use ~ql:update-client~.

 Be sure to first start ~slime~:
 #+begin_src lisp :results output
 (ql:update-client)
 #+end_src

 #+RESULTS:
 : The most up-to-date client, version 2020-01-04, is already installed.

*** QuickLisp Libraries
 To find out what's available in Quicklisp, use:

 : (ql:system-apropos substring)

 To see what systems depend on a particular system, use:

 : (ql:who-depends-on system-name)

*** QuickLisp Unload
 To remove software, use:

 : (ql:uninstall system-name)

 An uninstall does the following:

 - Deletes the system's tarball archive and unpacked source files
 - Deletes Quicklisp metadata files associated with the system
 - Clears ASDF's system cache via asdf:clear-system.


 Uninstalling does not alter  the current Lisp session in any  other way; if the
 given  system has  been  loaded, it  remains loaded  and  accessible until  the
 session is ended.
** Another System Definition Facility---ASDF
#+cindex:asdf
"ASDF is the de facto standard build facility for Common Lisp."

- [[https://common-lisp.net/project/asdf/][ASDF Project Website]]
- [[https://www.common-lisp.net/project/asdf/asdf/index.html][ASDF Manual]]

: (require "asdf")


The latest release is 3.3.4, published on February 14th, 2019.
*** What asdf Is
ASDF is what Common Lisp hackers use to build and load software.

ASDF 3 contains two parts: ~asdf/defsystem~ and ~uiop~.

~asdf/defsystem~  is the  part that  people usually  refer to  as =ASDF=,  with
~uiop~ being only  a supporting library, that happens to  be distributed at the
same time, by necessity.

**** asdf/defsystem
#+cindex:asdf/defsystem
is a tool to *describe* how Lisp source code is organized in /systems/, and how
to *build* and *load* these systems. The  build happens based on a plan in term
of /actions/  that depend on  previous actions; the  plan is computed  from the
structure of the systems.

Typical /actions/ consist of:
- *compiling* a Lisp source file
- *loading* the resulting compilation output


You  must  typically compile  and  load  files  that define  packages,  macros,
variables,  before  you  may  compile  and load  other  files  that  use  them.
Importantly, ASDF builds all software in  the current Lisp image, as opposed to
building software into separate processes.

**** uiop

#+cindex:uiop
the  /Utilities for  Implementation- and  OS- Portability/,  formerly known  as
~asdf/driver~, is a Common Lisp  portability library and runtime support system
that helps you write Common Lisp software in a portable way.

~uiop~ is distributed as part of =ASDF=:  its source code is transcluded in the
single-file ~asdf.lisp~ being distributed and the precompiled fasls provided by
Lisp implementations. =ASDF= relies heavily on it for its portability layer and
runtime support, particularly so as  to handle pathnames and filesystem access.
~uiop~  is  useful  on  its  own  and can  also  be  compiled  and  distributed
separately.

*** What asdf Is Not
#+cindex:Quicklisp
=ASDF= will  not download missing  software components  for you. For  that, you
want  =Quicklisp=, that  builds  upon  =ASDF=, and  is  great  for pulling  and
installing tarballs of packages you may depend upon.

#+cindex:clbuild
We also recommend [[https://common-lisp.net/project/clbuild/][~clbuild~]], that now  builds upon =Quicklisp=, as a great tool
for  pulling from  version  control packages  you  need to  modify  or want  to
contribute to.

#+cindex:asdf-install
We  recommend you  should not  use ~asdf-install~  anymore, as  it is  an older
similar piece of software that is both unmaintained and obsolete.

#+cindex:cl-launch
#+cindex:buildapp
#+cindex:roswell
=ASDF= is also  not a tool to build  or run Common Lisp software  from the Unix
command-line. For that, you want:
- [[https://cliki.net/cl-launch][~cl-launch~]],
- [[https://www.xach.com/lisp/buildapp/][~buildapp~]], or
- [[https://github.com/roswell/roswell][~roswell~]]
*** Getting started with ASDF
    :PROPERTIES:
    :author:   Michael Anckaert
    :date:     2020-07-29
    :END:
- [[https://sinax.be/blog/lisp/getting-started-with-asdf.html][Getting started with ASDF]]

In this article  I will try and explain  what ASDF is from a  beginner point of
view. As a new Lisp developer you're  bound to run into ASDF sooner than later.
ASDF  is a  defacto standard  in the  Lisp world  so a  basic understanding  is
essential to being productive.

** Common Lisp Package System
*** The Reader and the Evaluator
 #+cindex:reader
 #+cindex:evaluator
 Common Lisp defines two "black boxes", one that translates text into Lisp
 objects and another that implements the semantics of the language in terms of
 those objects.  The first box is called the "reader", and the second is call
 the "evaluator".

*** Syntax of Names

 #+cindex:package
 #+cindex:symbol
 #+cindex:name, package
 #+findex:find-packagea
 A /package/ is  like a table that  maps strings to symbols. Each  package has a
 /name/, which can be used to find the package using the function:
 - ~find-package.~ ::

 #+cindex:name-to-symbol mapping
 #+findex:find-symbol
 #+findex:intern
 The two key functions that the reader uses to access the name-to-symbol
 mappings in a package are:

 #+cindex:accessible symbol
 - ~find-symbol~ :: looks in the package for  a symbol with the given string for
   a name and returns it, or =nil= if  no symbol is found. All the symbols found
   in a  given package using ~find-symbol~  are said to be  /accessible/ in that
   package. In other words, the /accessible/ symbols in a package are those that
   can be referred to with unqualified names when the package is current.

   #+cindex:present symbol
   #+cindex:inherited symbol
   #+cindex:using a package
   #+cindex:external symbol
   #+cindex:export
   A symbol  can be  accessible in two  ways. The *first*  is for  the package's
   name-to-symbol table  to contain an entry  for the symbol, in  which case the
   symbol  is  /present/ in  the  package.  The *second*  way  a  symbol can  be
   accessible in a  package is if the package /inherits/  it. A package inherits
   symbols from  other packages by  /using/ the other packages.  Only /external/
   symbols in the  used packages are inherited.  A symbol is made  external in a
   package by /exporting/ it. An exported symbol  can be referred to by use of a
   single colon qualified name.

 - ~intern~ :: will return an existing symbol; otherwise it creates a new symbol
   with the string as its name and adds it to the package.

   #+cindex:home package
   When the  reader interns  a new  symbol in the  package, it  is added  to the
   package's  name-to-symbol table.  The  package  in which  a  symbol is  first
   interned is called the symbol's /home package/.

 Both of these functions take a string and, optionally, a package. The =package=
 argument defaults to the value of  the global variable =*PACKAGE*=, also called
 the /current package/.

 #+cindex:names
 #+cindex:unqualified name
 #+cindex:package-qualified name
 #+cindex:symbol object
 #+cindex:reader
 #+cindex:evaluator
 - unqualified names ::  Most names you  use are /unqualified/, that is, contain
   no colons. When the reader reads such a name, it translates it to a symbol by
   converting  any unescaped  letters  to uppercase  and  passing the  resulting
   string to  ~intern~. Thus, each  time the reader reads  the same name  in the
   same package,  it will  get the  same symbol object.  The evaluator  uses the
   object  identity of  symbols to  determine which  function, variable,  or the
   program element a given symbol refers to.

 - package-qualified  names ::  A name  containing either  a single  colon or  a
   double  colon  is  a  /package-qualified  name/.  When  the  reader  reads  a
   package-qualified name, it  splits the name on the colons  and uses the first
   part as the  name of a package and  the second part as the name  of a symbol.
   The reader  looks up  the appropriate  package and uses  it to  translate the
   symbol name to a symbol object.

   #+cindex:external symbol
   #+cindex:export
 - external symbol  :: A name  containing only a single  colon must refer  to an
   /external symbol/---one that the package /exports/ for public use.

 - symbol :: A double-colon name can refer to any symbol from the named package.

   #+cindex:keyword symbol
   #+cindex:package =KEYWORD=
   #+cindex:=KEYWORD= package
 - keyword symbol :: written with names  starting with a colon. Such symbols are
   interned in the package named  =KEYWORD= and automatically exported. When the
   reader interns a symbol in the =KEYWORD=, it also defines a constant variable
   with the symbol as both its name and  value. This is why you can use keywords
   in argument lists without quoting them--when they appear in a value position,
   they evaluate to themselves. The names  of keyword symbols, like all symbols,
   are converted  to all uppercase by  the reader before they  are interned. The
   name does not include the leading colon.

   #+cindex:uninterned symbol
 - uninterned symbol :: are written with  a leading =#:=. These names (minus the
   =#:=) are converted to uppercase as  normal and then translated into symbols,
   but the symbols are not interned in any package; each time the reader reads a
   =#:= name,  it creates  a new symbol.  You will rarely,  if ever,  write this
   syntax yourself, but you will sometimes see it when you print an s-expression
   containing symbols returned by the function =GENSYM=.

   : (gensym) ==> #:G3128

   #+cindex:shadowing symbol
 - shadowing  symbol   ::   To   keep  the  mappings   from  names   to  symbols
   deterministic, the package system allows only  one symbol to be accessible in
   a given  package for  each name.  That is,  a package  cannot have  a present
   symbol and  an inherited symbol with  the same name or  inherit two different
   symbols,  from different  packages,  with  the same  name.  However, you  can
   resolve  conflicts by  making one  of  the accessible  symbols a  /shadowing/
   symbol, which  makes the other  symbols of  the same name  inaccessible. Each
   package maintains a list of shadowing symbols.

   #+cindex:imported symbol
 - imported symbol :: An existing symbol  can be /imported/ into another package
   by adding it to the package's name-to-symbol table. Thus, the same symbol can
   be present in multiple packages.

   #+cindex:uninterened symbol
 - uninterned symbol   :: A present symbol  can be /uninterned/ from  a package,
   which causes it to be removed from  the name-to-symbol table, and, if it is a
   shadowing symbol, from the shadowing list. A symbol that isn't present in any
   package is called an uninterned symbol, can  no longer be read by the reader,
   will be printed using the =#:= syntax.

*** The Three Standard Packages
 When  you  first  start  Lisp,  the  value  of  =*PACKAGE*=  is  typically  the
 =COMMON-LISP-USER= package, also known as =CL-USER=. =CL=USER= uses the package
 =COMMON-LISP=, which exports all the names defined by the language standard.

 When you type an expression at the =REPL=, all the names of standard functions,
 macros, variables,  and so on will  be translated to the  symbols exported from
 =COMMON-LISP=, and all  other names will be interned  in the =COMMON-LISP-USER=
 package.

 The  =REPL= cannot  start  in the  =COMMON-LISP= package  because  you are  not
 allowed to intern  new symbols in it; =COMMON-LISP-USER= serves  as a "scratch"
 package where you can  create your own names while still  having easy access to
 all the symbols in =COMMON-LISP=.

 The  third standard  package is  the =KEYWORD=  package, the  package the  Lisp
 reader uses to intern names starting with a colon.

*** Defining Your Own Packages
#+cindex:package
Packages provide  basic control over  namespaces by controlling how  the reader
translates textual  names into symbol  objects. It is  not until later,  in the
evaluator, that the symbol is interpreted as the name of a function or variable
or whatever. It does not make sense  to talk about "exporting a function" or "a
variable" from a  package. You can export symbols to  make certain names easier
to refer to,  but the package system  does not allow you to  restrict how those
names are used.

#+findex:DEFPACKAGE
You define  new packages with the  macro =DEFPACKAGE=, which allows  you to not
only create the package  but to specify what packages it  uses, what symbols it
exports,  and what  symbols  it  imports from  other  packages  and to  resolve
conflicts by creating shadowing symbols.

You can define a simple package like this:

#+begin_src lisp
  (defpackage :com.gigamonkeys.email-db
    (:use :common-lisp))
#+end_src

This defines  a package name  =COM.GIGAMONKEYS.EMAIL-DB= that inherits  all the
symbols exported by the =COMMON-LISP= package.

#+cindex:string designator
Packages and symbols  are named with strings. However, in  a ~DEFPACKAGE~ form,
you can specify the names of  packages and symbols with /string designators/. A
string designator is  either a string, which desigates itself;  a symbol, which
designates its  name; or a  character, which designates a  one-character string
containing just  the character. Using  keyword symbols  is a common  style that
allows you to write the names  in lowercase---the reader will convert the names
to uppercase for  you. You could also write the  =DEFPACKAGE= with strings, but
then you  have to write them  in all uppercase  because the true names  of most
symbols and packages are uppercase because  of the case conversion performed by
the reader.

To read code in this package, you need  to make it the current package with the
~IN-PACKAGE~ macro:

#+begin_src lisp
  (in-package :com.gigamonkeys.email-db)
#+end_src

If  you type  this  expression at  the  =REPL=,  it will  change  the value  of
=*PACKAGE*=,  affecting how  the =REPL=  reads subsequent  expressions. If  you
include an ~IN-PACKAGE~ in  a file that is loaded with  ~LOAD~ or compiled with
~COMPILE-FILE~,  it  will change  the  package,  affecting the  way  subsequent
expressions in the file are read.  ~IN-PACKAGE~ expands into code that will run
when the file is compiled by ~COMPILE-FILE~ as well as when the file is loaded,
changing the way the reader reads the rest of the file during compilation.

With the current package set to the =COM.GIGAMONKEYS.EMAIL-DB= package, other
than names inherited from the =COMMON-LISP= package, you can use any names you
want for whatever purpose you want.
*** Packaging Reusable Libraries
Define a new package, but export certain  names to make them available to other
packages.

#+begin_src lisp
  (defpackage :com.gigamonkeys.email-db
    (:use :common-lisp)
    (:export :open-db
	     :save
	     :store))
#+end_src

The   =:export=   clause   specifies   names   that   will   be   external   in
=COM.GIGMONKEYS.TEXT-DB= and thus accessible in packages that =:use= it.  After
you have defined this package, you can change the definition of the main
application package to the following:

#+begin_src lisp
  (defpackage :com.gigamonkeys.email-db
    (:use :common-lisp :com.gigamonkeys.text-db))
#+end_src

Now  case written  in =COM.GIGMONKEYS.EMAIL-DB=  can use  unqualified names  to
refer    to    the   exported    symbols    from    both   =COMMON-LISP=    and
=COM-GIGAMONKEYS.TEXT-DB=.  All  other  names  will  continue  to  be  interned
directly in the =COM.GIGAMONKEYS.EMAIL-DB= package.

*** Importing Individual Names
You  can import  an  individual symbol  with an  =:import-from=  clause in  the
=DEFPACKAGE=.  For example:

#+begin_src lisp
  (defpackage :com.gigamonkeys.email-db
    (:use :common-lisp :com.gigamonkeys.text-db)
    (:import-from :com.acme.email :parse-email-address))
#+end_src

Now  anywhere   the  name   ~parse-email-address~  appears   in  code   in  the
=COM.GIGAMONKEYS.EMAIL-DB=  package,  it  will  be  read  as  the  symbol  from
=COM.ACME.EMAIL=. If  you need  to import  more than one  symbol from  a single
package, you  can include  multiple names  after the package  name in  a single
=:import-from= clause. A =DEFPACKAGE=  can also include multiple =:import-from=
clauses in order to import symbols from different packages.

*** Shadowing Individual Names

** Common Lisp Packages for JSON
*** FranzInc st-json
- https://github.com/franzinc/st-json

** Common Lisp Packages for CSV
*** cl-csv
 "A common lisp library providing easy csv reading and writing"

 - https://github.com/AccelerationNet/cl-csv


 This library aims to simplify working with csvs to the bare minimum of tedium

 - reads/writes csvs from/to strings, streams and files
 - support  streaming  reads  (allowing  processing  very  large  csvs,  through
   read-csv's row-fn paramter)
 - supports custom data formating
 - settable quote, separator and quote-escapes
 - supports multiline quoted data
 - A test suite
 - Detailed state about  the process on error (line number,  column number, char
   index), current collection state
*** csv-parser
"Some hacks on top of Alain Picard's CSV parser"

- https://github.com/sharplispers/csv-parser
- [[https://quickref.common-lisp.net/csv-parser.html][The csv-parser Reference Manual]]

**** Alain Picard's CSV Parser Code
     :PROPERTIES:
     :cite:     http://mirror.informatimago.com/lisp/members.optusnet.com.au/apicard/csv-parser.lisp
     :END:
#+name:csv-parser.lisp
#+begin_src lisp
;;                      -*- mode: lisp -*-
;;
;; CSV parsing/writing utilities, a la Microsoft Excel.
;;
;; Author: Alain Picard <apicard@optushome.com.au>
;;         (also alain.picard@memetrics.com)
;;
;; Version: 0.2
;; File: $Id: csv-parser.lisp,v 1.2 2003/12/09 03:52:09 ap Exp $
;;
;; License:
;; This code is placed under the Lesser GNU Public License (LGPL)
;; (see http://www.fsf.org/licenses/lgpl.html) as
;; clarified for Lisp by Franz when they released AllegroServe (see
;; http://allegroserve.sourceforge.net/license-allogroserve.txt)
;;
;; What this clarification basically means is that compiling this
;; file and loading it into your lisp image, either at time of
;; delivery or runtime, does not make your program a derivative of
;; this one.  YOU ARE EXPRESSLY PERMITTED TO LOAD THIS FILE INTO
;; YOUR LISP IMAGE, AT ANY TIME, FOR ANY AND ALL (INCLUDING COMMERCIAL)
;; PURPOSES.  In particular, clause 5 of the LGPL is NOT invoked
;; by you embedding or loading this code, interpeted or compiled,
;; into your application.
;;
;; Of course, if you make modifications to this file, then the terms
;; of the LGPL hold, and you must redistribute the sources of this
;; file and your modifications with your application.
;;
;; Lastly, if you DO make useful changes to this code, I would
;; appreciate receiving the changes (though this NOT a requirement
;; of the license of this code.)
;;
;;
;; This software is "as is", and has no warranty of any kind.  The
;; author assumes no responsibility for the consequences of any use
;; of this software.
;;
;;
;; Notes
;; -----
;;  Differences from Faré's CSV reader:
;;
;;  * this one can import DOS formatted files into a unix image,
;;    and not have the redundant ^M splattered at the end of the fields.
;;    This is important when processing a file on a Unix server which
;;    is being uploaded via HTTP by some poor schmuck on a windoze box.
;;
;;  * Handles empty trailing fields properly
;;
;;  * comes with test suite, to see the semantics I've chosen to implement
;;
;;  * I've included a couple of high-level goodies, like
;;    do-csv-file and map-csv-file, as well as the ability
;;    to control the range of line-numbers on which to apply
;;    your code.  Pretty simple stuff, but useful.
;;
;;  * You get a CSV-file writer, for free!  :-)
;;
;;  Questions:
;;    Can someone tell me why this is more than 10X faster
;;    under CMULisp 18e than under Lispworks 4.2 ? Sheeesh.
;;;;


(in-package :common-lisp-user)

(defpackage :csv-parser
  (:use :common-lisp)
  (:export  #:*field-separator*
	    #:*quote-character*
	    #:read-csv-line
	    #:do-csv-file
	    #:map-csv-file
	    #:write-csv-line))

(in-package :csv-parser)

(defparameter *field-separator* #\,
  "The character used to indicate the end of a field
   in a CSV file.")

(defparameter *quote-character* #\"
  "The character used to protect embedded field separators
   (usually commas) and whitespace within a field.

   To import the *quote-character* itself, you must have
   it printed twice in the input stream.")

(defvar *state* nil
  "Holds a function which knows how to handle chars based
   on what we've seen so far.")

(defvar *spaces-gobbled* nil
  "Keeps track of how many blanks have been skipped.  When emitting
   a field, we can trim extra right spaces, if appropriate, using this.")

(defvar *current-field* nil
  "Holds the field we are currently working on.")

(defvar *fields* nil
  "Holds the fields we have collected/parsed so far.")

(defvar *num-fields*
  "Holds the number of fields we have collected/parsed so far.")


;; Public
(defun read-csv-line (stream)
  "Read one line form a stream containing CSV data.
   Returns two values; a list of strings parsed, and
   the number of parsed values."
  (let ((*state* #'skip-white-space)
	(*spaces-gobbled* 0)
	(*fields* ())
	(*num-fields*  0)
	(*current-field* (make-empty-field)))
    (catch 'end-of-line
      (loop
       (funcall *state* (read-char stream nil :eof))))
    (values (nreverse *fields*)
	    *num-fields*)))

;; Public
(defun map-csv-file (file fn &key limit (skip-lines 0))
  "Call FN (up to LIMIT times, if specified) with
   a list containing the fields parsed from the CSV
   file FILE.

   SKIP-LINES, if provided, is the number of lines to skip
   before starting to call FN.

   *FIELD-SEPARATOR* and *QUOTE-CHARACTER* can be bound to
   modify what separates fields and delimits fields."
  (with-open-file (stream file :direction :input)
    (loop repeat skip-lines
	  do (read-csv-line stream))
    (if limit
	(loop as line = (read-csv-line stream)
	      while line
	      repeat limit
	      do (funcall fn line))
	(loop as line = (read-csv-line stream)
	      while line
	      do (funcall fn line)))))


;; Public
(defmacro do-csv-file (((fields num-fields) file &key limit (skip-lines 0))
                       &body body)
  "Repeatedly call BODY on CSV file FILE, binding
   FIELDS and NUM-FIELDS to a list containing the parsed fields,
   and the number of fields.
   Code runs inside a block with tagname NIL, so you
   may call (RETURN).

   *FIELD-SEPARATOR* and *QUOTE-CHARACTER* can be bound to
   modify what separates fields and delimits fields."
  (let ((stream (gensym "STREAM"))
	(count  (gensym "COUNT"))
	(glimit (gensym "LIMIT")))
    `(with-open-file (,stream ,file :direction :input)
      (loop repeat ,skip-lines
            do     (read-csv-line ,stream))
      (loop for ,count upfrom 0
            with ,glimit = ,limit
            do
            (multiple-value-bind (,fields ,num-fields) (read-csv-line ,stream)
	      (when (or (null ,fields)
			(and ,glimit
			     (>= ,count ,glimit)))
		(return))
	      ,@body)))))


;;;; Utilities

(defun change-state (state)
  (setf *state*
	(ecase state
	  (:skip         #'skip-white-space)
	  (:first-quote  #'got-first-quote)
	  (:second-quote #'got-second-quote)
	  (:regular      #'regular-field))))

(declaim (inline add-char))
(defun add-char (char)
  (declare  (type base-char char))
  (vector-push-extend char *current-field*))

(defun make-empty-field ()
  (make-array 0
	      :fill-pointer 0
	      :adjustable   t
	      :element-type 'base-char))

(defun remove-last-n-chars (n)
  (setf (fill-pointer *current-field*)
	(- (length *current-field*)
	   n)))

(declaim (inline quote-char-p end-of-line-char-p end-of-field-char-p
		 white-space-char-p))
(defun quote-char-p (char)
  (char= char *quote-character*))

(defun end-of-line-char-p (char)
  (char= char #\Newline))

(defun end-of-field-char-p (char)
  (char= char *field-separator*))

(defun white-space-char-p (char)
  (or (char= char #\Space)
      (char= char #\Tab)
      (char= char #\Return))) ; For DOS style line termination


;;  States:
;;    * skip-white-space (initial state).
;;    * regular-field    handle things like ` foo bar '
;;    * got-first-quote  handle things like ` " foo X'
;;    * got-second-quote handle things like ` " foo  "X '
;;

(defun skip-white-space (char)
  (cond
    ((or (eq char :eof)
	 (end-of-line-char-p char))
     (when *fields*
       ;; If no fields are present, this was a completeley
       ;; blank line.  Otherwise, collect the last null field.
       (emit-field))
     (throw 'end-of-line nil))

    ((white-space-char-p char)
     ; skip
     nil)

    ((end-of-field-char-p char)
     (emit-field))

    ((quote-char-p char)
     (change-state :first-quote))

    (t
     (change-state :regular)
     (add-char char))))

(defun regular-field (char)
  (cond
    ((or (eq char :eof)
	 (end-of-line-char-p char))
     (emit-field)
     (throw 'end-of-line nil))

    ((end-of-field-char-p char)
     (emit-field))

    ((white-space-char-p char)
     (add-char char)
     (incf *spaces-gobbled*))

    ((quote-char-p char)
     (error "Got a quote after regular characters; ~
             incorrectly formatted CSV file."))


    (t
     (setf *spaces-gobbled* 0)
     (add-char char))))

(defun got-first-quote (char)
  (cond
    ((eq char :eof)
     (error "Ran out of characters before finishing quoted field."))

    ((quote-char-p char)
     (change-state :second-quote))

    (t ; collect anything else
     (add-char char))))

(defun got-second-quote (char)
  (cond
    ((or (eq char :eof)
	 (end-of-line-char-p char))
     (emit-field)
     (throw 'end-of-line nil))

    ((quote-char-p char)
     ;; This is the weird embedded "" scenario
     (add-char char)
     (change-state :first-quote))

    ((end-of-field-char-p char)
     (emit-field))

    ((white-space-char-p char)
     (incf *spaces-gobbled*))

    (t
     (error "Got unexpected non-blank char after end of a quoted field"))))

(defun emit-field ()
  (cond
    ((eq *state* #'skip-white-space)
     (push nil *fields*))

    ((eq *state* #'got-second-quote)
     (push *current-field* *fields*))

    ((eq *state* #'regular-field)
     (remove-last-n-chars *spaces-gobbled*)
     (push *current-field* *fields*))

    (t
     (assert nil nil "Bug!")))

  (incf *num-fields*)
  (setf *spaces-gobbled* 0
	*state*          #'skip-white-space
	*current-field*  (make-empty-field)))



;;;; test harness
#+(or)
(trace skip-white-space got-first-quote got-second-quote regular-field
       emit-field add-char change-state remove-last-n-chars)

#+(or)(csv-tests)

;;  Call this; if nothing asserts, you win.
;;  (csv-tests)

(defun csv-tests ()
  (csv-test-blank)
  (csv-test-blanks)
  (csv-test-empty)
  (csv-test-simple)
  (csv-test-quoted)
  (csv-test-space-handling)
  (csv-test-other-delimiters)
  (csv-test-embedded-lines)
  (csv-test-embedded-commas))

(defun csv-test-blank ()
  (with-input-from-string (s "")
    (assert (eq nil (read-csv-line s)))
    (assert (eq nil (read-csv-line s)))))

(defun csv-test-blanks ()
  (with-input-from-string (s "  ")
    (assert (eq nil (read-csv-line s)))
    (assert (eq nil (read-csv-line s)))))

(defun csv-test-empty ()
  (with-input-from-string (s " ,,   , ")
    (assert (equal (list nil nil nil nil) (read-csv-line s)))
    (assert (eq nil (read-csv-line s)))))

(defun csv-test-simple ()
  (with-input-from-string (s "foo,bar,baz")
    (assert (equal (list "foo" "bar" "baz")
		   (read-csv-line s)))))

(defun csv-test-quoted ()
  (with-input-from-string (s "\"foo\",\"bar\",\"baz\"")
    (assert (equal (list "foo" "bar" "baz")
		   (read-csv-line s)))))

(defun csv-test-space-handling ()
  ;; leading/trailing blanks (but not intra word blanks)
  ;; are stripped unless the whole thing is quoted
  (with-input-from-string (s "\"  foo  bar  \",  foo bar  ")
    (assert (equal (list "  foo  bar  " "foo bar")
		   (read-csv-line s)))))

(defun csv-test-other-delimiters ()
  (let ((*field-separator* #\|)
	(*quote-character* #\'))
    (with-input-from-string (s "'foo'|'bar'|'baz'")
      (assert (equal (list "foo" "bar" "baz")
		     (read-csv-line s))))))

(defun csv-test-double-quotes ()
  (with-input-from-string (s "\"foo \"\" bar\",2,3,\"\", \" \"")
    (assert (equal (list "foo \" bar" "2" "3" "" " ")
		   (read-csv-line s)))))

(defun csv-test-embedded-lines ()
  (with-input-from-string (s "\"foo
 and bar\",\" 2 \",3")
    (assert (equal (list "foo
 and bar" " 2 " "3")
		   (read-csv-line s)))))

(defun csv-test-embedded-commas ()
  (with-input-from-string (s "\"foo , bar\",2,3")
    (assert (equal (list "foo , bar" "2" "3")
		   (read-csv-line s)))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;



;;;; Writing utilities

(defun write-csv-line (stream fields)
  "Write one CSV line to STREAM, containing fields.
   FIELDS is any (1d) sequence containing strings, symbols or numbers.

   Try to write it as esthetically pleasing as possible,
   i.e. don't output the *quote-character* unless necessary
   to protect the integrity of the data."

  (etypecase fields
    (cons   (write-csv-line-on-cons stream fields))
    (array  (write-csv-line-on-array stream fields))))

(defun write-csv-line-on-cons (stream fields)
  (loop for rest on fields
	while rest
	do
	(write-csv-field stream (first rest))
	(when (cdr rest)
	  (write-char *field-separator* stream)))
  (terpri stream))

(defun write-csv-line-on-array (stream fields)
  (loop for field across fields
	repeat (1- (length fields))
	do
	(write-csv-field stream field)
	(write-char *field-separator* stream)

	finally
	(write-csv-field stream (aref fields (1- (length fields))))
	(terpri stream)))

(defun write-csv-field (stream field)
  (etypecase field
    (null t)
    (number (princ field stream))
    (string (write-csv-string-safely stream field))
    (symbol (write-csv-string-safely stream (symbol-name field)))))

(defun special-char-p (char)
  (or (char= char *field-separator*)
      (char= char *quote-character*)
      (white-space-char-p char)))

(defun write-csv-string-safely (stream string)
  (if (find-if #'special-char-p string)
      (write-protected-copy stream string)
      (princ string stream)))

(defun write-protected-copy (stream field)
  (write-char *quote-character* stream)
  (loop for c across field
	do
	(write-char c stream)
	(when (char= c *quote-character*)
	  ;; Double it
	  (write-char c stream)))
  (write-char *quote-character* stream))

;;; END OF FILE
#+end_src
** Common Lisp Packages for MongoDB
*** cl-mongo
- [[https://www.mongodb.com][MongoDB]]
- [[https://github.com/fons/cl-mongo][fons/cl-mongo]] --- lisp interface to mongo db
- [[https://quickref.common-lisp.net/cl-mongo.html][cl-mongo reference manual]]
- [[https://www.quicklisp.org/beta/UNOFFICIAL/docs/cl-mongo/doc/index.html][CL-MONGO - api reference]]
** Common Lisp Packages for SQLite
*** Alain Picard's cl-sqlite
- http://mirror.informatimago.com/lisp/members.optusnet.com.au/apicard/index.html

** Common Lisp Regular Expressions
#+cindex:regular expressions
The  ANSI  Common  Lisp  standard  does  not  include  facilities  for  regular
expressions,  but a  couple of  libraries exist  for this  task, for  instance:
~cl-ppcre~.

- [[https://www.cliki.net/Regular%20Expression][CLiki Regular Expressions page]]

*** CL-Portable Perl-compatible Regular Expressions---CL-PPCRE
"Portable Perl-compatible regular expressions for Common Lisp"

- [[https://edicl.github.io/cl-ppcre/][CL-PPCRE Home]]
- [[https://github.com/edicl/cl-ppcre][CL-PPCRE on GitHub]]

CL-PPCRE is a portable regular expression library for Common Lisp which has the
following features:

- It  is  compatible  with  Perl  (especially when  used  in  conjunction  with
  cl-interpol, to allow compatible parsing of regexp strings).
- It is pretty fast.
- It is portable between ANSI-compliant Common Lisp implementations.
- It is thread-safe.
- In addition to specifying regular expressions as strings like in Perl you can
  also use S-expressions.
- It comes with  a BSD-style license so  you can basically do  with it whatever
  you want.

To use it, load it through ~quicklisp~:

: (ql:quickload :cl-ppcre)

**** CL-PPCRE Basic Operations
***** Scan Functions---Looking for matching patterns
     #+cindex:scan function
- ~scan~ :: The ~scan~ function tries to match the given pattern and on success
  returns four multiple-values values:

  1. the start of the match
  2. the end of the match
  3. array denoting the beginnings of register matches
  4. array denoting the endings of register matches

  Returns =NIL= on failure.

  #+cindex:create-scanner function
  #+cindex:scanner
- ~create-scanner~ ::   A regular expression  pattern can be compiled  with the
  ~create-scanner~ function call. A “scanner” will  be created that can be used
  by other functions.

  #+begin_src lisp
    (let ((ptrn (ppcre:create-scanner "(a)*b")))
      (ppcre:scan ptrn "xaaabd"))
  #+end_src

  will yield the same results as:

  #+begin_src lisp
    (ppcre:scan "(a)*b" "xaaabd")
  #+end_src

  but  will  require  less  time  for repeated  ~scan~  calls  as  parsing  the
  expression and compiling it is done only once.

***** Extracting information

- ~scan-to-strings~  :: The ~scan-to-strings~ function is similar to ~scan~ but
  returns /substrings/  of =target-string= instead of  positions. This function
  returns two values on  success: the whole match as a string  plus an array of
  substrings (or =NIL=s) corresponding to the matched registers.

- ~register-groups-bind~ ::  The ~register-groups-bind~ function tries to match
  the given pattern against the target string and binds matching fragments with
  the given variables.

  #+begin_src lisp
    (ppcre:register-groups-bind (first second third fourth)
	  ("((a)|(b)|(c))+" "abababc" :sharedp t)
	(list first second third fourth))
  #+end_src

  #+begin_example
  ;; => ("c" "a" "b" "c")
  #+end_example

  CL-PPCRE also provides a shortcut for calling a function before assigning the
  matching fragment to the variable:

  #+begin_src lisp
    (ppcre:register-groups-bind (fname lname (#'parse-integer date month year))
	  ("(\\w+)\\s+(\\w+)\\s+(\\d{1,2})\\.(\\d{1,2})\\.(\\d{4})" "Frank Zappa 21.12.1940")
	(list fname lname (encode-universal-time 0 0 0 date month year 0)))
  #+end_src

  #+begin_example
  ;; => ("Frank" "Zappa" 1292889600)
  #+end_example

**** Scanning

#+attr_texinfo: :options create-scanner (re-string string) &key case-insensitive-mode multi-line-mode single-line-mode extended-mode destructive
#+begin_defun
The function accepts most of the regex  syntax of Perl 5.8 as described in ~man
perlre~ including  extended features like non-greedy  repetitions, positive and
negative  look-ahead and  look-behind assertions,  "standalone" subexpressions,
and conditional subpatterns.

The following Perl features /are/ currently supported:

- =\t=, =\n=, =\r=, =\f=, =\a=, =\e=,
- =\033= (octal character codes),
- =\x1B= (hexadecimal character codes),
- =\c[= (control characters),
- =\w=, =\W=, =\s=, =\S=, =\d=, =\D=, =\b=, =\B=, =\A=, =\Z=, and =\z=
- =\Q= and =\E=
- =\p=  and =\P=  (named properties)  but  only the  long form  with braces  is
  supported, i.e. =\p{Letter}= and =\p{L}= will work while =\pL= won't.


The following Perl features are (currently) /not/ supported:

- ~(?{ code })~ and  ~(??{ code })~ because they obviously  don't make sense in
  Lisp.
- =\N{name}= (named characters),
- =\x{263a}= (wide hex characters),
- =\l=, =\u=, =\L=, and =\U= because  they're actually not part of Perl's regex
  syntax
- =\X= (extended Unicode), and
- =\C= (single character).
- Posix  /character  classes/  like   =[[:alpha]]=.  Use  /Unicode  properties/
  instead.
- =\G= for Perl's ~pos()~ because we don't have it.


- return        values         ::        @@texinfo:@var{@@scanner@@texinfo:}@@,
  @@texinfo:@var{@@register-names@@texinfo:}@@

- re-string ::  Accepts a string which  is a regular expression  in Perl syntax
  and returns a closure which will scan strings for this regular expression.

- =*ALLOW-NAMED-REGISTERS*=   ::  The   second  value   is  only   returned  if
  =*ALLOW-NAMED-REGISTERS*= is =true=.

- REGISTER-NAMES   ::   (return  value) represents  a list  of strings  mapping
  registers  to their  respective names;  the  first element  stands for  first
  register, the second element for second register, etc. You have to store this
  value if  you want to map  a register number  to its name later  as ~scanner~
  doesn't capture  any information  about register names.  If a  register isn't
  named, it has =NIL= as its name.

- MODEs :: The =mode= keyword arguments  are equivalent to the =imsx= modifiers
  in Perl. The =destructive= keyword will be ignored.

#+end_defun

#+texinfo: @heading Parse Tree

#+attr_texinfo: :options create-scanner (parse-tree t) &key case-insensitive-mode multi-line-mode single-line-mode extended-mode destructive
#+begin_defun
This  is similar  to ~CREATE-SCANNER~  for regex  strings above  but accepts  a
/parse tree/ as its first argument.  A parse tree is an S-expression conforming
to the following syntax:...

- return values :: scanner, register-names

#+end_defun

#+texinfo: @heading Scan

#+attr_texinfo: :options scan regex target-string &key start end
#+begin_defun
Searches the string ~target-string~ from ~start~ (which defaults to 0) to ~end~
(which defaults to  the length of ~target-string~) and tries  to match ~regex~.
On success returns four values:
- the start of the match,
- the end of the match
- array denoting the beginnings of register matches
- array denoting the endings of register matches

On failure returns =NIL=.

- return-values ::
  - match-start,
  - match-end,
  - reg-starts,
  - reg-ends
#+end_defun

#+texinfo: @heading ~scan-to-strings~ 

#+attr_texinfo: :options scan-to-strings regex target-string &key start end sharedp
#+begin_defun
- return values :: match, regs

Like ~SCAN~  but returns  substrings of  ~target-string~ instead  of positions,
i.e. this function returns  two values on success:
- the whole match as a string
- plus  an  array  of  substrings  (or =NIL=s)  corresponding  to  the  matched
  registers.  If ~sharedp~  is true,  the substrings  may share  structure with
  ~target-string~.
#+end_defun

**** Splitting and Replacing

**** Modifying scanner behaviour

**** Miscellaneous

**** Conditions

**** Unicode Properties

**** Filters

**** Compatibility with Perl

**** Bugs and Problems

**** Hints---Comments---Performance

** Iterate
- [[https://common-lisp.net/project/iterate/][Iterate]]
- [[https://common-lisp.net/project/iterate/doc/index.html][The Iterate Manual]]
- [[https://gitlab.common-lisp.net/iterate/iterate][Iterate on GitLab]]

~iterate~  is an  iteration construct  for Common  Lisp. It  is similar  to the
=CL:LOOP= macro, with these distinguishing marks:

- it is extensible,
- it helps editors  like Emacs indent iterate forms by  having a more lisp-like
  syntax, and
- it isn't part of the ANSI standard  for Common Lisp (which is sometimes a bad
  thing and sometimes good).


It is available from QuickLisp.

: #<SYSTEM iterate / iterate-20200610-git / quicklisp 2020-10-16>

** SharpListers
A group of Common Lisp hackers who occasionally maintain otherwise abandoned or
quasi-abandoned Common Lisp software packages.

- https://github.com/sharplispers
** ZS3---Amazon S3 and CloudFront from Common Lisp
#+cindex:ZS3
#+cindex:Amazon S3
#+cindex:S3, Amazon
#+cindex:Amazon CloudFront
#+cindex:CloudFront, Amazon
ZS3 is a  Common Lisp library for working with  Amazon's Simple Storage Service
(S3) and CloudFront content delivery service.

- https://www.xach.com/lisp/zs3/
- [[https://github.com/xach/zs3/][ZS3 on GitHub]]
** Writing Modules
- https://gist.github.com/substack/5075355

My thoughts on writing tiny reusable modules that each do just one
thing. These notes were adapted from an email I recently sent.

-----

If some component is reusable enough to  be a module then the maintenance gains
are really worth the  overhead of making a new project  with separate tests and
docs. Splitting out a  reusable component might take 5 or 10  minutes to set up
all the package overhead but it's much easier to test and document a piece that
is completely separate from a larger project. When something is easy, you do it
more often.

I've observed  the biggest gains  for splitting  something out into  a separate
module when I'm completely stuck mucking around in a larger application. When I
isolate the problem  down to the scope  of a small module, it's  much easier to
see how that small piece fits in with the greater application objective.

Another technique is to  pick tools and approaches that don't  involve a lot of
boilerplate in the first place. My usual flow for writing a new module is:

1. hack  up some tiny (<10  line) example file  that does just enough  to start
   experimenting with the api

2. start fleshing out an index.js file required by the example file

3. make incremental changes to the index file to get the example further along,
   updating the example as necessary to reflect changes

4. once the example pretty much works, copy it into test/

5. `npm install  tap` or `npm install tape`  for modules I want to  test in the
   browser.  I like  simple,  imperative tests  that I  can  adapt from  simple
   examples.

6. add some assertions around the example code

7. `pkginit`  (https://github.com/substack/pkginit) to generate  a package.json
   (or you could just use `npm init`)

8.  copy the  example file  into  a readme.markdown  since I  really like  when
   packages have code in their readmes when I'm looking for modules to use

9. add a blurb  at the top of the readme.markdown,  document the methods (there
   are only a few to document usually), add a license and install instructions

10. create a github repo

11. add travis and/or testling-ci github hooks as appropriate

12. `git push` and `npm publish`

With practice, I run through all these steps very quickly now. Not all of these
are strictly necessary  and sometimes I'll skip  a step but this  is mostly the
procedure I use for new modules.

As much  as possible, I  try to build large-scale  projects using lots  of tiny
modules so I  just repeat this process whenever I  need some reusable component
that doesn't yet  exist in quite the form  I need it to exist.  As more modules
are published to npm  I expect I won't need to write so  many modules but there
will always be room for new stuff.

When applications are done well, they are just the really application-specific,
brackish  residue that  can't  be  so easily  abstracted  away.  All the  nice,
reusable  components sublimate  away onto  github and  npm where  everybody can
collaborate to advance the commons.
* Common Lisp Condition System

#+cindex:condition system
One of  Lisp's great features  is its /condition  system/. It serves  a similar
purpose to the exception handling systems in  Java, Python, and C++ but is more
flexible. Its  flexibility extends beyond error  handling---conditions are more
general than exceptions in that a condition can represent any occurrence during
a program's execution  that may be of  interest to code at  different levels on
the call stack.

The condition system is more flexible than exception systems because instead of
providing a  two-part division between the  code that signals an  error and the
code that  handles it,  the condition system  splits the  responsibilities into
three parts:

1. signaling a condition,
2. handling it, and
3. restarting.


In this chapter, I'll describe how you could use conditions in part of a
hypothetical application for analyzing log files. You'll see how you could use
the condition system:U

- to allow a  low-level function to detect  a problem while parsing  a log file
  and signal an error,
- to allow mid-level  code to provide several possible ways  of recovering from
  such an error, and
- to allow code at the highest level  of the application to define a policy for
  choosing which recovery strategy to use.

** Terminology
- error :: not a  bug, but rather something occurring that may  stop a piece of
  code from running: a  file is missing, a disk is full,  a server has crashed,
  the network is down. However, if the  rest of the program is depending on the
  actions that were  going to be taken,  then you'd better deal  with the error
  somehow or you will have introduced a  bug. So, errors aren't caused by bugs,
  but neglecting to handle an error is almost certainly a bug.

- call stack :: In a well-written program,  each function is a black box hiding
  its  inner workings.  Programs are  then built  out of  layers of  functions:
  high-level functions  are built on top  of the lower-level functions,  and so
  on. This hierarchy  of functionality manifests itself at runtime  in the form
  of the call  stack: if high calls  medium, which calls low, when  the flow of
  control is in low, it's also still in medium and high, that is, they're still
  on the call stack.

  Function boundaries are an excellent place to deal with errors. If any of the
  functions  in the  call stack  can somehow  do their  job despite  underlying
  errors,  then none  of the  functions  above it  needs  to know  there was  a
  problem.

- error handling ::  In most languages,  errors are handled by returning from a
  failing function  and giving the  caller the  choice of either  recovering or
  failing  itself. Some  languages use  the normal  function return  mechanism,
  while languages with  /exceptions/ return control by  /throwing/ or /raising/
  an exception.

  Both schemes suffer  from a common flaw: while searching  for a function that
  can recover, the stack unwinds, which means code that might recover has to do
  so without the context of what the lower-level code was trying to do when the
  error actually occurred.

** Common Lisp Conditions
Common Lisp's error  handling system gives you  a way out of  this conundrum by
letting you  separate the code  that actually recovers  from an error  from the
code that decides how to recover. Thus,  you can put recovery code in low-level
functions  without  committing  to   actually  using  any  particular  recovery
strategy, leaving that decision to code in high-level functions.

*** An Example
To get a sense  of how this works, let's suppose  you're writing an application
that reads some sort of textual log file, such as a Web server's log. Somewhere
in your application you'll have a function to parse the individual log entries.
Let's assume you'll write a function,  ~parse-log-entry~, that will be passed a
string containing the text of a single log entry and that is supposed to return
a =log-entry= object representing the entry.  This function will be called from
a function, ~parse-log-file~, that reads a complete log file and returns a list
of objects representing all the entries in the file.

To keep things  simple, the ~parse-log-entry~ function will not  be required to
parse incorrectly formatted  entries. It will, however, be able  to detect when
its input is malformed.  But what should it do when it detects  bad input? In C
you'd return a special value to indicate there was a problem. In Java or Python
you'd throw or raise an exception. In Common Lisp, you signal a condition.

*** Condition Object
A /condition/  is an  object whose  class indicates the  general nature  of the
condition and whose instance data carries  information about the details of the
particular circumstances  that lead  to the condition  being signaled.  In this
hypothetical  log  analysis  program,  you  might  define  a  condition  class,
=malformed-log-entry-error=, that  ~parse-log-entry~ will signal if  it's given
data it can't parse.

**** Condition Classes are defined with DEFINE-CONDITION Macro
Condition classes  are defined with  the ~DEFINE-CONDITION~ macro,  which works
essentially  the same  as  ~DEFCLASS~  except that  the  default superclass  of
classes   defined   with   ~DEFINE-CONDITION~  is   =CONDITION=   rather   than
=STANDARD-OBJECT=. Slots are  specified in the same way,  and condition classes
can  singly  and  multiply  inherit   from  other  classes  that  descend  from
=CONDITION=

But for historical  reasons, condition classes aren't required  to be instances
of  =STANDARD-OBJECT=, so  some of  the  functions you  use with  =DEFCLASS='ed
classes aren't required  to work with conditions. In  particular, a condition's
slots can't be accessed using ~SLOT-VALUE~; you must specify either a =:reader=
option or  an =:accessor= option  for any slot whose  value you intend  to use.

**** New Condition Objects are created with MAKE-CONDITION
Likewise, new condition  objects are created with  ~MAKE-CONDITION~ rather than
~MAKE-INSTANCE~. ~MAKE-CONDITION~  initializes the  slots of the  new condition
based on the =:initargs= it's passed, but there's no way to further customize a
condition's initialization, equivalent to ~INITIALIZE-INSTANCE~.

**** Subclass of ERROR
When using  the condition  system for  error handling,  you should  define your
conditions as subclasses of =ERROR=, a subclass of =CONDITION=. Thus, you might
define =malformed-log-entry-error=,  with a  slot to hold  the argument  that was
passed to ~parse-log-entry~, like this:

: (define-condition malformed-log-entry-error (error)
:   ((text :initarg :text :reader text)))

*** Condition Handler

* Common Lisp Testing
** FiveAM
"Common Lisp regression testing framework"

[[https://common-lisp.net/project/fiveam/][FiveAM]] is a Test Framework whose goal is to be as simple as possible.

- [[https://common-lisp.net/project/fiveam/docs/index.html][FiveAM API]]
- [[https://github.com/lispci/fiveam][FiveAM on GitHub]]


FiveAM  is a  simple (as  far  as writing  and running  tests goes)  regression
testing  framework.  It  has  been  designed  with  Common  Lisp's  interactive
development model in mind.

*** Features

- Test and test  suite hierarchies allow test to be  organized into hierarchies
  to ease running.
- Functions for re-running recently run tests.
- Inter-test dependencies.
- Specification based testing ala QuickCheck.
- Redefined  macros  are   instantly  seen  by  the  test   code,  no  explicit
  recompilation required. (this is exactly what LispUnit and FReT do)

** Lisp Unit
"A  Test  Framework  for Common  Lisp  in  the  style  of JUnit,  designed  and
implemented with simplicity of use in mind."

- [[https://github.com/OdonataResearchLLC/lisp-unit/wiki][Lisp Unit wiki]]
- [[https://github.com/OdonataResearchLLC/lisp-unit][Lisp Unit on GitHub]]


~lisp-unit~  is a  Common Lisp  library that  supports unit  testing. It  is an
extension  of the  library written  by Chris  Riesbeck ([[https://courses.cs.northwestern.edu/325/readings/lisp-unit.php][see]]).  There is  a long
history of testing packages in  Lisp, usually called "regression" testers. More
recent packages  in Lisp and  other languages have  been inspired by  JUnit for
Java.


#+texinfo: @heading Features

- Written in portable Common Lisp
- Loadable as a single file
- Loadable with ASDF or Quicklisp
- Simple to define and run tests
- Redefine functions and macros without reloading tests
- Test return values, printed output, macro expansions, and conditions
- Fine-grained control over the testing output
- Store all test results in a database object that can be examined
- Group tests by package for modularity
- Group tests using tags
- Signal test completion and return results with the condition.


*** How To Use Test Unit
The core  definitions of  ~lisp-unit~ may  be used by  loading the  single file
~lisp-unit.lisp~.  To use  the  extensions, ~lisp-unit~  must  be loaded  using
either =Quicklisp= or =ASDF=.

1. Load (or compile and load) as a single file : ~(load "lisp-unit")~; or
2. Load using =Quicklisp= : ~(ql:quickload :lisp-unit)~; or
3. Load using =ASDF= : ~(asdf:load-system :lisp-unit)~.
4. Load a file of tests.
5. Run the tests with ~run-tests~.

*** How to Test
#+begin_src sh
> (in-package :cs325-user)
    #<PACKAGE CS325-USER>
> (define-test pick-greater
       (assert-equal 5 (pick-greater 2 5))
       (assert-equal 5 (pick-greater 5 2))
       (assert-equal 10 (pick-greater 10 10))
       (assert-equal 0 (pick-greater -5 0))
   )
   ==> PICK-GREATER
#+end_src

Following  good test-first  programming  practice, we  run  these tests  before
writing any code.

#+begin_src sh
> (run-tests pick-greater)
  ==> PICK-GREATER: Undefined function PICK-GREATER called with arguments (2 5).
#+end_src

This shows  that we need to  do some work. So  we define our broken  version of
~pick-greater~.

#+begin_src sh
> (defun pick-greater (x y) x)  ;; deliberately wrong
    PICK-GREATER
#+end_src

Now we run the tests again:

#+begin_src sh
> (run-tests pick-greater)
  PICK-GREATER: (PICK-GREATER 2 5) failed: Expected 5 but saw 2
  PICK-GREATER: (PICK-GREATER -5 0) failed: Expected 0 but saw -5
  PICK-GREATER: 2 assertions passed, 2 failed.
#+end_src

This shows  two failures. In both  cases, the equality test  returned =NIL=. In
the  first case  it was  because ~(pick-greater  2 5)~  returned 2  when 5  was
expected, and in the second case, it was because ~(pick-greater -5 0)~ returned
-5 when 0 was expected.

**** Assertion Forms
The most commonly used assertion form is
: (assert-equal value form)

This tallies a failure  if form returns a value not equal  to value. Both value
and test  are evaluated in the  local lexical environment. This  means that you
can use local variables  in tests. In particular, you can  write loops that run
many tests at once:

#+begin_src sh
> (define-test my-sqrt
      (dotimes (i 5)
        (assert-equal i (my-sqrt (* i i)))))
    MY-SQRT

    > (defun my-sqrt (n) (/ n 2))   ;; wrong!!

    > (run-tests my-sqrt)
    MY-SQRT: (MY-SQRT (* I I)) failed: Expected 1 but saw 1/2
    MY-SQRT: (MY-SQRT (* I I)) failed: Expected 3 but saw 9/2
    MY-SQRT: (MY-SQRT (* I I)) failed: Expected 4 but saw 8
    MY-SQRT: 2 assertions passed, 3 failed.
#+end_src

However, the  above output  doesn't tell us  for which values  of =i=  the code
failed. Fortunately, you can  fix this by adding expressions at  the end of the
~assert-equal~. These expression and their values will be printed on failure.

#+begin_src sh
> (define-test my-sqrt
      (dotimes (i 5)
        (assert-equal i (my-sqrt (* i i)) i)))  ;; added i at the end
    MY-SQRT
    > (run-tests my-sqrt)
    MY-SQRT: (MY-SQRT (* I I)) failed: Expected 1 but saw 1/2
       I => 1
    MY-SQRT: (MY-SQRT (* I I)) failed: Expected 3 but saw 9/2
       I => 3
    MY-SQRT: (MY-SQRT (* I I)) failed: Expected 4 but saw 8
       I => 4
    MY-SQRT: 2 assertions passed, 3 failed.
#+end_src

The next most useful assertion form is:
: (assert-true test)

This tallies a failure  if test returns false. Again, if you  need to print out
extra information, just add expressions after test.

There  are also  assertion forms  to test  what code  prints, what  errors code
returns, or what a macro expands into. A complete list of assertion forms is in
the reference section.


#+cindex:assert-true v. assert macro
#+cindex:assert macro v. assert-true
#+begin_quote
Do not  confuse ~assert-true~  with Common Lisp's  ~assert~ macro.  ~assert~ is
used in code  to guarantee that some  condition is true. If it  isn't, the code
halts. ~assert~  has options you  can use  to let a  user fix what's  wrong and
resume execution. A similar collision of names exists in JUnit and Java.
#+end_quote

**** How to Organize Tests with Packages
Tests are grouped internally by the current package, so that a set of tests can
be defined  for one package  of code without  interfering with tests  for other
packages.

If  your code  is being  defined in  ~cl-user~, which  is common  when learning
Common Lisp,  but not for  production-level code,  then you should  define your
tests in ~cl-user~ as well.

If your code is being defined in  its own package, you should define your tests
either in that  same package, or in  another package for test  code. The latter
approach has the advantage  of making sure that your tests  have access to only
the exported symbols of your code package.

For example, if you were defining a =date= package, your ~date.lisp~ file would
look like this:

#+name:date.lisp
#+begin_src lisp
(defpackage :date
      (:use :common-lisp)
      (:export #:date->string #:string->date))

    (in-package :date)

    (defun date->string (date) ...)
    (defun string->date (string) ...)
#+end_src

Your ~date-tests.lisp~ file would look like this:

#+name:date-tests.lisp
#+begin_src lisp
defpackage :date-tests
      (:use :common-lisp :lisp-unit :date))

    (in-package :date-tests)

    (define-test date->string
      (assert-true (string= ... (date->string ...)))
      ...)
    ...
#+end_src

You could then run all your =date= tests in the test package:

#+begin_src lisp
(in-package :date-tests)

    (run-tests)
#+end_src

Alternately, you could run all your date tests from any package with:

#+begin_src lisp
(lisp-unit:run-all-tests :date-tests)
#+end_src

**** Reference Section
Here is a list of the functions and macros exported by ~lisp-unit~.

***** Test definition forms

: (define-test name exp1 exp2 ...)

: (get-tests [package)

: (get-test-code name [package)

: (remove-tests names [package])

: (remove-all-tests [package])

: (run-all-tests package)

: (run-tests name1 name2 ...)

: (use-debugger [flag])

***** Assertion forms

All of the assertion  forms are macros. They tally a  failure if the associated
predication returns false. Assertions can  be made about return values, printed
output, macro  expansions, and even  expected errors. Assertion  form arguments
are evaluated in the local lexical environment.

All assertion forms  allow you to include additional expressions  at the end of
the form. These expressions and their values will be printed only when the test
fails.

Return values are unspecified for all assertion forms.

: (assert-eq value form [form1 form2 ...])

: (assert-eql value form [form1 form2 ...])

: (assert-equal value form [form1 form2 ...])

: (assert-equalp value form [form1 form2 ...])

: (assert-equality predicate value form [form1 form2 ...])

These macros tally  a failure if value  is not equal to the  result returned by
form, using the specified equality predicate.

In general, ~assert-equal~ is used for most tests. But any binary predicate can
be used, with ~assert-equality~, e.g.,

: (assert-equality unordered-equal '(a b c) (unique-atoms '((b c) a ((b a) c))))

: (assert-true test [form1 form2 ...])
: (assert-false test [form1 form2 ...])

~assert-true~ tallies a failure if test returns false. ~assert-false~ tallies a
failure if test returns =true=.

: (assert-prints "output" form [form1 form2 ...])

: (assert-expands expansion form [form1 form2 ...])

: (assert-error condition-type form [form1 form2 ...])

: (fail format-string [form1 form2 ...])

***** Utility predicates

Several predicate functions are exported that are often useful in writing tests
with ~assert-equality~.

: (logically-equal value1 value2)

: (set-equal list1 list2 [:test])

: (unordered-equal list1 list2 [:test])

*** Test Anything Protocol Extensions
- [[http://testanything.org][Home]]  TAP, the  Test  Anything  Protocol, is  a  simple text-based  interface
  between testing modules  in a test harness.  TAP started life as  part of the
  test harness  for Perl but  now has implementations  in C, C++,  Python, PHP,
  Perl, Java, JavaScript, and others.

  Here’s what a TAP test stream looks like:

  #+begin_example
  1..4
  ok 1 - Input file opened
  not ok 2 - First line of the input valid
  ok 3 - Read the rest of the file
  not ok 4 - Summarized correctly # TODO Not written yet
  #+end_example

- [[https://github.com/OdonataResearchLLC/lisp-unit/wiki/Test-Anything-Protocol-Extensions][Wiki]] The  Test Anything Protocol  extension exports 2  functions, ~write-tap~
  and ~write-tap-to-file~. These functions write  a test results database using
  the TAP format.

*** Code the Unit Test First
- http://www.extremeprogramming.org/rules/testfirst.html


When you create your tests first, before the code, you will find it much easier
and faster  to create your code.  The combined time  it takes to create  a unit
test and create some  code to make it pass is about the  same as just coding it
up straight  away. But, if you  already have the  unit tests you don't  need to
create them after the code saving you some time now and lots later.

Creating a  unit test  helps a developer  to really consider  what needs  to be
done.  Requirements  are  nailed  down  firmly   by  tests.  There  can  be  no
misunderstanding a specification written in the form of executable code.

You also have immediate  feedback while you work. It is often  not clear when a
developer has finished  all the necessary functionality. Scope  creep can occur
as extensions and error conditions are  considered. If we create our unit tests
first then we know when we are done; the unit tests all run.

There is a rhythm  to developing software unit test first.  You create one test
to  define some  small aspect  of  the problem  at  hand. Then  you create  the
simplest code that will make that test pass. Then you create a second test. Now
you add to the  code you just created to make this new  test pass, but no more!
Not until you have  yet a third test. You continue until  there is nothing left
to test. The coffee maker problem shows an example written in Java.

**** Extreme Programming---A gentle introduction
- http://www.extremeprogramming.org/index.html


#+texinfo:@ifhtml
[[file:../resources/images/project.gif]]
#+texinfo:@end ifhtml
#+texinfo:@ifnothtml
[[file:./resources/images/project.gif]]
#+texinfo:@end ifnothtml


Extreme Programming  is successful  because it stresses  customer satisfaction.
Instead of  delivering everything you could  possibly want on some  date far in
the future this process delivers the software  you need as you need it. Extreme
Programming  empowers  your  developers  to  confidently  respond  to  changing
customer requirements, even late in the life cycle.

***** Simple Rules
- http://www.extremeprogramming.org/rules.html

****** Planning
- User Stories
- Release Planning---Release Schedule
- Frequent small releases
- Project divided into iterations
- Iteration planning starts each iteration

****** Managing
- Open work space
- Sustainable pace
- Stand-up meeting to start each day
- Project Velocity is measured
- Move people around
- Fix XP

****** Designing
- Simplicity
- System metaphor
- CRC cards
- Spike solutions
- No functionality is added early
- Refactor

****** Coding
- Customer is always available
- Code to agreed standards
- Code the unit test first
- Production code is pair programmed
- One pair integrates code at a time
- Integrate first
- Dedicated integration computer
- Collective ownership

****** Testing
- All code must have unit tests
- All code must pass all unit tests
- When a bug is found, tests must be created
- Acceptance tests are run often

**** The Values of Extreme Programming
- http://www.extremeprogramming.org/values.html

**** Simplicity is the Key
- http://www.extremeprogramming.org/rules/simple.html

**** User Stories
- http://www.extremeprogramming.org/rules/userstories.html

User stories serve the same purpose as use cases but are not the same. They are
used to create  time estimates for the release planning  meeting. They are also
used instead of a large requirements  document. User Stories are written by the
customers as things that  the system needs to do for them.  They are similar to
usage  scenarios,  except that  they  are  not  limited  to describing  a  user
interface. They are in  the format of about three sentences  of text written by
the customer in the customers terminology without techno-syntax.

*** CS 325 Lisp Unit Tester
- by Chris Riesbeck


My main  goal for ~lisp-unit~  was to make it  simple to use,  particularly for
beginning Lisp programmers.


** Lisp Unit2
"A  Test  Framework  for Common  Lisp  in  the  style  of JUnit,  designed  and
implemented with simplicity of use in mind."

- https://github.com/AccelerationNet/lisp-unit2


Lisp-unit2 is  a Common Lisp  library that supports unit  testing. It is  a new
version of a library of the lisp-unit library written by Chris Riesbeck.

- [[http://russ.unwashedmeme.com/blog/?p=434][CommonLisp Testing: announcing Lisp-Unit2]]

Blog post by the author of Lisp-Unit2 announcing the new project and explaining
it a bit.

#+texinfo: @heading Features

- Written in portable Common Lisp
- Loadable with ASDF or Quicklisp
- Simple to define and run tests
- Redefine functions and macros without  reloading tests - tests are recompiled
  before each run and at definition time
- Tests have source-location for going to definition
- Supports  testing:  return  values,  printed output,  macro  expansions,  and
  conditions. Special support for testing floating and rational point numbers
- Running  a single  test  returns  a test-result  object.  Running many  tests
  returns a test-result-db
- Tests grouped and accessed by name, tag, and package of test name
- Signals for  starting and completing  test runs  (both individually and  as a
  group)


#+texinfo: @heading Use

: (ql:quickload :lisp-unit2)
or
: (asdf:load-system :lisp-unit2)

** Prove
Yet another unit testing framework for Common Lisp by Eitaro Fukamachi.

(This project was originally called =CL-TEST-MORE=.)

- [[https://github.com/fukamachi/prove][Prove on GitHub]] (archived)


The advantages of 'prove' are:

- Various simple functions for testing and informative error messages
- ASDF integration
- Extensible test reporters
- Colorizes the report if it's available (note for SLIME)
- Reports test durations


You can install 'prove' via Quicklisp.

: (ql:quickload :prove)

See [[*SLIME Colors for Testing using Prove][SLIME Colors for Testing using Prove]] to add colored output in SLIME when
using Prove.
** Rove
"Rove  is a  unit  testing  framework for  Common  Lisp  applications. This  is
intended to be a successor of Prove."  Eitaro Fukamachi (author of Prove)

- [[https://github.com/fukamachi/rove][Rove on GitHub]]
** clunit
"A Common Lisp Unit Testing Framework."

- [[https://github.com/tgutu/clunit][clunit on GitHub]]
** Parachute
"An extensible and cross-compatible testing framework."

- [[https://github.com/Shinmera/parachute][Parachute on GitHub]]
** Mockingbird
"A small stubbing and mocking library for Common Lisp"

- [[https://github.com/Chream/mockingbird][Mockingbird on GitHub]]


This  package  provides  some  useful  stubbing and  mocking  macros  for  unit
testing. Used  when specified functions  in a test  should not be  computed but
should instead return a provided constant value.
** Check-it
"Randomized specification-based testing for Common Lisp. Available through
Quicklisp."

- [[https://github.com/DalekBaldwin/check-it][check-it on GitHub]]


This is  a randomized  property-based testing library  for Common  Lisp. Rather
than  being a  full-fledged  general  test framework  in  its  own right,  it's
designed to embed randomized tests in whatever framework you like.
** CL-Coverals
"A helper library to post test coverage to [[https://coveralls.io/][Coveralls]]."

- [[https://github.com/fukamachi/cl-coveralls][CL-Coveralls on GitHub]]
** FranzInc Tester
"Tester framework for Common Lisp"

- https://github.com/franzinc/tester
* Common Lisp Object system---CLOS
- https://www.dreamsongs.com/CLOS.html

** CLOS History
- Levine, /Fundamentals of CLOS/ 2003-07-15 ([[Livine][see below]])

The functionality  belonging to this name  [CLOS] was added to  the Common Lisp
language between the publication of Steele's first edition of "Common Lisp, the
Language" in 1984 and the formalization of the language as an ANSI standard ten
years later.

The source material for CLOS was a  report written in three chapters. The first
two,  consisting  of "Programmer  Interface  Concepts"  and "Functions  in  the
Programmer Interface",  will now be  found as the two  halves of chapter  28 in
[Steele 1990] and  were the basis for relevant parts  of the ANSI specification
when it  later appeared.  The third  chapter, on  the Metaobject  protocol, was
regarded (by its authors, I believe) as incomplete and never published.

- Linda G. DeMichiel, /The Common Lisp Object System/

The Common  Lisp Object System  is an object-oriented programming  paradigm de-
signed for Common Lisp. Over a period  of twenty months, the Common Lisp Object
System  design group  took  the best  ideas from  CommonLoops  and Flavors  and
combined  them  into a  new  object-oriented  paradigm  for Common  Lisp.  This
combination is not simply a union: it is  a new paradigm that is similar in its
outward  appearances to  Com- monLoops  and Flavors,  and it  has been  given a
firmer underlying semantic basis. The  major participants in this design effort
were Daniel Bobrow  and Gregor Kiczales from Xerox, David  Moon and Sonya Keene
from Symbolics, and Richard Gabriel and Linda DeMichiel from Lucid.

The Common Lisp Object  System has been proposed as a  standard for ANSI Common
Lisp. In 1987, the X3J13 committee endorsed an earlier, but incomplete, version
of the specification, stating that it would almost certainly be adopted as part
of the Common Lisp standard, and  encouraged implementors to proceed with trial
implementations. In  June 1988,  the X3J13 committee  accepted the  Common Lisp
Object  System  Programmer  Interface,  as defined  in  Document  88-002R,  for
inclusion into the Common Lisp language being specified by X3J13. This paper is
a  report on  the specification  of the  Common Lisp  Object System  Programmer
Interface that was adopted by X3J13 in June 1988.

** Common Lisp Object System Specification
- [[https://www.dreamsongs.com/CLOS.html][CLOS]]

  The specification was published in  the journal Lisp and Symbolic Computation
  (LASC)  in Volume  1, Numbers  3-4,  and was  formally accepted  by X3J13  in
  June 1988.

- [[https://www.dreamsongs.com/Files/ECOOP.pdf][Overview]]

  The introduction to that double issue.

- [[https://www.dreamsongs.com/Files/concepts.pdf][Conceptual Material]]

- [[https://www.dreamsongs.com/Files/Functions.pdf][Functional Material]]

- [[https://www.dreamsongs.com/Files/LASC-Overview.pdf][Companion Description]] by Linda DeMichiel

  It  should  be read  by  people  unfamiliar with  Lisp-based  object-oriented
  languages or by people who do not wish to read the full specification.

- [[https://www.dreamsongs.com/Files/clos-cacm.pdf][CLOS: Integrating Object-Oriented and Functional Programming]], 2004

- [[https://www.dreamsongs.com/Files/clos-book.pdf][CLOS in Context: The Shape of the Design Space]], 2004

** CLOS Fundamentals
- <<Livine>>[[http://cl-cookbook.sourceforge.net/clos-tutorial/][Fundamentals of CLOS]] by Nick Levine 2003-07-15


The intention  of this  tutorial is  to provide a  sufficient grounding  in the
(say) 10% of  CLOS which covers 90% of  use cases - enough to get  a novice off
the ground.

** CLOS Programming
- Sonya Keene, /Object-Oriented Programming in Common Lisp--A Programmer's
  Guide to CLOS/, 1989
  - https://doc.lagout.org/programmation/Lisp/Object-Oriented%20Programming%20in%20Common%20Lisp_%20A%20Programmer%27s%20Guide%20to%20CLOS%20%5BKeene%201989-01-11%5D.pdf

  "[This] is a very easy introduction and more thorough than the single chapter
  in [Graham 1995], but it will obviously take you longer to read." --Levine.
** CLOS References
- [[https://lifegoo.pluskid.org/upload/doc/object_models/CLOS.pdf][CLOS: The Common Lisp Object System A Overview]]

- [[https://engineering.purdue.edu/RVL/Publications/Kersten93ATutorial2.pdf][A TUTORIAL ON LISP OBJECT-ORIENTED PROGRAMMING FOR BLACKBOARD COMPUTATION]]
* Common Lisp Network Programming
** Programming network sockets in Lisp
In this article,  I'll show you how  you can program sockets in  Lisp using the
SBCL implementation.

- https://sinax.be/blog/lisp/programming-network-sockets-in-lisp.html

** SBCL Networking
- http://www.sbcl.org/manual/#Networking
** USocket
"Universal socket library for Common Lisp"

- [[https://common-lisp.net/project/usocket/][USOCKET - Universal socket library for Common Lisp]]
- [[https://common-lisp.net/project/usocket/api-docs.shtml][USOCKET API documentation]]
- https://github.com/usocket/usocket
- [[http://beej.us/guide/bgnet/html/][Beej's Guide to Network Programming]]
* Common Lisp on Emacs
** Emacs Lisp
*** Emacs Lisp vs Common Lisp
Learning Emacs Lisp is useful and similar (but different from CL
- Dynamic scope is everywhere
- There are no reader (or reader-related) functions
- Does not support all the types that are supported in CL
- Incomplete implementation of CLOS (with the add-on EIEIO package)
- Not all of CL is supported
- No numerical tower support


Some good Emacs Lisp learning resources
- [[https://www.gnu.org/software/emacs/manual/eintr.html][An Introduction to Programming in Emacs Lisp]]
- [[http://www.oreilly.com/catalog/gnuext/][Writing Gnu Emacs Extensions]]
- [[http://wikemacs.org/wiki/Category:Emacs_Lisp][Wikemacs]]

*** Emacs Lisp Reference
- An Introduction to Programming in Emacs Lisp ::

    https://www.gnu.org/software/emacs/manual/html_node/eintr/index.html

    https://www.gnu.org/software/emacs/manual/pdf/eintr.pdf

    https://github.com/RenWenshan/emacs-lisp-intro-solutions

- Emacs Lisp Reference Wiki ::

    https://www.emacswiki.org/emacs/EmacsLispReference

- Learn Emacs Lisp ::

    https://www.emacswiki.org/emacs/LearnEmacsLisp

- Emacs Lisp Cookbook ::

    https://www.emacswiki.org/emacs/ElispCookbook

- Category Code ::

    https://www.emacswiki.org/emacs/CategoryCode
*** Lisp-Mode
Emacs Lisp Mode is enabled for any files ending in =.el= or when
editing the Emacs InitFile.
**** Evaluating Expressions in Lisp-Mode
- sexp :: any readable Lisp expression --- code enclosed in
  parentheses, a string enclosed in double quotes, a variable name, a
  quoted expression, a numeral, and so on.

- eval-last-sexp :: =[C-u] C-x C-e=

  This prints the value of the immediately-preceding sexp in the echo
  area. Using a prefix argument =C-u= will insert the result of an
  evaluation into the current buffer at point.

  To make ‘C-x C-e’ pretty-print:

  : (global-set-key [remap eval-last-sexp] 'pp-eval-last-sexp)

- eval-defun :: =C-M-x=

  This evaluates the defun at point. If the cursor is inside or
  immediately after a variable declaration, then this function, unlike
  ‘C-x C-e’, resets the variable to the value contained in the
  declaration.

- eval-expression :: =M-:=

  runs the command eval-expression. Evaluate EXP and print value in
  the echo area. When called interactively, read an Emacs Lisp
  expression and evaluate it. This is especially useful when you are
  coding and testing. It lets you quickly invoke non-interactive
  functions (non-commands).

  To make `M-:’ pretty-print:

  : (global-set-key [remap eval-expression] 'pp-eval-expression)

- eval-region :: =M-x eval-region=

  This evaluates the EmacsLisp code in the region. To evaluate all of
  the code in the current buffer, mark it using =C-x h= first.

- describe-variable :: =C-h v=

  Checks the current value of a variable. This prints the variable’s
  doc string and value.

- set-variable :: =M-x set-variable=

  Set user options.
**** Inferior Emacs Lisp Mode
- ielm :: =M-x ielm=

  Interactively evaluate Emacs Lisp expressions. This creates a buffer
  much like a shell buffer. Whatever Lisp expressions you type are
  evaluated and the result is printed into the buffer.

**** Lisp Interaction Mode
It is useful for evaluating EmacsLisp expressions. Typing ‘C-j’ after
an expression will print the result on the next line.
** Lisp Mode
*** ILISP Mode
A GNU Emacs Interface for Interacting with Lisp

[[http://www.inf.ufsc.br/~aldo.vw/func/ilisp/ilisp.html][ILISP]] is an interface from GNU Emacs to an inferior LISP.

ILISP is  a powerful GNU  Emacs interface to  many dialects of  Lisp, including
Lucid, Allegro,  Xanalys/Harlequin LispWorks,  GCL, KCL,  AKCL, ECL,  IBCL, and
CMUCL. Also some Scheme implementations are  supported as well as a preliminary
version of Xlisp/XlispStat.

ILISP was a package designed  to integrate various Lisp implementations (mostly
Common Lisp systems and various Scheme dialects) within Emacs (or XEmacs).

ILISP development stopped in 2004. You should use SlimeMode instead.
** SLIME Mode
http://www.common-lisp.net/project/slime/images2/slime-small.png

 - https://common-lisp.net/project/slime/
 - [[https://github.com/slime][SLIME on GitHub]]
 - [[https://common-lisp.net/project/slime/doc/html/][SLIME User Manual]]

 SLIME is an  Emacs mode for Common Lisp development.  SLIME extends Emacs with
 support for interactive programming in Common Lisp. While ~lisp-mode~ supports
 editing Lisp  source files, ~slime-mode~  adds support for interacting  with a
 running Common Lisp process  for compilation, debugging, documentation lookup,
 and so on.

- Provides REPL which is hooked to implementation directly in Emacs
- Has integrated Common Lisp debugger with Emacs interface
- Interactive object-inspector in Emacs buffer
- Has its own minor mode which enhances ~lisp-mode~ in many ways
- Supports every common Common Lisp implementation
- Symbol completion
- Cross-referencing
- Can perform macroexpansions


#+texinfo: @heading Featured Highlights

- Superior Lisp Interactive Mode for Emacs :: https://common-lisp.net/project/slime/

    "SLIME is an  Emacs mode for Common Lisp development.  Inspired by existing
  systems such as Emacs Lisp and ILISP, we are working to create an environment
  for hacking Common Lisp in."

- ~slime-mode~ ::
    An Emacs minor-mode to enhance lisp-mode with:
  - Code evaluation, compilation, and macroexpansion
  - Online documentation
    - =describe=
    - =apropos=
    - =hyperspec=
  - Definition finding
  - Symbol and package name completion
  - Automatic macro indentation based on =&body=.
  - Cross-reference interface

- SLDB ::
    Common Lisp debugger with an Emacs-based user interface

- REPL ::
    The Read-Eval-Print Loop ("top-level") is written in Emacs Lisp for
    tighter integration with Emacs.

- Compilation Notes ::
  SLIME  is able  to take  compiler messages  and annotate  them directly  into
  source buffers.

- Inspector ::
  Interactive object-inspector in an Emacs buffer.

- The currently supported Common Lisp implementations are ::
  - Steel Bank Common Lisp (SBCL) ::
    ~/opt/local/bin/sbcl~
  - Clozure Common Lisp (a.k.a. OpenMCL) (CCL) ::
    ~/usr/local/dev/bin/ccl~
  - CLISP ::
    ~/opt/local/bin/clisp~
  - Armed Bear Common Lisp (ABCL) ::
    ~/opt/local/bin/abcl~
  - Embedded Common Lisp (ECL) ::
    *NOTE*: fails to install using Xcode 12
  - CMU Common Lisp (CMUCL) ::
  - LispWorks ::
  - Allegro CL ::
  - Scieneer CL ::
  - Corman CL ::

*** Setting Up SLIME
 - ~inferior-lisp-program~ ::
   Point the =inferior-lisp-program= variable to your favourite Common
   Lisp implementation:
   : (setq inferior-lisp-program "sbcl")

 - slime-setup ::

   : (slime-setup '(slime-fancy slime-quicklisp slime-asdf))

*** Using Multiple LISPs in SLIME
To setup SLIME with multiple Lisp's configure the variable:

: slime-lisp-implementations

This variable holds a list of programs  and if you invoke SLIME with a negative
prefix argument,
: M-- M-x slime
you can select a  program from that list. When called  without a prefix, either
the name specified in
: slime-default-lisp
or the first item of the list will be used.

The elements of the list should look like:

: (NAME (PROGRAM PROGRAM-ARGS...) &key CODING-SYSTEM INIT INIT-FUNCTION ENV)

#+begin_src elisp
(setq slime-lisp-implementations
      '((ccl ("/opt/local/share/ccl/1.12/dx86cl64"))
        (sbcl ("/opt/local/bin/sbcl") :coding-system utf-8-unix)))
#+end_src

- NAME :: is a symbol and is used to identify the program.
- PROGRAM :: is the filename of the program.
- PROGRAM-ARGS :: is a list of command line arguments.
- CODING-SYSTEM :: the coding system for the connection. (see slime-net-coding-system)
- INIT ::
  should be  a function which takes  two arguments: a filename  and a character
  encoding. The  function should  return a  Lisp expression  as a  string which
  instructs Lisp to start the Swank server  and to write the port number to the
  file. At startup, SLIME starts the Lisp  process and sends the result of this
  function to Lisp’s standard input. As default, slime-init-command is used. An
  example is shown in Loading Swank faster.
- INIT-FUNCTION :: should be a function  which takes no arguments. It is called
  after the connection is established. (See also slime-connected-hook.)
- ENV :: specifies a list of environment variables for the subprocess. E.g.

  #+begin_src elisp
    (sbcl-cvs ("/home/me/sbcl-cvs/src/runtime/sbcl"
	       "--core" "/home/me/sbcl-cvs/output/sbcl.core")
	      :env ("SBCL_HOME=/home/me/sbcl-cvs/contrib/"))
  #+end_src

  initializes =SBCL_HOME= in the subprocess.

*** Running SLIME
 SLIME is started with the Emacs command:
 : M-x slime

 This uses the  inferior-lisp package to start a Lisp  process, loads and starts
 the Lisp-side  server (known as  “Swank”), and establishes a  socket connection
 between Emacs and  Lisp. Finally a REPL  buffer is created where  you can enter
 Lisp expressions for evaluation.

 #+texinfo: @heading Slime Editing Commands

 #+findex: slime-editing-commands.el
 The  file ~slime-editing-commands.el~  contains the  commands  used to  control
 =SLIME=.

 To tell SLIME which Lisp program to run, add a prefix argument:
 : C-u M-x slime

 To choose from multiple Lisp programs, add a negative prefix:

 : M-- M-x slime

 - ~slime-close-all-parens-in-sexp~ :: =C-c C-]=

   Balance parentheses of open s-expressions at point.

 - ~slime-reindent-defun~ :: =C-c M-q=

   Reindent the current defun, or refill  the current paragraph. If the current
   defun  has unbalanced  parens, an  attempt  will be  made to  fix it  before
   reindenting.

 - ~slime-beginning/end-of-defun~ :: =M-C-a/e=

 - ~slime-compile-defun~ :: =C-c C-c=

 - ~slime-switch-to-output-buffer~ :: =C-c C-z=

   Switch to the REPL.
=
 - ~slime-load-file~ :: =C-c C-l=

   Load a lisp file.

 - ~slime-compile-and-load-file~ :: =C-c C-k=

   Compile and load the buffer’s file and highlight compiler notes.

*** SLIME Contrib Modules

SLIME’s functionalities live  in packages and so-called  =contrib= modules must
be loaded to add further functionalities. The default ~slime-fancy~ includes:
- slime-autodoc
- slime-c-p-c
- slime-editing-commands
- slime-fancy-inspector
- slime-fancy-trace
- slime-fontifying-fu
- slime-fuzzy
- slime-mdot-fu
- slime-macrostep
- slime-presentations
- slime-references
- slime-repl
- slime-scratch
- slime-package-fu
- slime-trace-dialog

**** Loading Contrib Packages
 In  version   2.1  the   developers  moved   some  functionality   to  separate
 packages. This chapter tells you how to load contrib modules and describes what
 the particular packages do.

 Contrib packages aren’t loaded by default. You  have to modify your setup a bit
 so that Emacs knows where to find them and which of them to load.

 - ~slime-contribs~ :: variable holding the  list of package-names that you want
   to use.  Its default value is ~slime-fancy~ which loads almost everything.  a
   setup  to load  the slime-scratch  and slime-editing-commands  packages looks
   like:

   : (setq slime-contribs '(slime-scratch slime-editing-commands))

   After starting SLIME, the commands of both packages should be available.

   If you want to  enable more contribs after you start SLIME,  you can set the
   ~slime-contribs~ variable to another value and call:
   : M-x slime-setup.

   Note that packages will not be unloaded if they are removed from the list,
   and if you have more than one SLIME connection currently active, you must
   manually repeat ~slime-setup~ for each of them.


 You can unload contrib packages by calling a function whose name is obtained by
 adding =-unload= to  the contrib’s name, for every contrib  you wish to unload.
 So, to remove ~slime-repl~, you must call ~slime-repl-unload~.

**** The SLIME REPL
 SLIME uses  a custom Read-Eval-Print  Loop (REPL).  The REPL  user-interface is
 written in Emacs Lisp, which  gives more Emacs-integration than the traditional
 comint-based Lisp interaction:
 - Conditions signalled in REPL expressions are debugged with SLDB.
 - Return values are  distinguished from printed output by  separate Emacs faces
   (colours).
 - Emacs manages the REPL prompt with  markers. This ensures that Lisp output is
   inserted in the right place, and doesn’t get mixed up with user input.


 Load the REPL:
 : (add-to-list 'slime-contribs 'slime-repl)

 Select the output buffer, preferably in a different window.
 : M-x slime-switch-to-output-buffer (C-c C-z)

 Insert a call to the function defined around point into the REPL.
 : M-x slime-call-defun (C-c C-y)

 Inserts the last expression to the REPL and evaluates it there.
 : M-x slime-eval-last-expression-in-repl (C-c C-j)

**** SLIME-Helm

SLIME also has some nice extensions like Helm-SLIME which features, among
others:
- Fuzzy completion,
- REPL and connection listing,
- Fuzzy-search of the REPL history,
- Fuzzy-search of the apropos documentation.

**** User-interface Conventions
 There are a few "global" user-interface conventions.

***** Temporary Buffers
 Some SLIME commands create temporary buffers to display their results.

 - Temporary buffers can be dismissed by pressing =q=.
 - Pressing =<RET>= is supposed to “do the most obvious useful thing.”
 - Temporary buffers containing Lisp symbols use ~slime-mode~ in addition to any
   special mode of their own.
 - ~slime-description-autofocus~ (default =nil=); determines which buffer gets
   the initial focus.

***** =*inferior-lisp*= Buffer
 SLIME internally uses the ~comint~ package to start Lisp processes.

 - The buffer =*inferior-lisp*= contains the  Lisp process’s own top-level. This
   direct access to Lisp is useful for troubleshooting, and some degree of SLIME
   integration is available using the ~inferior-slime-mode~.
 - Many people  load the  better integrated =SLIME  REPL= ~contrib~  module (see
   REPL) and ignore the =*inferior-lisp*= buffer.
*** SLIME Colors for Testing using Prove

SLIME doesn't support to color with ANSI colors in the REPL buffer officially.

You can add the feature by using [[https://github.com/enriquefernandez/slime-repl-ansi-color][slime-repl-ansi-color.el]].

After installing it, set ~prove:*enable-colors*~ to =T= before running tests.

#+begin_src lisp
;; A part of my ~/.sbclrc
(ql:quickload :prove)
(setf prove:*enable-colors* t)
#+end_src

If you would prefer not to load ~prove~ in every lisp session, set up this
method instead of the former:

#+begin_src lisp
defmethod asdf:perform :after ((op asdf:load-op) (c (eql (asdf:find-system :prove))))
  (setf (symbol-value (intern (string :*enable-colors*) :prove)) t))
#+end_src

** Redshank
"Common Lisp Editing Extensions (for Emacs)"

- [[https://github.com/michaelw/redshank/][Redshank on GitHub]]

** GNU Emacs Common Lisp Emulation
This file documents the GNU Emacs Common Lisp emulation package.

- [[https://www.gnu.org/software/emacs/manual/html_node/cl/index.html#Top][cl-lib Manual]]
- [[https://github.com/emacs-mirror/emacs/blob/master/lisp/emacs-lisp/cl-lib.el][cl-lib on GitHub]]

This document  describes a set  of Emacs  Lisp facilities borrowed  from Common
Lisp.  Common Lisp  is a  huge language,  and Common  Lisp systems  tend to  be
massive and extremely complex. Emacs Lisp, by contrast, is rather minimalist in
the choice of Lisp features it offers the programmer. As Emacs Lisp programmers
have  grown  in  number,  and  the applications  they  write  have  grown  more
ambitious, it has become  clear that Emacs Lisp could benefit  from many of the
conveniences of Common Lisp.

The CL package adds a number of Common Lisp functions and control structures to
Emacs Lisp.  This package  is distributed with  Emacs, so there  is no  need to
install any additional files in order to start using it.

*** Organization

The Common Lisp package is organized into four main files:

- cl-lib.el  :: This  is  the main  file, which  contains  basic functions  and
  information about the package.

  The  file  ~cl-lib.el~  includes  all necessary  autoload  commands  for  the
  functions  and macros  in  the other  three  files.  All you  have  to do  is
  ~(require 'cl-lib)~, and  ~cl-lib.el~ will take care of pulling  in the other
  files when they are needed.

- cl-extra.el  ::  This file  contains  the  larger,  more complex  or  unusual
  functions. It is kept separate so that packages which only want to use Common
  Lisp fundamentals like the cl-incf function won’t need to pay the overhead of
  loading the more advanced functions.

- cl-seq.el :: This file contains most  of the advanced functions for operating
  on sequences or lists, such as cl-delete-if and cl-assoc.

- cl-macs.el ::  This file  contains the  features that  are macros  instead of
  functions. Macros expand when the caller is  compiled, not when it is run, so
  the  macros generally  only  need to  be present  when  the byte-compiler  is
  running (or when the macros are used  in uncompiled code). Most of the macros
  of this package are isolated in cl-macs.el  so that they won’t take up memory
  unless you are compiling.

- cl.el :: There  is another file, ~cl.el~,  which was the main  entry point to
  this package  prior to Emacs 24.3.  Nowadays, it is replaced  by ~cl-lib.el~.
  The two provide the same features (in most cases), but use different function
  names  (in  fact,  cl.el  mainly   just  defines  aliases  to  the  cl-lib.el
  definitions).

  Since the old ~cl.el~ does not use a clean namespace, Emacs has a policy that
  packages distributed with Emacs must not load ~cl~ at run time. (It is ok for
  them to  load ~cl~  at compile  time, with  ~eval-when-compile~, and  use the
  macros it provides.) There is no such restriction on the use of ~cl-lib~. New
  code should use ~cl-lib~ rather than ~cl~.

- cl-compat.el  :: There  is one more file, ~cl-compat.el~,  which defines some
  routines from the older Quiroz ~cl.el~ package that are not otherwise present
  in the new package. This file is obsolete and should not be used in new code.

*** Usage

: (require 'cl-lib)

Add this  ~require~ statement  to your init  file if you  make frequent  use of
features from this package.

Code  that  only  uses macros  from  this  package  can  enclose the  above  in
~eval-when-compile~.

Except where noted, all functions defined by this package have the same calling
conventions as  their Common  Lisp counterparts,  and names  that are  those of
Common Lisp plus a ‘cl-’ prefix.

Internal function  and variable names  in the  package are prefixed  by =cl--=.
Here is a complete list of functions prefixed by =cl-= that were not taken from
Common Lisp:

: cl-callf           cl-callf2          cl-defsubst
: cl-letf            cl-letf*

The following simple  functions and macros are defined in  ~cl-lib.el~; they do
not cause other components like ~cl-extra~ to be loaded.

#+begin_example
cl-evenp           cl-oddp            cl-minusp
cl-plusp           cl-endp            cl-subst
cl-copy-list       cl-list*           cl-ldiff
cl-rest            cl-decf [1]        cl-incf [1]
cl-acons           cl-adjoin [2]      cl-pairlis
cl-pushnew [1,2]   cl-declaim         cl-proclaim
cl-caaar…cl-cddddr                  cl-first…cl-tenth
cl-mapcar [3]

[1] Only when place is a plain variable name.

[2] Only if :test is eq, equal, or unspecified, and :key is not used.

[3] Only for one sequence argument or two list arguments.
#+end_example

*** Program Structure
This section describes  features of this package that have  to do with programs
as  a whole:  advanced argument  lists  for functions,  and the  ~cl-eval-when~
construct.

**** Argument Lists
* Common Lisp Learning
** Practical Common Lisp
** Common Lisp---An Interactive Approach
:PROPERTIES:
:cite:     https://cse.buffalo.edu/~shapiro/Commonlisp/
:author:   Stuart C. Shapiro
:date:     1992
:copyright: Stuart C. Shapiro
:errata:   Online version has been corrected
:last-modified: Thu Nov 13 16:37:19 2014
:END:

- https://cse.buffalo.edu/~shapiro/Commonlisp/

  This  book is  out of  print. The  publisher has  returned the  copyright and
  rights to  me, the author.   I am  making it available  here in pdf,  and dvi
  formats, and in two  versions of ps format, a heavier font  and a finer font,
  under  the  following  conditions:  hardcopies  must  retain  the  title  and
  copyright pages; web links must point to  this page rather than to a separate
  copy of the dvi, ps, or pdf file;  quotes and other copies of material in the
  book,  including programs,  must include  the citation:  "Stuart C.  Shapiro,
  /COMMON LISP: An Interactive Approach./ W. H. Freeman, New York, 1992."

  A Baker's Dozen  of Reasons to Adopt Common Lisp:  An Interactive Approach by
  Stuart C. Shapiro

  1. Contains many sample interactions to illustrate the material in the text,
     helping students know what to expect when they experiment on their own.

  2. Introduces pure Lisp before imperative Lisp to give students a familiarity
     with the functional approach and to help develop a balanced programming
     style.

  3. Labels each exercise as either review, instruction, drill, utility, or
     part of one of the extended programming projects, so that an intelligent
     choice can be made when only selected exercises are to be done.

  4. Presents coverage of packages early in Chapter 7, and then uses packages
     consistently and frequently. From Chapter 7 on, every set of exercises
     utilizes a different package for thorough student familiarity.

  5. Carefully distinguishes S-expressions from forms beginning with the first
     chapter and consistently throughout.

  6. Discusses the important Common Lisp types: numbers (integers, floating
     point numbers, and ratios), strings, characters, symbols, packages, lists,
     conses, functions, hash tables, and single dimensional arrays.

  7. Provides two chapters on the Common Lisp Object System (CLOS) to introduce
     students to object-oriented programming.

  8. Introduces check-type in Chapter 16 and uses it consistently afterwards to
     help students ensure that the objects passed to a function are of the
     correct type.

  9. Views the documentation string as a required part of a function
     definition.

  10. Uses first and rest instead of car and cdr, eql instead of eq, and setf
      instead of setq to correspond with modern Common Lisp.

  11. Contains solutions to about one-third of the programming exercises in
      Appendix A.

  12. Includes a Common Lisp reference manual that documents all the Common
      Lisp functions, macros, and special forms introcuced in the text.

  13. An Instructor's Guide, available free upon adoption, presents chapter
      objectives and solutions to all programming exercises.


- [[https://cse.buffalo.edu/~shapiro/Courses/CSE202/Notes/][CSE202: Programming in Lisp]]

  The notes  from an  on-line course, CSE  202, using this  book, and  given in
  Fall, 2000, is available.

- [[https://cse.buffalo.edu/~shapiro/Courses/CSE202/Summer2004/][A Short Course in Common Lisp]]

  An  even more  up-to-date, faster  introduction  to Common  Lisp, written  in
  Summer   2004  and   somewhat   biased  toward   Allegro   Common  Lisp,   is
  Stuart C. Shapiro & David R. Pierce, A Short Course in Common Lisp.
* ANSI Common Lisp
  :PROPERTIES:
  :author:   Paul Graham
  :date:     1996
  :ISBN:     0133708756
  :END:
- [[http://www.paulgraham.com/acl.html][ANSI Common Lisp Author's Site]]
- [[https://wiki.c2.com/?AnsiCommonLisp][ANSI Common Lisp Wiki]]
- [[http://www.paulgraham.com/ancomliser.html][Errata]]
- [[https://courses.cs.northwestern.edu/325/readings/graham/graham-notes.html][Annotations by Chris Riesbeck in EECS 325]]


#+begin_comment
[[./resources/src/acl2.lisp][Open source code]]
#+end_comment


#+attr_texinfo: :author Chris Riesbeck
#+begin_quote
Graham  has an  excellent  Lisp  coding style.  His  code  is maintainable  and
portable. Function definitions are short  and well-motivated, and, for the most
part, variable and function names are clear and helpful.
#+end_quote

The aim of this book is to teach you Common Lisp quickly and thoroughly.

It is two books in one:

1. Tutorial that explains all the essential concepts of Lisp programming;
2. Up-to-date  summary of  ANSI Common  Lisp describing  every operator  in the
   language.


It assumes no prior knowledge of Lisp.  It begins with the most basic concepts,
and pays special attention to the points that tend to confuse someone seeing
Lisp for the first time.

The best way to learn Lisp is to use it.  This book is designed to get you
started as quickly as possible.  After a brief Introduction,
- Chapter Two explains, in 21 pages,  everything you need to start writing Lisp
  programs;
- Chapters  3-9 introduce  the essential  elements of  Lisp programming.  These
  chapters pay special attention to critical concepts like the role of pointers
  in Lisp,  the use  of recursion  to solve problems,  and the  significance of
  first-class functions.
- Chapters   10-14  cover   macros,   CLOS,  operations   on  list   structure,
  optimization, and advanced topics like packages and read-macros.
- Chapters 15-17 sum up the lessons of the preceding chapters in three examples
  of real applications:
  - a program for making logical inferences,
  - an HTML generator, and
  - an embedded language for object-oriented programming.
- Four Appendices A-D:
  - include a guide to debugging,
  - source code for 58 Common Lisp operators,
  - a summary of the differences between ANSI Common Lisp andprevious versions of the language, and
  - a refernce describing every operatorin ANSI Common Lisp.
- Section of notes containing clarifications, references, additional code, and
  occasional heresies.

** On Lisp Companion Volume
#+cindex:macros
#+cindex:On Lisp
Lisp has a  unique quality: macros.  Lisp programmers can,  and often do, write
programs to write their  programs for them. Lisp is the  only major language in
which  this is  a routinely  used  technique, because  Lisp is  the only  major
language to provide  the abstractions that make it convenient.  I would like to
invite  readers who  are interested  in learning  more about  macros and  other
advanced techniques to read the companion volume, /On Lisp/.

** Features

This book offers a broad description  of the CommonLisp language. There is some
overlap with  (but newer  than) the  author's earlier  and more  advanced book,
/OnLisp/.  It is unusually well-written and enjoyable.

- An up-to-date reference manual for ANSI Common Lisp.
- An in-depth  look at  object-oriented programming.  Explains the  Common Lisp
  Object System  (CLOS), and also shows  how to write your  own object-oriented
  language.
- Over  20  substantial  examples,  including programs  for  ray-tracing,  text
  generation, pattern-matching, logical inference, generating HTML, sorting and
  searching, file I/O, compression, and date arithmetic.
- Special attention  to critical  concepts, including  prefix syntax,  code vs.
  data, recursion,  functional programming,  types, implicit  pointers, dynamic
  allocation,  closures, macros,  class precedence,  and generic  functions vs.
  message-passing.
- A complete guide to optimization.
- The  clearest and  most thorough  explanation of  macros in  any introductory
  book.
- Examples   that  illustrate   Lisp   programming   styles,  including   rapid
  prototyping, bottom-up programming, object-oriented programming, and embedded
  languages.
- An appendix on debugging, with examples of common errors.

** Introduction
Lisp  is  designed  to evolve.  You  can  define  new  Lisp operators.  As  new
abstractions  become popular  (object-oriented  programming,  for example),  it
always  turns out  to be  easy to  implement  them in  Lisp. Like  DNA, such  a
language does not go out of style.

*** New Tools
Why learn Lisp? Because  it allows you to do things that you  can't do in other
languages. Suppose you  want to write a  function that takes a  number ~n~, and
returns a function that adds ~n~ to its argument:

#+begin_src lisp
  ; Lisp
  (defun addn (n)
    #'(lambda (x)
	(+ x n)))
#+end_src

What does ~addn~ look like in C? You just can't write it. Programming languages
teach you not to want what they cannot provide. You have to think in a language
to write programs in it, and it's hard to want something you can't describe.

Closures are  only one of  the abstractions we  don't find in  other languages.
Another unique feature of Lisp is that Lisp programs are expressed as Lisp data
structures. This  means that you can  write programs that write  programs. They
are called macros.

With  macros, closures,  and run-time  typing, Lisp  transcends object-oriented
programming. The proof  of it is made  quite explicit, in code,  in Chapter 17.
Chapters 2-13  will gradually introduce  all the  concepts that you'll  need in
order to understand the code in Chapter 17.

*** New Techniques
Lisp gives you tools that other languages don't provide. Taken separately, the
new things that come with Lisp---automatic memory management, manifest typing,
closures, and so on---each make programming that much easier. Taken together,
they form a critical mass that makes possible a new way of programming.

#+texinfo: @subheading Extensible Software

#+cindex:extensible software
Lisp is designed to be /extensible/: it lets you define new operators yourself.
This is possible  because the Lisp language  is made out of  the same functions
and macros as your own programs. So  it's no more difficult to extend Lisp than
to write a program in it.  In fact, is so easy (and so useful) that extending
the language is standard practice.

#+texinfo: @subsubheading Bottom-up Programming

#+cindex:bottom-up programming
As  you are  writing your  program /down/  toward the  language, you  build the
language /up/ toward your program. You work /bottom-up/, as well as /top-down/.

Almost any  program can benefit from  having the language tailored  to suit its
needs,  but  the  more  complex  the program,  the  more  valuable  /bottom-up/
programming  becomes.

A /bottom-up/ program can be written as  a series of layers, each one acting as
a sort of programming language for the one above. /TeX/ was one of the earliest
programs  to be  written this  way.  You can  write programs  bottom-up in  any
language, but Lisp is far the most natural vehicle for this style.

#+cindex:extensible software
/Bottom-up/ programming leads naturally to extensible software. If you take the
principle of /bottom-up/  programming all the way to the  topmost layer of your
program, then that  layer becomes a programming language for  the user. Because
the  idea of  extensibility is  so deeply-rooted  in Lisp,  it makes  the ideal
language of writing extensible software.  Three of the most successful programs
of the  1980s provide Lisp  as an extension  language: Gnu Emacs,  Autocad, and
Interleaf.

#+texinfo: @subheading Reusable Software

#+cindex:reusable software
Working bottom-up is also the best  way to get /reusable/ software.

,*The essence  of writing /reusable/ software  is to separate the  general from
the specific, and bottom-up programming inherently creates such a separation.*

Instead  of  devoting   all  your  effort  to  writing   a  single,  monolithic
application, you devote part of your effort to building a language, and part to
writing a (proportionately smaller) application on  top of it. What is specific
to  this application  will be  concentrated in  the topmost  layer. The  layers
beneath will from a language for  writing applications like this one---and what
could be more reusable than a programming language?

#+texinfo: @subheading Big Abstractions and a Dynamic Interactive Environment

Lisp allows  you not just  to write more  sophisticated programs, but  to write
themn faster.  Lisp programs tend to  be short---the language gives  you bigger
concepts, so  you don't  have to  use as  many. The  time it  takes to  write a
program  depends mostly  on its  length.  So this  fact alone  means that  Lisp
programs take less time to write.

The  effect   is  amplified  by   Lisp's  /dynamic  character/:  in   Lisp  the
edit-compile-test cycle is so short that programming is real-time.

/Bigger  abstractions/ and  an  /interactive environment/  can  change the  way
organizations develop software. The phrase /rapid prototyping/ describes a kind
of programming that began  with Lisp: in Lisp, you can  often write a prototype
in less time that it would take to write the spec for one. Such a prototype can
be so abstract  that it makes a  better spec than one written  in English. Lisp
allows you to  make a smooth transition from prototype  to production software.
When Copmmon  Lisp programs are  written with an eye  to speed and  compiled by
modern  compilers,  they run  as  fast  as  programs  in any  other  high-level
language.

*** A New Approach
#+texinfo: @heading The Lisp Style of Programming

One of the aims of this book is  to explain not just the Lisp language, but the
/new  approach  to  programming/  that  Lisp  makes  possible.  As  programming
environments grow in power, and languages become more abstract, the /Lisp style
of programming/ is gradually replacing the old plan-and-implement model.

#+texinfo: @subheading Reduce the Cost of Mistakes---Increase Exploration

It would be safer  to bet that specifications will be  misquided, and that code
will  be full  of bugs.  This is  what the  new model  of programming  assumes.
Instead of hoping that people won't make mistakes, it tries to make the cost of
mistakes very low.  The cost of a  mistake is the time required  to correct it.
With powerful  languages and  good programming environments,  this cost  can be
greatly reduced. *Programming  style can then depend less on  planning and more
on exploration*.

Planning is a  necessary evil. It is  a respone to risk: the  more dangerous an
undertaking, the  more important it is  to plan ahead. Powerful  tools decrease
risk, and  so decrease the  need for planning. The  design of your  program can
then  benefit from  what  is probably  the most  useful  source of  information
available: the experience of implementing it.

#+texinfo: @subheading Rapid Prototyping---Not Specifications

/Lisp style/ has been evolving in this direction since the 1960s. You can write
prototypes so  quickly in Lisp  that you can  go through several  iterations of
design  and implementation  before  you  would, in  the  old  model, have  even
finished writing out the specifications. You  don't have to worry so much about
design flaws, because you discover them a  lot sooner. Nor do you have to worry
so much about bugs. When you program  in a functional style, bugs can only have
a  local effect.  When  you use  a  very abstract  language,  some bugs  (e.g.,
dangling pointers)  are no longer possible,  and what remain are  easy to find,
because your  programs are so  much shorter. And  when you have  an interactive
environment, you can  correct bugs instantly, instead of enduring  a long cycle
of editing, compiling and testing.

/Lisp style/ has evolved this way  because it yields results. Less planning can
mean better design. More powerful tools are taking the risk out of exploration.
That's good  news for  programmers, because it  means that we  will be  able to
undertake more ambitious projects.
** Welcome to Lisp
This chapter aims to get you programming as soon as possible.  By the end of it
you will know enough Common Lisp to begin writing programs.
*** Form
#+cindex:topleval
Any lisp system will include an  interactive front-end called a /toplevel/. You
type Lisp expressions into the toplevel, and the system displays their values.

Lisp usually displays  a prompt to tell  you that it's waiting for  you to type
something. Many implementations of Common Lisp use =>= as the toplevel prompt.

#+texinfo: @subheading Lisp Expressions

One of the simplest kinds of /Lisp expression/ is the integer. If you enter =1=
after the prompt,

#+begin_example
> 1
1
>
#+end_example

the system will print its value, followed by another prompt.

In this case,  the value displayed is the  same as what we typed.  An number is
said  to /evaluate  to  itself/. Things  get more  interesting  when you  enter
expressions that  take some work  to evaluate. If you  want to add  two numbers
together, you type something like:

#+begin_example
> (+ 2 3)
5
#+end_example

#+cindex:operator
#+cindex:arguments
The =+= is  called the /operator/, and  the numbers =2= and =3=  are called the
/arguments/.

#+cindex:prefix notation
This form is called /prefix/ notation, because the operator comes first.  The
flexibility of prefix notation means that, in Lisp, =+= can take any number of
arguments, including none:

#+begin_example
> (+)
0
> (+ 2)
2
> (+ 2 3)
5
> (+ 2 3 4)
9
> (+ 2 3 4 5)
14
#+end_example

Because operators can take varying numbers of arguments, we need parentheses to
show where an expression begins and ends.

#+texinfo: @subsubheading Nested Expressions

Expressions can be nested.  That is, the arguments in an expression may
themselves be complex expressions:

: > (/ (- 7 1) (- 4 2))
: 3

#+texinfo: @subheading Expressions and Code Consist of Atoms and Lists

Another beauty of Lisp notation is: this is all there is.  All Lisp expressions
are either:
- atoms, like =1=, or
- lists, which consist of zero or more expressions enclosed in parentheses.

All Lisp code takes this form. A language like C has a more complicated syntax:
arithmetic expressions use infix notation; function  calls use a sort of prefix
notation, with the arguments delimited  by commas; expressions are delimited by
commas; and blocks of  code are delimited by curly brackets. In  Lisp, we use a
single notation to express all these ideas.

*** Evaluation
In this section we take a closer look at how expressions are evaluated.

#+texinfo: @subheading Evaluation Rule

When Lisp evaluates a function call, it does so in two steps:

1. First the arguments are evaluated from left to right.

2. The values of arguments are passed to the fucntion named by the operator.

If  any of  the arguments  are themselves  function calls,  they are  evaluated
according to the same rules.

Not all the operators in Common Lisp  are functions, but most are. And function
calls are always evaluated this way. The arguments are evaluated left-to-right,
and their  values are passed  to the function, which  returns the value  of the
expression as a whole. This is called the /evaluation rule/ for Common Lisp.

#+texinfo: @subheading Special Operators

One operator that  does not follow the Common Lisp  evaluation rule is ~quote~.
The ~quote~  operator is a /special  operator/, meaning that it  has a distinct
evaluation rule of its  own. And the rule is: do  nothing. The ~quote~ operator
takes a single argument and just returns it verbatim.

: > (quote (+ 3 5)
: (+ 3 5)

Common Lisp defines ='= as an abbreviation for ~quote~.  You can get the effect
of calling ~quote~ by affixing a ='= to the front of any expression:

: > '(+ 3 5)
: (+ 3 5)

Lisp provides the ~quote~ as a way of /protecting/ expressions from evaluation.

*** Data

**** Integers---Strings
#+cindex:integer
#+cindex:string
Lisp offers  all the  data types  we find  in most  other language,  along with
several  others that  we don't.  One  data type  we  have used  already is  the
/integer/, which  is written as  a series of  digits: =256=. Another  data type
Lisp  has  in common  with  most  other languages  is  the  /string/, which  is
represented as  a series of  characters surrounded  by double quotes:  ="ora et
labora"=.  Integers and strings both evaluate to themselves.

**** Symbols---Lists
#+cindex:symbol
#+cindex:list
Two Lisp data types that we don't  commonly find in other languages are symbols
and lists.  /Symbols/ are words.  Ordinarily, they are converted  to uppercase,
regardless of how you type them:

: > 'Artichoke
: ARTICHOKE

Symbols do not (usually) evaluate to themselves, so if you want to refer to a
symbol, you should quote it.

/Lists/ are represeted as zero or more elements enclosed in parentheses.  The
elements can be of any type, including lists.  You have to quote lists, or Lisp
would take them for function calls:

#+begin_example
> '(my 3 "Sons")
(MY 3 "Sons")
> '(the list (a b c) has 3 elements)
(THE LIST (A B C) HAS 3 ELEMENTS)
#+end_example

#+cindex:quote
One quote protects a whole expression, including expressions within it.

You  can  build lists  by  calling  ~list~. Since  ~list~  is  a function,  its
arguments are evaluated. Here we call to =+= with a call to ~list~:

: > (list 'my (+ 2 1) "Sons")
: (MY 3 "Sons")

**** Lisp Programs as Data---Lists
We re now  in a position to  appreciate one of the most  remarkable features of
Lisp:

/Lisp programs are expressed as lists./

It means  that Lisp  programs can  generate Lisp  code. Lisp  programmers write
programs to  write their programs for  them. It is important  to understand the
relation between  expressions and lists.  This is why we  need the quote.  If a
list is quoted,  evaluation returns the list  itself; if it is  not quoted, the
list is treated as code, and evaluation returns its value:

: > (list '(+ 2 1) (+ 2 1))
: ((+ 2 1) 3)

Here, the first argument  is quoted, and so yields a  list. The second argument
is not quoted, and is treated as a function call, yielding a number.

**** The Empty List
#+cindex:empty list
#+cindex:nil
In Common  Lisp, there  are two ways  of representing the  empty list.  You can
represent it as a pair of parentheses with nothing between them, or you can use
the symbol  =nil=. It will be  displayed as =NIL=  no matter how you  write it.
=NIL= evaluates to itself, and so does not need to be quoted.

*** List Operations

#+texinfo:@heading Build Lists

#+findex:cons
The function ~cons~ builds lists.  If its second argument is a list, it returns
a new list with the first argument added to the front.

: > (cons ’a ’(b c d))
: (A B C D)

#+findex:list
We can build up  lists by consing new elements onto an  empty list.  The ~list~
function is just a more convenient way of consing several things onto ~nil~.

#+begin_example
> (cons ’a (cons ’b nil))
(A B)
> (list ’a ’b)
(A B)
#+end_example

#+findex:car
#+findex:cdr
The primitive  functions for  extracting the  elemnets of  lists are  ~car~ and
~cdr~.  The ~car~ of  a list is the first element, and  the ~cdr~ is everything
after the first element.

#+begin_example
> (car ’(a b c))
A
> (cdr ’(a b c))
(B C)
#+end_example

You can use combinations of ~car~ and ~cdr~ to reach any element of a list.  If
you want to get the third element, you could say:

: > (car (cdr (cdr ’(a b c d))))
: C

#+findex:third
You can do the same thing by calling ~third~:

: > (third ’(a b c d))
: C

*** Truth

**** True and False
#+cindex:t
#+findex:listp
In Common Lisp,  the symbol =t= is the default  representation for truth.  Like
=nil=,  =t= evaluates  to itself.   The function  ~listp~ returns  true if  its
argumentis a list:

: > (listp ’(a b c))
: T

#+texinfo:@heading Predicate
#+cindex:predicate
A function whose return value is intended to be interpreted as truth or falsity
is called a /predicate/.  Common Lisp predicates often have names that end with
=p=.

#+cindex:false
#+cindex:nil
Falsity in Common Lisp is represented by =NIL=, the empty list.  If we give
~listp~ an argument that isn’t a list, it returns =NIL=:

: > (listp 27)
: NIL

#+cindex:truth
Although =t= is  the default representation for truth,  everything except =NIL=
also counts as true in a logical context.

**** Null and Not
#+findex:null
#+cindex:not
Because =NIL= plays two roles in Common List, the function ~null~, which
returns true of the empty list

: > (null nil)
: T

and the function ~not~, which returns =true= if its argument is false,

: > (not nil)
: T

do exactly the same thing.

**** If Special Operator
#+findex:if
The simplest conditional in Common Lisp is ~if~.  It usually takes three
arguments:
- a /test/ expression,
- a /then/ expression, and
- an /else/ expression

The /test/ expression is evaluated; if it returns =true=, the /then/ expression
is evaluated  and its value is  returned; but if the  /test/ expression returns
=false=, the /else/ expression is evaluated and its value is returned.

Like ~quote~, ~if~ is a special operator.  It could not possibly be implemented
as a function,  because the arguments in a function  call are always evaluated,
and the  whole point  of ~if~ is  that only  one of the  last two  arguments is
evaluated.

The /else/ expression is optional, and will default to =NIL= if it is omitted.

**** And---Or
#+findex:and
#+findex:or
The  logical operators  ~and~ and  ~or~ resemble  conditionals.  Both  take any
number of argument, but only evalue as many  as they need to in order to decide
what to return.  If all its arguments are =true= (not =NIL=), then ~and~
returns the value of the last one.

But if one of the arguments turns out to be fale, none of the arguments after
that get evaluated.  Similarly for ~or~ which stops as soon as it finds an
argument that is true.

These two operators are /macros/.  Like special operators, macros can cirumvent
the usual evaluation rule.

*** Functions
#+findex:function
You can define new functions with ~defun~.  It usually takes three or more
arguments:
- a name,
- a list of parameters, and
- one or more expressions that will make up the body of the function.

#+cindex:symbol
Symbols are variable names, existing as objects in their own right.  That’s why
symbols,  like lists,  have to  be quoted.   A list  has to  be quoted  because
otherwise  it will  be treated  as  code; a  symbol  has to  be quoted  because
otherwise it will be treated as a variable.

You can think of a function as a generalized version of a Lisp expression.  The
following expression tests whether the sum of 1 and 4 is greater than 3:

: > (> (+ 1 4) 3)
: T

By replacing these particular numbers with variables, we can write a function
that will test whether the sum of any two numbers is greater than a third:

: > (defun sum-greater (x y z)
:     (> (+ x y) z)
: SUM-GREATER
: > (sum-greater 1 4 3)
: T

Lisp  makes no  distinction between  a program,  a procedure,  and a  function.
Functions do for everything.   If you want to consider one  of the functions as
the /main/  function, you  can, but  you will  ordinarily be  able to  call any
function from  the toplevel.  Among other  things, this means that  you will be
able to test your programs piece by piece as you write them.

*** Recursion
#+cindex:recursion
A function  can call  any function,  including itself.   A function  that calls
itself  is  /recursive/.   The  Common Lisp  function  ~member~  tests  whether
something is an element  of a list.  Here is a simplified  version defined as a
recursive function:

#+begin_src lisp
  (defun our-member (obj lst)
    (if (null lst)
        nil
        (if (eql (car lst) obj)
            (our-member obj (cdr lst)))))
#+end_src

The predicate ~eql~  tests whether its two arguments are  identical: aside from
that, everything in this definition is something we have seen before.

The definition of ~our-member~ corresponds to the following English
description.  To test whether an object ~obj~ is a member of a list ~lst~, we:

1. First check whether ~lst~ is empty.  If it is, then ~obj~ is clearly not a
   member of it, and we’re done.
2. Otherwise, if ~obj~ is the first element of ~lst~, it is a member.
3. Otherwise, ~obj~ is only a member of ~lst~  if it is a member of the rest of
   ~lst~.

When you want to understand how a recursive function works, it can help to
translate it into a description of this kind.

*** Reading Lisp
Lisp programmers read and write code  by indentation, not by parentheses.  When
they are writing  code, they let the text editor  show which parentesis matches
which.  With a good editor, matching parentheses ceases to be an issue when you
are  writing  code.  And  because  there  are  universal conventions  for  Lisp
indentation,  it’s not  an  issue  when you’re  reading  code either.   Because
everyone uses the  same conventions, you can reaad code  by the indentation and
ignore the parentheses.

*** Input and Output
#+cindex:I/O
So far we have  done I/O implicitly, by taking advantage  of the toplevel.  For
real interactive programs  this is not likely  to be enough.  We look  at a few
functions for input and output.

#+findex:format
The most general output function in Common Lisp is ~format~.  It takes two or
more argument:
- the first indicates where the output is to be printed;
- the second  is a  string template,  and
- the remaining arguments are usually objects whose printed representations are
  to be inserted into a template.

The first argument to ~format~, =t=, indicates that the output is to be sent to
the default place.  Ordinarily, this will be the toplevel.  The second argument
is a  string that serves  as a template for  output.  Within this  string, each
=~A= indicates a position to be filled,  and the =~%= indicates a newline.  The
positions are filled by the values of the remaining arguments, in order.

#+findex:read
The standard function  for input is ~read~.  When given  no arguments, it reads
from the default place, which is usually the toplevel.  ~read~ will sit waiting
indefinitely until you type soemthing and hit return.

#+cindex:parser, Lisp
~read~ is a  complete Lisp parser.  It doesn’t just  read characters and return
them as  a string.  It parses  what it reads  and returns the Lisp  object that
results.

The body of a  function can have any number of  expressions.  When the function
is called, they  will be evaluated in  order, and the function  will return the
value of the last one.

#+cindex:side-effect
A  side-effect is  some change  to the  state of  the world  that happens  as a
consequence  of  evaluating  an  expression.   When we  evaluate  a  pure  Lisp
expression like =(+ 1 2)=, there are  no side-effects; it just returns a value.
But when we call  ~format~, as well as returning a  value, it prints something.
That’s one kind of side-effect.

When we  are writing code without  side-effects, there is no  point in defining
functions  with bodies  of more  than one  expression.  The  value of  the last
expression is  returned as  the value of  the function, but  the values  of any
preceding  expressions  are  thrown  away.   If  such  expressions  don’t  have
side-effects,  you would  have  no  way of  telling  whether  Lisp bothered  to
evaluate them at all.

*** Variables
One of the most frequently used operators in Common Lisp is ~let~, which allows
you to introduce new local variables:

#+begin_example
> (let ((x 1) (y 2))
    (+ x y))
3
#+end_example

A ~let~ expression has two parts:
1. a list  of instructions for creating variables, each  of the form =(variable
   expression)=.   Each variable  will initially  be set  to the  value of  the
   corresponding /expression/.
2. a body of expressions, which are evaluated in order.  The value of the last
   expression is returned as the value of the ~let‘~.

Here is an example of a more selective version of ~askem~ written using ~let~:

#+begin_src lisp
  (defun ask-number ()
    (format t "Please enter a number. ")
    (let ((val (read)))
      (if (numberp val)
          val
          (ask-number))))
#+end_src

This function creates  a variable ~val~ to hold the  object returned by ~read~.
Because it  has a  handle on  this object, the  function can  look at  what you
entered before deciding whether or not  to return it.  ~numberp~ is a predicate
that tests whether its argument is a number.

If the value  entered by the user  is not a number,  ~ask-number~ calls itself.
The result is a function that insists on getting a number.

#+cindex:local variable
#+cindex:global variable
Variables like  those we have seen  so far are called  /local/ variables.  They
are only  valid within a certain  context.  There is another  kind of variable,
called  a  /global/ variable,  that  can  be visible  everywhere.[fn::The  real
distinction here is between /lexical/ and /special/ variables.  More in Chapter
6.]

#+findex:defparameter
You  can  create  a  global  variable  by  giving  a  symbol  and  a  value  to
~defparameter~.

: > (defparameter *glob* 99)
: *GLOB*

Such a variable will then be  accessible everywhere, except in expressions that
create a new  local variable with the  same name.  To avoid  the possibility of
this happening  by accident, it’s  conventional to give global  variables names
that begin and  end with asterisks.  The  name of the variable  we just created
would be pronounced “star-glob-star”.

#+findex:defconstant
You can also define global constants by calling ~defconstant~:

: (defconstant limit (+ *glob* 1))

#+findex:boundp
There is no need  to give constants distinctive names because  it will cause an
error  if anyone  uses the  same name  for a  variable.  If  you want  to check
whether some symbol is the name of a global variable or constant, use ~boundp~:

: > (boundp ’*glob*)
: T

*** Assignment
#+findex:setf
In Common Lisp, the most general assignment operator is ~setf~.  We can use it
to do assigments to either kind of variable:

: > (setf *glob* 98)
: 98
: > (let ((n 10))
:     (setf n 2)
:     n)
: 2

When the first argument to ~setf~ is a symbol tht is not the name of a local
variable, it is taken to be a global variable:

: > (setf x (list ’a ’b ’c))
: (A B C)

That is,  you can create  global variables  implicitly, just by  assigning them
values.  In source files, it is better style to use explicit ~defparameters~.

You can do  more than just assign  values to variables.  The  first argument to
~setf~ can  be an expression as  well as a  variable name.  In such  cases, the
value of  the second  argument is inserted  in the /place/  referred to  be the
first:

: > (setf (car x) ’n)
: N
: > x
: (N B C)

The first  argument to  ~setf~ can be  almost any expression  that refers  to a
particular place.  All such operators are marked as “settable” in Appendix D.

You can give any (even) number of arguments to ~setf~.  An expression of the
form:

#+begin_example
(setf a b
      c d
      e f)
#+end_example

is equivalent to three separate calls to ~setf~ in sequence.

*** Functional Programming
/Functional programming/ means  writing programs that work  by returning values
instead of  by modifying things.   It is the  dominant paradigm in  Lisp.  Most
build-in Lisp functions are meant to be  called for the values they return, not
for side-effects.

The function ~remove~ takes an object and a list and returns a /new/ list
containing everything but that object.

#+begin_example
> (setf lst ’(c a r a t))
(C A R A T)
> (remove ’a lst)
(C R T)
#+end_example

The origin list is untouched afterwards:

: > lst
: (C A R A T)

So what  if you really do  want to remove something  from a list? In  Lisp, you
generally do such things  by passing the list as an  argument to some function,
and using ~setf~ with  the return value.  To remove all the =a=  s from a list,
we say:

: (setf x (remove ’a x))

Functional programming means avoiding ~setf~ and things like it.

One  of the  most important  advantages of  functional programming  is that  it
allows /interactive  testing/.  In  purely functional code,  you can  test each
function as  you write it.   If it  returns the values  you expect, you  can be
condfident  that it  is correct.   You have  instant turnaround  when you  make
changes anywhere in a program.  And this instant turnaround enables a whole new
style of programming.

*** Iteration
#+cindex:iteration
When you want to  do something repeatedly, it is sometimes  more natural to use
iteration than  recursion.  A typical  case for  iteration is to  generate some
sort of table.  This function:

#+begin_src lisp
  (defun show-squares (start end)
    (do ((i start (+ i 1)))
        ((> i end) 'done)
      (format t "~A ~A~%" i (* i i))))
#+end_src

prints out the squares of the integers from ~start~ to ~end~.

**** do Macro

#+findex:do macro
The ~do~ macro is the fundamental iteration operator in Common Lisp.  Like
~let~, ~do~ can create variables, and the first argument is a list of variable
specifications.  Each element of this list can be of the form:

: (variable initial update)

where  /variable/ is  a symbol,  and  /initial/ and  /update/ are  expressions.
Initially,  each /variable/  will  be set  to the  value  of the  corresponding
/initial/; on each iteration  it will be set to the  value of the corresponding
/update/.  The ~do~  in ~show-squares~ creates just one variable,  ~i~.  On the
first iteration,  ~i~ will be  set to the value  of ~start~, and  on successive
iterations its value will be incremented by one.

The  second  argument  to  ~do~  should  be  a  list  containing  one  or  more
expressions.  The  first expression  is used to  test whether  iteration should
stop.  In  the cae above,  the test expression is  ~(> i end)~.   The remaining
expressions in this  list will be evaluated in order  when iteration stops, and
the value of the last will be returned as the value of the ~do~.

The remaining arguments  to ~do~ comprise the  body of the loop.   They will be
evaluated, in order,  on each iteration.  On each iteration,  the variables are
updated, then the termination test is  evaluated, and then (if the test failed)
the body is evaluated.

For comparison, here is a recursive version of ~show-squares~:

#+begin_src lisp
  (defun show-squares (i end)
    (if (> i end)
        'done
        (progn
          (format t "~A ~A~%" i (( i i)))
          (show-squares (+ i 1) end))))
#+end_src

The  only thing  new in  this  function is  ~progn~.   It takes  any number  of
expressions, evaluates them in order, and returns the value of the last.

#+findex:dolist macro
Common Lisp has simpler iteration operators for special cases.  To iterate
through the elements of a list, for example, you would use ~dolist~.  Here is a
function that returns the length of list:

#+begin_src lisp
  (defun our-length (lst)
    (let ((len 0))
      (dolist (obj lst)
        (setf len (+ len 1)))
      len))
#+end_src

Here, ~dolist~ takes an argument of the form =(variable expression)=, followed
by a body of expressions. The body will be evaluated with /variable/ bound to
successive elements of the list returned by /expression/.  The obvious
recursive version of this function would be:

#+begin_src lisp
  (defun our-length (lst)
    (if (null lst)
        0
        (+ (our-length (cdr lst)) 1)))
#+end_src

If the list is empty, its length is zero; otherwise it is the length of the cdr
plus  one.  This  version  of ~our-length~  is cleaner,  but  because it’s  not
tail-recursive, it won’t be as efficient.

*** Functions as Objects
#+cindex:function object
#+findex:function
In Lisp, functions  are regular objects, like symbols or  strings or lists.  If
we give  the name of  a function to ~function~,  it will return  the associated
object.  Like  ~quote~, ~function~ is a  special operator, se we  don’t have to
quote the argument:

: > (function +)
: #<Compiled-Function + 17BA4E>

Until now we have only dealt with objects that look the same when Lisp displays
them as when  we typed them in.   This convention does not  apply to functions.
Internally, a built-in function  like =+= is likely to be  a segment of machine
code.  A Common Lisp implementation may choose whatever external representation
it likes.

#+cindex:sharp-quote
Just as we can use =’= as an abbreviation for ~quote~, we can use =#’= as an
abbreviation for ~function~:

: > #’+
: #<Compiled-Function + 17BA4E>

This abbreviation is known as /shart-quote/.

#+findex:apply
Like  any other  kind  of object,  we  can pass  functions  as arguments.   One
function that takes a function as an  argument is ~apply~.  It takes a function
and a list of arguments for it, and returns the result of applying the function
to the arguments:

: > (apply #’+ ’(1 2 3))
: 6
: > (+ 1 2 3)
: 6

It can be given any number of arguments, so long as the last is a list:

: > (apply #’+ 1 2 ’(3 4 5))
: 15

#+findex:funcall
The function ~funcall~ does  the same thing but does not  need the arguments to
be packaged in a list:

: > (funcall #’+ 1 2 3)
: 6

#+cindex:lambda expression
The ~defun~ macro creates a function and  gives it a name.  But functions don’t
have to have names, and we don’t need  ~defun~ to define them.  We can refer to
functions literally.  To refer literally to  a function, we use what’s called a
/lambda  expression/.  A  lambda expression  is  a list  containing the  symbol
~lambda~, followed  by a list  of parameters, followed by  a /body/ of  zero or
more expressions.

Here is a lambda expression representing  a function that takes two numbers and
returns their sum:

#+begin_src lisp
  (lambda (x y)
    (+ x y))
#+end_src

Like an ordinary function name, a lambda expression can be the first element of
a function call,

: > ((lambda (x) (+ x 100)) 1)
: 101

and by affixing a sharp-quote to  a lambda expression, we get the corresponding
function,

: > (funcall #’(lambda (x) (+ x 100))
:            1)
: 101

*** Types
In many languages, variables are what have  types, and you can’t use a variable
without specifying its type.  In Common Lisp, values have types, not variables.
Every object has  a label attached to it, identifying  its type.  This approach
is called /manifest typing/.  You don’t  have to declare the types of variables
because any variable can hold objects of any type.

Type declarations are possible, and discussed in Section 13.3.

The built-in Common Lisp types form a hierarchy of subtypes and supertypes.  An
object always has more than one type.  For example, the number 27 is of type:
- fixnum
- integer
- rational
- real
- number
- atom
- t,

in order of increasing generality.  The type =t= is the supertype of all types,
so everything is of type =t=.

The function ~typep~ takes an object and  a type specifier, and returns true if
the object is of that type.

: > (typep 27 ’integer)
: T
* Scheme
- [[https://schemers.org][Schemers.org]]
- [[http://www.scheme.dk/planet/][Planet Scheme]]

- [[https://wiki.c2.com/?SchemeLanguage]]

- [[https://icem.folkwang-uni.de/~finnendahl/cm_kurse/doc/schintro/schintro_toc.html][An Introduction to Scheme and its Implementation]]

- [[https://icem.folkwang-uni.de/~finnendahl/cm_kurse/doc/t-y-scheme/t-y-scheme.html][Teach Yourself Scheme in Fixnum Days]]

Scheme is a  member of the Lisp  family of languages. Scheme  was introduced in
1975  by Gerald  J. Sussman  and Guy  L.  Steele Jr..  Scheme is  defined in  a
document called  The Revised^5  Report on the  Algorithmic Language  Scheme, or
R5RS for short. A newer report, R6RS, was released in 2007, but this report has
attracted considerable controversy, and a number of Scheme implementations have
chosen not  to be compliant  with it. Yet another  report was released  in 2013
("R7RS"), that was less ambitious than R6RS and more minimal.

Even though Scheme is consciously minimalist,  it is recognized that a language
must be more than a minimal core in order to be useful. Accordingly, the Scheme
community uses a  process known as `Scheme Requests  For Implementation' (SRFI,
pronounced `SUR-fee') to define new  language features. A typical Scheme system
therefore complies  with one  of the  Scheme reports  plus some  or all  of the
accepted SRFIs.

Scheme is a  statically scoped and properly tail-recursive dialect  of the Lisp
programming language invented  by Guy Lewis Steele Jr. and  Gerald Jay Sussman.
It was  designed to have  an exceptionally clear  and simple semantics  and few
different ways  to form expressions.  A wide variety of  programming paradigms,
including imperative,  functional, and message passing  styles, find convenient
expression in Scheme.

It was the first dialect of Lisp to fully support:

- lexical scoping
- first-class procedures
- continuations


In its earliest  form it was a very small  language intended primarily
for research  and teaching. Scheme  is now a  complete general-purpose
programming language, though  it still derives its power  from a small
set of key concepts.

There are two standards for Scheme: an official standard with IEEE and
a de facto one, often called  "RnRS", short for the Revised^nth Report
on  the  Algorithmic  Language  Scheme.  In  colloquial  use,  "Scheme
standard" usually refers to the latter.

** What are some differences between Scheme and Common Lisp?
- http://community.schemewiki.org/?scheme-faq-general


Scheme  is a  dialect of  Lisp that  stresses conceptual  elegance and
simplicity.  It  is  much  smaller  than  Common  Lisp;  the  language
specification is about  50 pages, compared to Common  Lisp's 1300 page
draft standard.  Advocates of  Scheme often find  it amusing  that the
entire  Scheme standard  is shorter  than  the index  to Guy  Steele's
"Common Lisp: the Language, 2nd  Edition". Unlike the Scheme standard,
the Common Lisp  standard has a large library of  utility functions, a
standard   object-oriented   programming   facility  (CLOS),   and   a
sophisticated condition handling system.

#+begin_quote
"Some people prefer to teach Scheme in introductory courses because it
is so  much smaller  than Common  Lisp. But one  can easily  teach the
subset of Common  Lisp that is equivalent to Scheme,  so language size
isn't really  an issue  for beginners. A  more compelling  argument is
that there is a certain style of applicative programming, making heavy
use  of lexical  closures, that  can  be expressed  more elegantly  in
Scheme syntax. But there are also  areas where Common Lisp is superior
to Scheme,  such as its support  for user defined macros,  its elegant
unification of lists and vectors into a sequence datatype, and its use
of keyword  arguments to  greatly extend the  utility of  the sequence
functions. The combination of tremendous power, extensive manufacturer
support,  and a  built-in  object-oriented  programming facility  make
Common  Lisp   the  only  industrial  strength   Lisp.  Although  this
book[fn:8] does emphasize a  side-effect-free, applicative approach to
programming with which Scheme afficionados will feel quite at home, it
does so in purely Common Lisp style."
#+end_quote
- https://wiki.c2.com/?CommonLispaGentleIntroductionToSymbolicComputation


#+texinfo: @heading Namespaces

#+attr_texinfo: :author Peter Seibel in Practical Common Lisp
#+begin_quote
In Common Lisp  a symbol can name both  an operator---function, macro,
or  special  operator---and a  variable.  This  is  one of  the  major
differences  between  Common  Lisp   and  Scheme.  The  difference  is
sometimes described as  Common Lisp being a Lisp-2 vs.  Scheme being a
Lisp-1---a Lisp-2  has two namespaces,  one for operators and  one for
variables, but  a Lisp-1  uses a single  namespace. Both  choices have
advantages, and partisans can debate endlessly which is better.
#+end_quote

#+texinfo: @heading The False Value

#+attr_texinfo: :author Peter Seibel in Practical Common Lisp
#+begin_quote
Not all Lisps handle boolean values  the same way. Another of the many
subtle differences upon which a good  Common Lisp vs. Scheme flame war
can rage  for days  is Scheme's  use of a  distinct false  value =#f=,
which isn't  the same value  as either the  symbol =nil= or  the empty
list, which are also distinct from each other.
#+end_quote

** Standardizations of Scheme
Scheme has been standardized both formally and informally.

The two dialects  in which most major  Lisp programs of the  1970s were written
are MacLisp  (Moon 1978; Pitman  1983), developed at  the MIT Project  MAC, and
Interlisp (Teitelman 1974),  developed at Bolt Beranek and Newman  Inc. and the
Xerox  Palo  Alto   Research  Center.  Portable  Standard   Lisp  (Hearn  1969;
Griss 1981) was a Lisp dialect designed to be easily portable between different
machines. MacLisp  spawned a number of  subdialects, such as Franz  Lisp, which
was developed at  the University of California at Berkeley,  and Zetalisp (Moon
1981),  which was  based on  a special-purpose  processor designed  at the  MIT
Artificial  Intelligence Laboratory  to  run Lisp  very  efficiently. The  Lisp
dialect used in this book, called Scheme (Steele 1975), was invented in 1975 by
Guy Lewis Steele Jr. and Gerald  Jay Sussman of the MIT Artificial Intelligence
Laboratory and later reimplemented for  instructional use at MIT. Scheme became
an IEEE  standard in 1990  (IEEE 1990). The  Common Lisp dialect  (Steele 1982,
Steele 1990) was  developed by the Lisp community to  combine features from the
earlier Lisp  dialects to  make an  industrial standard  for Lisp.  Common Lisp
became an ANSI standard in 1994 (ANSI 1994).
- https://mitpress.mit.edu/sites/default/files/sicp/full-text/book/book-Z-H-9.html

*** IEEE Standard for the Scheme Programming Language
describes the formal ANSI/IEEE Standard for Scheme.

*** Revised Reports on the Algorithmic Language Scheme
The Revised6 Report on the Algorithmic Language Scheme

- [[http://people.csail.mit.edu/jaffer/r3rs_toc.html][R3RS]]

  LaTeX has changed  with time; it no longer works  from R3RS and R4RS
  source. For that  reason, this page doesn't have  links to r3rs.pdf,
  r3rs.ps, and r3rs.dvi. They could be produced by an old installation
  of LaTeX, or by modification of r3rs.tar.

  - [[http://groups.csail.mit.edu/mac/ftpdir/scm/r3rs.info.tar.gz][R3RS INFO]]
  - [[http://groups.csail.mit.edu/mac/ftpdir/scm/r3rs.txi][R3RS TEXINFO]]
  - [[http://groups.csail.mit.edu/mac/ftpdir/scheme-reports/r3rs.tar][R3RS LaTeX]]

- [[http://people.csail.mit.edu/jaffer/r4rs_toc.html][R4RS]]

  - [[http://people.csail.mit.edu/jaffer/r4rs.pdf][R4RS PDF]]
  - [[http://groups.csail.mit.edu/mac/ftpdir/scm/r4rs.info.tar.gz][R4RS INFO]]
  - [[http://groups.csail.mit.edu/mac/ftpdir/scm/r4rs.txi][R4RS TEXINFO]]
  - [[http://groups.csail.mit.edu/mac/ftpdir/scheme-reports/r4rs.tar.gz][R4RS LaTeX]]

- [[http://people.csail.mit.edu/jaffer/r5rs_toc.html][R5RS]]

  - [[http://people.csail.mit.edu/jaffer/r5rs.pdf][R5RS PDF]]
  - [[http://groups.csail.mit.edu/mac/ftpdir/scm/r5rs.info.tar.gz][R5RS INFO]]
  - [[http://groups.csail.mit.edu/mac/ftpdir/scm/r5rs.txi][R5RS TEXINFO]]
  - [[http://groups.csail.mit.edu/mac/ftpdir/scheme-reports/r5rs.tar.gz][R5RS LaTeX]]

- [[http://www.r6rs.org][R6RS]]

= [[https://small.r7rs.org/attachment/r7rs.pdf][R7RS]]

document an evolving informal standard that most implementations
support.

- http://people.csail.mit.edu/jaffer/Scheme

**** The Revised6 Report on the Algorithmic Language Scheme
http://www.r6rs.org

** The Scheme Family
   :PROPERTIES:
   :author:   Paul McJones
   :last-modified: 2020-04-20 10:10
   :END:
- http://www.softwarepreservation.org/projects/LISP/scheme_family/

*** Creation of Scheme
- [[ftp://publications.ai.mit.edu/ai-publications/pdf/AIM-349.pdf][SCHEME: An Interpreter for Extended Lambda Calculus]]
  - Gerald Jay Sussman and Guy Lewis Steele, Jr.
  - AI Memo No. 349, Artificial Intelligence Laboratory, Massachusetts
    Institute of Technology, December 1975
- [[http://www.softwarepreservation.org/projects/LISP/scheme_family/][LAMBDA: The Ultimate Imperative]]
  - Guy Lewis Steele, Jr. and Gerald Jay Sussman
  - AI Memo No. 353, Artificial Intelligence Laboratory, Massachusetts
    Institute of Technology, March 10, 1976
- [[ftp://publications.ai.mit.edu/ai-publications/pdf/AIM-379.pdf][LAMBDA: The Ultimate Declarative]]
  - Guy Lewis Steele, Jr.
  - AI Memo No. 379, Artificial Intelligence Laboratory, Massachusetts
    Institute of Technology, November 1976
- [[ftp://publications.ai.mit.edu/ai-publications/pdf/AIM-443.pdf][Debunking the "Expensive Procedure Call" Myth; or, Procedure Call]]
  Implementations Considered Harmful; or, LAMBDA: The Ultimate GOTO]]
  - Guy Lewis Steele, Jr.
  - AI Memo No. 443, Artificial Intelligence Laboratory, Massachusetts
    Institute of Technology, October 1977
- [[ftp://publications.ai.mit.edu/ai-publications/pdf/AIM-452.pdf][The Revised Report on SCHEME: A Dialect of LISP]]
  - Guy Lewis Steele, Jr. and Gerald Jay Sussman
  - AI Memo No. 452, Artificial Intelligence Laboratory, Massachusetts
    Institute of Technology, January 1978
- [[ftp://publications.ai.mit.edu/ai-publications/pdf/AIM-453.pdf][The Art of the Interpreter; or, The Modularity Complex (Parts Zero, One, and Two)]]
  - Guy Lewis Steele, Jr. and Gerald Jay Sussman
  - AI Memo No. 453, Artificial Intelligence Laboratory, Massachusetts
    Institute of Technology, May 1978
- [[ftp://publications.ai.mit.edu/ai-publications/pdf/AITR-474.pdf][RABBIT: A Compiler for SCHEME (A Study in Compiler Optimization)]]
  - Guy Lewis Steele, Jr.
  - Technical Report 474, Artificial Intelligence Laboratory, Massachusetts
    Institute of Technology, May 1978
- [[ftp://publications.ai.mit.edu/ai-publications/pdf/AIM-514.pdf][Design of LISP-based Processors; or, SCHEME: A Dielectric LISP, or Finite Memories Considered Harmful; or, LAMBDA: The Ultimate Opcode.]]
  - Guy Lewis Steele, Jr. and Gerald Jay Sussman
  - AI Memo No. 514, Artificial Intelligence Laboratory, Massachusetts
    Institute of Technology, March 1979
- [[ftp://publications.ai.mit.edu/ai-publications/pdf/AIM-848.pdf][The Revised Revised Report on Scheme; or, An UnCommon Lisp]]
  - William Clinger, editor
  - AI Memo No. 848, Artificial Intelligence Laboratory, Massachusetts
    Institute of Technology, August 1985
- [[https://dl.acm.org/doi/10.1145/15042.15043][Revised3 Report on the Algorithmic Language Scheme]]
  - Jonathan Rees and William Clinger, editors
  - SIGPLAN Notices Volume 21, Number 12, December 1986
- [[https://legacy.cs.indiana.edu/ftp/scheme-repository/][Revised4 Report on the Algorithmic Language Scheme]]
  - William Clinger and Jonathan Rees, editors
  - ACM Lisp Pointers Volume 4, Number 3, July 1991
- [[https://web.archive.org/web/20160322115236/http://cs.au.dk/~hosc/local/HOSC-11-1-pp7-105.pdf][Revised5 Report on the Algorithmic Language Scheme]]
  - https://schemers.org/Documents/Standards/R5RS/
  - Richard Kelsey, William Clinger, and Jonathan Rees, editors
  - Higher-Order and Symbolic Computation, Volume 11, Number 1, August 1998
- [[http://www.r6rs.org][The Revised6 Report on the Algorithmic Language Scheme]]
  - Michael Sperber et al.
  - September 26, 2007
- [[http://www.cs.cmu.edu/afs/cs/project/ai-repository/ai/lang/scheme/impl/rabbit/0.html][Scheme compiler written in Lisp, 1978]]
  - Guy L. Steele, Jr.
- [[http://www.cs.cmu.edu/afs/cs/project/ai-repository/ai/lang/scheme/doc/intro/intro.txt][The Scheme programming language]]
  - Ken Dickey
- [[http://www.cs.cmu.edu/afs/cs.cmu.edu/project/ai-repository/ai/lang/scheme/0.html][CMU Scheme Repository]]
  - [[http://www.cs.cmu.edu/afs/cs/project/ai-repository/ai/lang/scheme/bookcode/0.html][Machine readable parts of various Scheme books]]
  - [[http://www.cs.cmu.edu/afs/cs/project/ai-repository/ai/lang/scheme/code/0.html][Scheme code for benchmarking, research, education, and fun]]
  - [[http://www.cs.cmu.edu/afs/cs/project/ai-repository/ai/lang/scheme/doc/0.html][Documentation, including standards and proposals]]
  - [[http://www.cs.cmu.edu/afs/cs/project/ai-repository/ai/lang/scheme/edu/0.html][Educational Materials for Teaching/Learning Scheme]]
  - [[http://www.cs.cmu.edu/afs/cs/project/ai-repository/ai/lang/scheme/faq/0.html][Scheme FAQ: Frequently Asked Questions (FAQ) posting for comp.lang.scheme newsgroup]]
  - [[http://www.cs.cmu.edu/afs/cs/project/ai-repository/ai/lang/scheme/doc/macros/0.html][Proposals and implementations for macros in Scheme.]]
  - [[http://www.cs.cmu.edu/afs/cs/project/ai-repository/ai/lang/scheme/oop/0.html][OOP: Code related to object-oriented programming.]]
  - [[http://www.cs.cmu.edu/afs/cs/project/ai-repository/ai/lang/scheme/util/0.html][Utilities for programming in Scheme.]]
  - [[http://www.cs.cmu.edu/afs/cs/project/ai-repository/ai/lang/scheme/doc/bib/0.html][This directory contains several bibliographies related to work on Scheme.]]
  - [[http://www.cs.cmu.edu/afs/cs/project/ai-repository/ai/lang/scheme/doc/notes/0.html][Summaries and interesting notes about Scheme-related stuff.]]
  - [[http://www.cs.cmu.edu/afs/cs/project/ai-repository/ai/lang/scheme/impl/0.html][Free/Shareware Scheme implementations]]

** Resources on Scheme
*** [[schemers.org][schemers.org]]
The main resource for all things Scheme


This is a collection of resources for the Scheme programming language.
It was initiated by the PLT group at Rice University.
*** [[http://www.scheme.dk/planet/][Planet Scheme]]
Planet Scheme is a meta blog. Blog posts on Scheme are collected here.

*** Scheme FAQ
- http://community.schemewiki.org/?scheme-faq-general

*** RnRS
- http://people.csail.mit.edu/jaffer/Scheme

*** MIT Scheme
- http://groups.csail.mit.edu/mac/projects/scheme/

*** The Scheme Programming Language Third Edition 2003
- https://www.scheme.com/tspl3/
  - by R. Kent Dybvig (3rd ed. 2003)

This book is intended to provide an introduction to the Scheme
programming language but not an introduction to programming in
general. The reader is expected to have had some experience
programming and to be familiar with terms commonly associated with
computers and programming languages.

The author recommends that readers unfamiliar with Scheme or Lisp also
read _The Little Schemer_ to become familiar with the concepts of
- list processing and
- recursion.


This book covers everything in both standards.

This book is organized into nine chapters, plus appendices.

1. Chapter 1 describes the properties and features of Scheme that make
   it a useful and enjoyable language to use. Also describes Scheme's
   notational conventions and the typographical conventions employed
   in this book.

2. Chapter 2 is an introduction to Scheme programming for the novice
   Scheme programmer that leads the reader through a series of
   examples, beginning with simple Scheme expressions and working
   toward progressively more difficult ones.

3. Chapter 3 continues the introduction but covers more advanced
   features and concepts.

4. Chapter 4 describes operations for creating procedures and variable
   bindings.

5. Chapter 5, program control operations

6. Chapter 6, operations on the various object types (including lists,
   numbers, and strings);

7. Chapter 7, input and output operations;

8. Chapter 8, syntactic extension.

9. Chapter 9 contains a collection of complete example programs or
   packages, each with a short overview, some examples of its use, the
   implementation with brief explanation, and a set of exercises for
   further work. Each of these programs demonstrates a particular set
   of features, and together they illustrate an appropriate style for
   programming in Scheme.

10. Bibliography

11. Answers

12. Formal syntax

13. A concise summary of Scheme syntactic forms and procedures

14. Index
*** The Scheme Programming Language Fourth Edition 2009
https://www.scheme.com/tspl4/

*** The Little Schemer
Daniel P. Friedman and Matthias Felleisen. The Little Schemer, fourth
edition. MIT Press, 1996.

- [[https://pdfs.semanticscholar.org/35d0/d5275a8390c351ce98fbdc2ad37d210ba63b.pdf][The Little Schemer (4th Edition)]]

*** Simply Scheme---Introducing Computer Science 2nd Ed
- https://people.eecs.berkeley.edu/~bh/ss-toc2.html

*** PVTS
- http://davidpilo.com/pvts/


Visualize lists, pointers  and function calls in your code.  PVTS is a
visual interpreter for the Scheme functional programming languages.

*** Scheme-FAQ
- http://community.schemewiki.org/?scheme-faq

*** Structure and Interpretation of Computer Programs---SICP
- [[https://sarabander.github.io/sicp/][SICP HTML Online Version]]
- [[https://mitpress.mit.edu/sites/default/files/sicp/full-text/book/book.html][SICP Online Textbook]]
- [[https://mitpress.mit.edu/sites/default/files/sicp/code/index.html][SICP Code from the Book]]
- [[https://mitpress.mit.edu/sites/default/files/sicp/index.html][SICP Companion Website]]
- [[https://github.com/sarabander/sicp-pdf][SICP LaTeX and Texinfo Sources and PDF]]
- [[https://github.com/sarabander/sicp][SICP in HTML and EPUB3 Formats]]
- [[https://www.neilvandyke.org/sicp-texi/][SICP in Texinfo Format]]
- [[https://github.com/sarabander/p2pu-sicp][SICP Solutions]]
- [[http://zv.github.io/sicp-chapter-1][SICP Solutions from zv]]
- [[https://github.com/ldct/isicp][Interactive SICP]]
- [[http://www.xuanji.li/isicp/][Interactive HTML SICP]]
- [[https://mitpress.mit.edu/sites/default/files/sicp/psets/index.html][SICP Sample Programming Assignments]]
- [[https://github.com/zv/SICP-guile][SICP in Guile & Emacs Lisp]]

*** 6.001 Structure and Interpretation of Computer Programs
- [[https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-001-structure-and-interpretation-of-computer-programs-spring-2005/video-lectures/][MIT with Abelson and Sussman]]
- [[https://www.youtube.com/watch?v=-J_xL4IGhJA&list=PLE18841CABEA24090][YouTube with Abelson and Sussman]]
- [[https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-001-structure-and-interpretation-of-computer-programs-spring-2005/][Spring 2005]]
- [[https://dspace.mit.edu/bitstream/handle/1721.1/35852/6-001Fall-2002/OcwWeb/Electrical-Engineering-and-Computer-Science/6-001Structure-and-Interpretation-of-Computer-ProgramsFall2002/CourseHome/index.htm][Fall 2002]]
- [[http://aduni.org/courses/sicp/][Ars Digita University Version]]
- [[https://see.stanford.edu/Course/CS107][Stanford CS 107 Programming Paradigms Spring 2008 Main Entry]]
- [[http://videolectures.net/stanfordcs107s08_programming_paradigms/][Stanford CS 107 Spring 2008 with Jerry Cain]]
- [[https://www.youtube.com/watch?v=Ps8jOj7diA0][Stanford CS 107 Spring 2008 YouTube Lectures]]

** Scheme Implementations
[[http://www.r6rs.org/implementations.html][R6RS Implementations]]

http://community.schemewiki.org/?category-implementations

*** List of Known Scheme Implementations
    :PROPERTIES:
    :last-modified: 2020-08-09 10:23:38
    :END:
- [[http://community.schemewiki.org/?scheme-faq-standards#implementations][What Scheme implementations are there?]]

  This  page holds  a list  of  known Scheme  implementations, in  alphabetical
  order.

*** Quick and Dirty List of Scheme Implementations
- [[http://community.schemewiki.org/?category-implementations][Here is a quick-and-dirty list of a very select number of Scheme implementations.]]


- Bigloo ::
  Compiles Scheme to C, JVM and .NET.
- Chez ::
  A very fast cross-platform native code compiler (commercial) along with a
  free interpreter.
- Chibi ::
  A very small library intended for use as an extension and scripting language
  in C programs.
- Chicken ::
  A Scheme->C compiler with a good FFI?.
- Cyclone ::
  A brand-new Scheme-to-C compiler that allows practical application
  development using R7RS Scheme.
- Elk ::
  A Scheme based extension language kit.
- Gambit ::
  Scheme->C compiler. Also compiles to Javascript and working on an universal
  backend (PHP, Python, Ruby, Asm).
- Gauche ::
  This wiki runs on it. A scripting language scheme interpreter with good
  Unicode support.
- Guile ::
  The GNU Scheme interpreter, designed to have good integration with C
  programs. A nice extension language.
- Ikarus ::
  R6RS Scheme incremental compiler to i32 and i64 native code.
- IronScheme ::
  R6RS Scheme for the .NET Framework.
- kali-scheme-revival ::
  A variant of Scheme48 for distributed computation.
- Kawa ::
  Runs on the JVM
- Larceny ::
  Is a simple and efficient R6RS runtime for scheme.
- LispMe ::
  R4RS Scheme, but for Palm Os
- Ocs ::
  An R5RS Scheme interpreter in OCaml.
- Pika-Scheme ::
  A new implementation currently in prerelease stage.
- PLT-Scheme ::
  PLT Scheme is an umbrella name for a family of implementations of the Scheme
  language - DrScheme, MzScheme, MrEd.
- Pocket-Scheme ::
  A scheme for WinCE based handhelds.
- RScheme ::
  Compiles to C, has Dylan-like OO features.
- Scheme48 ::
  The primary design goal was clarity and good design.
- Schoca ::
  A Scheme interpreter in Objective Caml.
- SCM ::
  Small and portable R5RS implementation. SLIB, by the same author, is nicelly
  integrated with SCM.
- SCSH ::
  The SCheme SHell, based on Scheme48. This adds a lot of very interesting
  facilities for POSIX system interfacing.
- SISC ::
  A Scheme interpreter in Java, making the whole Java library available to
  Scheme, and still being very fast (for an interpreter)
- SISCWeb ::
  The framework for creating web applications using the SISC interpreter.
- Stalin ::
  Scheme to C compiler
- STKlos ::
  A Scheme System with an Object System and TK integration
- T ::
  Is the name for an implementation and dialect of scheme
  - [[http://mumble.net/~jar/tproject/][T Project Web Site]]
  - [[http://web.archive.org/web/20070103020434/http://mumble.net/~campbell/t/t.html][T Revival Website]] (Last Updated Friday, 7th April, 2006)
  - T is a dialect of Scheme and its implementation. T originated from Yale. It
    is not compatible with R5RS.
- TinyScheme ::
  A lightweight Scheme interpreter
- Unlikely-Scheme ::
  An embeddable C++ implementation
- Ypsilon ::
  R6RS interpreter

*** Chez Scheme
 http://cisco.github.io/ChezScheme/

 Chez Scheme is both a programming language and an implementation of
 that language, with supporting tools and documentation. As a superset
 of the language described in the Revised6 Report on the Algorithmic
 Language Scheme (R6RS), Chez Scheme supports all standard features of
 Scheme, including first-class procedures, proper treatment of tail
 calls, continuations, user-defined records, libraries, exceptions, and
 hygienic macro expansion. Chez Scheme also includes extensive support
 for interfacing with C and other languages, support for multiple
 threads possibly running on multiple cores, non-blocking I/O, and many
 other features.

**** Chez Scheme User's Manual
 http://cisco.github.io/ChezScheme/csug9.5/csug.html

 Chez Scheme's additional language, run-time system, and programming
 environment features are described in the Chez Scheme User's Guide.

**** Open Source
 https://github.com/cisco/chezscheme
*** Guile Scheme
[[https://www.gnu.org/software/guile/][Guile]]

"Guile is  designed to  help programmers create  flexible applications
that  can be  extended by  users or  other programmers  with plug-ins,
modules, or scripts."

*** Chicken Scheme
- [[http://www.call-cc.org][Chicken Home]]
- [[http://wiki.call-cc.org/][Chicken Wiki]]
- [[http://api.call-cc.org/4/doc/][Search Chicken documentation]]

CHICKEN  Scheme  combines  an  optimising   compiler  with  a  reasonably  fast
interpreter.  It supports  almost  all of  R7RS and  the  important SRFIs.  The
compiler generates  portable C code  that supports tail  recursion, first-class
continuations  and  lightweight  threads,  and  the interface  to  and  from  C
libraries is  flexible, efficient,  and easy to  use. It runs  on Linux,  OS X,
Windows, many Unix flavours

CHICKEN is a compiler that translates Scheme source files into C, which in turn
can be fed to a C compiler  to generate a standalone executable. An interpreter
is also  available and can  be used as a  scripting environment or  for testing
programs  before  compilation. The  interpreter  allows  interactive use,  fast
prototyping, debugging, and scripting.

To invoke the CHICKEN interpreter, you use the ~csi~ command.

To run a script, add the following command header to the script file:
: #! /usr/local/bin/csi -script

The parameter ~command-line-arguments~ is set to  a list of the parameters that
were  passed to  the  Scheme  script. Scripts  can  be  compiled to  standalone
executables.

*** Gambit Scheme
- [[http://dynamo.iro.umontreal.ca/wiki/index.php/Main_Page][Gambit Home]]
- https://wiki.c2.com/?SchemeLanguage
- https://github.com/gambit/gambit/blob/master/INSTALL.txt

The  Gambit Scheme  system  is  a complete,  portable,  efficient and  reliable
implementation of the Scheme programming language.

*** MIT/GNU Scheme
- http://groups.csail.mit.edu/mac/projects/scheme/
- https://www.gnu.org/software/mit-scheme/
- [[https://www.gnu.org/software/mit-scheme/documentation/stable/mit-scheme-user/index.html][MIT/GNU Scheme 10.1.11]]
- [[http://www.cs.cmu.edu/afs/cs.cmu.edu/project/ai-repository/ai/lang/scheme/0.html][CMU Scheme Repository]]


MIT/GNU Scheme is a complete programming environment that runs on many unix
platforms and Windows.  It features a:

- interpreter
- native-code compiler
- rich runtime library
- powerful source-level debugger
- integrated Emacs-like editor

*** Kawa Scheme
[[https://www.gnu.org/software/kawa/][The Kawa Scheme Language]]
[[https://www.gnu.org/software/kawa/tutorial/index.html][Kawa Scheme Tutorial]]
[[https://gitlab.com/kashell/Kawa][Kawa on GitLab]]

Kawa is a general-purpose programming language that runs on the Java
platform.

- Runs on the Java platform, with no native code needed
- Extends the Scheme language, following the R7RS specification from 2013
- Programs run fast - roughly as fast as Java programs, and much faster than
  other “scripting languages”.
- Full, convenient, and efficient access to the huge set of Java libraries; you
  can access objects, methods, fields, and classes without run-time overhead.
- Start-up times are fast.
- Scripts are simple Kawa source files that can run as an application or
  command.
- You can embed Kawa as a scripting language for Java applications.
- Deployment is easy and flexible. You just need the Kawa jar file.
- Kawa provides the usual read-eval-print loop
- Kawa has builtin pretty-printer support, and fancy formatting.
- Kawa supports class-definition facilities, and separately-compiled modules.
- You can allocate  and initialize objects with a compact  “builder” syntax. It
  works out-of-the-box (with no run-time overhead)
- JavaFX programming is simpler.
- Flexible shell-like functionality, including process literals.
- Web page  scripts are  easy to  write and  install with  self-configuring web
  servers, optionally using servlets and XML literals.
- Arrays and sequences have a lot of flexibility
- Many useful features for mathematics and numerics
  - infinite-precision rational numbers and complex numbers.
  - Compile-time optimization of arithmetic with the use of type declarations
    and inference.
  - A quantity is a real number with a unit, such as 3cm.
  - Quaternions are a 4-dimensional generalization of complex numbers.
  - Unsigned primitive integer types (ubyte, ushort, uint, ulong) are
    implemented efficiently without object allocation.
- A lazy value wraps an expression which is evaluated only when it is needed.
- Kawa provides a framework for implementing other programming languages,
  - comes with incomplete support for CommonLisp, Emacs Lisp, and EcmaScript,
    and XQuery.

**** Installing Kawa Scheme
These instructions install the pre-compiled binary distribution. The
pre-compiled release is at:

- ftp://ftp.gnu.org/pub/gnu/kawa/kawa-3.1.1.zip


The binary release  comes as a ~.zip~  archive that includes Kawa  itself (as a
~.jar~  file  ~$KAWA_HOME/lib/kawa.jar~),  some third-party  helper  libraries,
~kawa~ command scripts (for GNU/Linux/Unix/MacOS or Windows), and documentation
(basically  this  manual).  The  ~.zip~  file unzips  into  a  directory  named
~kawa-3.1.1~ with ~lib~, ~bin~, and ~doc~ sub-directories. Place this directory
somewhere  suitable  and name  the  location  =KAWA_HOME=. The  binary  release
requires  Java 8  or later.  If you  want to  use Kawa  as part  of some  other
application, you just need the =$KAWA_HOME/lib/kawa.jar=.

**** Running Kawa Scheme
To  run a  Kawa  script file  or  the Kawa  read-eval-print-loop  run the  Kawa
application. There are various way to do  so. The recommended way is to execute
the $KAWA_HOME/bin/kawa  Bash shell  script. The script  assumes that  either a
suitable ~java~  program is in  your PATH;  or the =JAVA=  environment variable
names  a   suitable  ~java~   executable;  or  that   =JAVA_HOME=  is   set  so
=$JAVA_HOME/bin/java= is suitable.

Add the following to a startup script:
: export KAWA_HOME='/usr/local/kawa/kawa-3.1.1'
: alias kawaj='java -jar $KAWA_HOME/lib/kawa.jar'

The alias ~kawaj~ runs the ~kawa.jar~ directly, producing a repl.

Add the kawa ~bin~ directory to your =PATH= variable:
: export $KAWA_HOME/bin

To open the documentation manual as an html file, type:
: kawa --brownse-manual

**** Running Kawa Command Scripts
Use the following header command in your scripts:
: #!/usr/bin/env kawa

then make the program executable with:
: chmod +x <script>

and run it with:
: ./<script> <args...>

**** Sending Options to Kawa in a Command Script
If you need to  specify extra arguments to ~kawa~, you  can run arbitrary shell
commands inside Scheme block comments.

#+begin_src sh
#!/bin/sh
#|
exec kawa out:base=16 out:radix=yes "$0" "$*"
|#
(format #t "The command-line is:~{ ~w~}.~%" (command-line))
(display "It has ")
(display (apply + (map string-length (command-line))))
(display " characters.")
(newline)
#+end_src

The trick is to hide the shell code from Kawa inside a =#|...|#= block-comment.
The start of the block comment is a  line starting with a =#=, so it is treated
as a comment by  the shell. You can then invoke ~kawa~  (or ~java~ directly) as
you prefer,  setting up  class-path and  jars as  needed, and  passing whatever
arguments you want. You need to make  sure the shell finishes before it reaches
the end of the block comment or the Scheme code, which would confuse it.

Using comments this way  has the advantage that you have  the option of running
the script “manually” if you prefer:

#+begin_example
$ kawa /tmp/scm-echo out:base=8 "x y"
The command-line is: "/tmp/scm-echo" "out:base=8" "x y".
It has 26 characters.
#+end_example

**** Kawa Implementation of Asymmetric Encryption Keys Via KeyPairGenerator
- http://rdsathene.org/scheme/docs/kawa-example-exec-1.html


=AsymmetricKeyMaker=  is an  excellent example  for  several reasons.  It is  a
command line  program takes user  input and returns  a result. It  utilizes the
Java exception  system and gives us  an opportunity to deal  with both abstract
and concrete classes.

- Asymmetric Encryption Keys With the KeyPairGenerator
  - January 16, 2004
  - 'Core Java Technologies Tech Tips' article
  - https://www.java-tips.org/java-se-tips-100019/39-javax-crypto/915-asymmetric-encryption-keys-with-the-keypairgenerator.html


Example of standalone  executable program duplicating the  functionality of the
January  16,  2004  'Core  Java Technologies  Tech  Tips'  article  'Asymmetric
Encryption Keys With the KeyPairGenerator'. This example assumes the reader has
obtained their  own copy of  that document and will  reference it and  the Java
source for our  purpose of reproducing the functionality. It  is not reproduced
here due  to the  lengthy and confusing  amount of copyright  and terms  of use
information  Sun uses  on  all  their documentation.  The  Sun  source for  the
=AsymmetricKeyMaker= program  is 25 lines, so  we can reference things  by line
number.

#+begin_src lisp
; -*-scheme-*- Copyright © Robert D. Skeels 02/07/2004 <athene@earthlink.net>

(module-name <AsymmetricKeyMaker>)

(define-namespace key-pair-generator "class:java.security.KeyPairGenerator")

(define gen-keys
  (lambda (algorithm)
    (let* ((our-kpg (key-pair-generator:getInstance algorithm))
           (our-key-pair (invoke our-kpg 'generateKeyPair))
           (writeln (lambda (args) (display args) (newline))))
           (writeln (invoke our-key-pair 'getPublic))
           (writeln (invoke our-key-pair 'getPrivate)))))

(define try-gen-keys
  (lambda (algorithm)
    (try-catch (gen-keys algorithm)
        (ex <java.security.NoSuchAlgorithmException>
          (begin
          (display  "usage: java AsymmetricKeyMaker <RSA | DSA>")
          (newline))))))

(if (> (vector-length command-line-arguments) 0)
  (try-gen-keys (vector-ref command-line-arguments 0)))
#+end_src

#+begin_src java
KeyPairGenerator generator =
                 KeyPairGenerator.getInstance("RSA");
 generator.initialize(1024);
 KeyPair keyPair = generator.generateKeyPair();

import java.security.KeyPairGenerator;
 import java.security.NoSuchAlgorithmException;
 import java.security.KeyPair;

 public class AsymmetricKeyMaker {

    public static void main(String[] args) {
      String algorithm = "";
      if (args.length == 1) algorithm = args[0];

      try {
        KeyPair keyPair = KeyPairGenerator
                             .getInstance(algorithm)
                             .generateKeyPair();

        System.out.println(keyPair.getPublic());
        System.out.println(keyPair.getPrivate());

      } catch (NoSuchAlgorithmException e) {
        System.err.println(
          "usage: java AsymmetricKeyMaker <RSA | DSA>");
      }

    }
 }
#+end_src

**** JEmacs---The Java/Scheme-based Emacs
- [[http://jemacs.sourceforge.net][JEmacs Home]]
- http://jemacs.sourceforge.net/JEmacs-FSM.html
- Per Bothner


JEmacs is  a re-implementation  of the  Emacs programmable  text editor.  It is
written in Java,  and currently uses the  Swing GUI toolkit. Emacs  is based on
the extension language Emacs Lisp (Elisp), which is a dynamically-scoped member
of the Lisp family. JEmacs supports Elisp, as well as the use of Scheme, a more
modern  statically-scoped Lisp  dialect. Both  languages get  compiled to  Java
bytecodes,  either  in  advance  or  on-the-fly,  using  the  Kawa  compilation
framework.

*** SCM Scheme
- [[http://people.csail.mit.edu/jaffer/SCM.html][The SCM Implementation of Scheme]] ::

  latest release scm-5f3 2020-02-15 by Aubrey Jaffer


SCM is  a Scheme implementation  conforming to Revised5 Report  on the
Algorithmic Language Scheme and the  IEEE P1178 specification*. Scm is
written in C and runs under Amiga, Atari-ST, GNU/Linux, MacOS, MS-DOS,
MS-Vista,  MS-Windows, OS/2,  NOS/VE,  Unicos, VMS,  Unix and  similar
systems.

SCM includes  Hobbit, the  Scheme-to-C compiler originally  written by
Tanel  Tammet.  Hobbit  generates  C   files  whose  binaries  can  be
dynamically or statically  linked with a SCM  executable. SCM includes
linkable  modules   for  sequence-comparison,  arrays,   records,  and
byte-number  conversions;  and  modules  for POSIX  system  calls  and
network-sockets, readline, ncurses, and Xlib.

SCM requires the [[http://people.csail.mit.edu/jaffer/SLIB][SLIB Scheme Library]].

*** Scheme 48
- https://www.s48.org


Scheme 48 is an implementation of Scheme written by Richard Kelsey and
Jonathan Rees. It is based on  a byte-code interpreter and is designed
to be used  as a testbed for experiments  in implementation techniques
and as an expository tool.
*** Scsh
- https://scsh.net


Scsh is an  open-source Unix shell embedded within  Scheme, running on
all major  Unix platforms including  AIX, Cygwin, Linux,  FreeBSD, GNU
Hurd, HP-UX, Irix, Mac OS X, Solaris, and some others.

Scsh is  a variant  of Scheme  48 (an  R5RS compliant  new-tech Scheme
system)  Scsh  is  designed  for  writing  real-life  standalone  Unix
programs and  shell scripts. Scsh  spans a wide range  of application,
from “script”  applications usually handled  with perl or sh,  to more
standard systems applications usually written in C.

Scsh has two main components:  a process notation for running programs
and  setting up  pipelines and  redirections, and  a complete  syscall
library for low-level  access to the operating system,  i.e. to POSIX,
the least common  denominator of more or less all  Unices, plus widely
supported extensions such as symbolic links and BSD sockets. Moreover,
scsh provides  an awk  facility for pattern-directed  computation over
streams of  records, a  rich facility for  matching regular-expression
patterns  in  strings,   event-based  interrupt  handling,  user-level
threads, a  futuristic module system, and  an interactive environment.
Scsh  comes with  extensive documentation  describing these  and other
features.
*** STk
- http://kaolin.unice.fr/STk/


STk  is  a free  R4RS  Scheme  interpreter  which  can access  the  Tk
graphical  package. Concretely,  it can  be  seen as  the standard  Tk
package  where Tcl  has been  replaced  by a  Scheme interpreter.  STk
embeds  also an  efficient CLOS  like object  oriented system,  called
STklos, which provides:

- multiple inheritance,
- generic functions,
- multi-methods,
- a MOP (Meta Object Protocol)

** Scheme Programs
*** SLIB
- http://people.csail.mit.edu/jaffer/SLIB


The SLIB Portable Scheme Library.

SLIB is  a portable  library for the  programming language  Scheme. It
provides a platform independent framework for using packages of Scheme
procedures and  syntax. As distributed, SLIB  contains useful packages
for  all R4RS  and R5RS  Scheme  implementations. Its  catalog can  be
transparently  extended  to  accomodate   packages,  both  source  and
compiled, specific to a site, implementation, user, or directory.

*** SLIB-PSD Portable Scheme Debugger
- https://github.com/perttikellomaki/psd

*** Color-Scheme
- http://people.csail.mit.edu/jaffer/Color/Color-Scheme


SLIB's  color  package  provides  methods  to  specify,  compute,  and
transform colors in the color spaces...

*** BRL - the Beautiful Report Language
- http://brl.sourceforge.net


a framework for building server-side web applications.

*** The Festival Speech Synthesis System
- http://www.cstr.ed.ac.uk/projects/festival/


A general multi-lingual speech synthesis system with a Scheme-based command interpreter.

*** GIMP
- https://www.gimp.org

*** GnoTime
- http://gttr.sourceforge.net


GTT is  a to-do list/diary/journal tool  that can track the  amount of
time spent on projects, and,  among other things, generate reports and
invoices based on that time.

*** GNUCash
- https://www.gnucash.org

*** Guile
- https://www.gnu.org/software/guile/guile.html

*** Impromptu
- http://impromptu.moso.com.au

*** JACAL
- http://people.csail.mit.edu/jaffer/JACAL.html


JACAL is an interactive symbolic mathematics program.

** Scheme Libraries
*** The SLIB Portable Scheme Library
- http://people.csail.mit.edu/jaffer/SLIB.html
- [[http://groups.csail.mit.edu/mac/ftpdir/scm/slib-3b6.zip][SLIB ZIP Source]]
- Released 2020-02-16


SLIB is a portable Scheme library providing compatibiliy and utility functions
for all standard Scheme implementations.

SLIB supports
- Bigloo,
- Chez,
- ELK-3.0,
- Gambit-4.0,
- Gauche-0.9,
- Guile,
- JScheme,
- MacScheme,
- MITScheme,
- Pocket-Scheme,
- RScheme,
- S7,
- scheme->C,
- Scheme48,
- SCM,
- SCM-Mac,
- scsh,
- SISC,
- Stk,
- T3.1,
- umb-scheme, and
- VSCM.


SLIB-PSD is a portable debugger for Scheme (requires emacs editor):
- [[http://groups.csail.mit.edu/mac/ftpdir/scm/slib-psd1-3.tar.gz][SLIB-PSD SOURCE]]
- [[https://github.com/perttikellomaki/psd][SLIB on GitHub]]

**** SLIB Installation
- http://people.csail.mit.edu/jaffer/slib/Installation.html

**** SLIB Documentation
- http://people.csail.mit.edu/jaffer/slib/

** Scheme on Emacs

On Emacs, there are a couple of major modes designed for Scheme:

#+texinfo: @heading Work with Different Implementations of Scheme

- ~cmuscheme-mode~ :: Inferior Scheme mode---Major mode for interacting with an
  inferior  Scheme   process.  This   is  an  old   major  mode   extension  of
  ~scheme-mode~; adds functions  for code execution directly  from within Emacs
  buffers;  this package  implements interactive  work with  interactive Scheme
  interpreters. This interactive work is  implemented via the ~comint~ package,
  included into Emacs distribution.

  - [[https://github.com/typester/emacs/blob/master/lisp/cmuscheme.el][~cmuscheme.el~ source]]

  - Installation ::  put into your  initialization file the following  lines of
    code, and the package will be loaded when you call ~run-scheme~.

    #+begin_src lisp
      (autoload 'run-scheme "cmuscheme" "Run an inferior Scheme" t)
      (setq scheme-program-name "<scheme>")
    #+end_src

    All settings  for this  package are available  via the  customization group
    named =cmuscheme=.

- ~quack~ :: [[http://community.schemewiki.org/?Quack][Quack]] is a package  for Emacs by neil-van-dyke that enhances Emacs
  support for Scheme. It is  layered atop the standard packages ~cmuscheme.el~,
  by Olin Shivers, and ~scheme.el~, by Bill Rozas and Dave Love.

- [[http://www.nongnu.org/geiser/][~geiser~]]  :: Geiser  is a  collection  of Emacs  major and  minor modes  that
  conspire with one or more Scheme interpreters to keep the Lisp Machine Spirit
  alive. It draws inspiration (and a bit more) from environments such as Common
  Lisp’s Slime,  Factor’s FUEL, Squeak  or Emacs itself,  and does its  best to
  make Scheme hacking inside Emacs (even more) fun.


#+texinfo: @heading Work with Concrete Implementations of Scheme

- ~xscheme~ ::   Scheme  Interaction Mode---major mode for  interacting with an
  inferior MIT Scheme process; it is used to run (only) MIT Scheme under Emacs.

  : (require 'xscheme)
  : M-x run-scheme

- ~gds~ ::

- ~bee-mode~ ::

- ~gambit~ ::

*** Scheme Mode

~scheme-mode~ is a  major mode for editing Scheme code;  it is distributed with
Emacs and is a modified form  of ~lisp-mode~ (whose parent mode is ~prog-mode~)
and uses the same source-code editing commands as ~lisp-mode~.

~scheme-mode~  is started  with  the  command =M-x  scheme-mode=;  it runs  the
~scheme-mode-hook~ during initialization.

Using the  command =M-x run-scheme=  will start  an inferior Scheme  process in
~inferior-scheme-mode~ in a dedicated  buffer (usually called =*scheme*=) using
the general  ~cmuscheme~ package. When  an inferior Scheme process  is running,
some  additional  commands will  be  defined,  for evaluating  expressions  and
controlling the interpreter, and the state  of the process will be displayed in
the mode line of all Scheme buffers.

~scheme-mode~ provides the following functionality:
  - syntax highlighting
  - works with language expressions
  - indents source code
  - highlights paired brackets


~scheme-mode~ is enabled automatically for  all files with standard extensions
  of Scheme source code:
  - ~.scm~
  - ~.ss~


To enable ~scheme-mode~ for other file extensions:
  : (add-to-list 'auto-mode-alist '("\\.<ext>$" . scheme-mode))


 - To switch to that mode, put something like this into your ~.emacs~ file:

   #+begin_src elisp
   (autoload 'scheme-mode "cmuscheme" "Major mode for Scheme." t)
   (autoload 'run-scheme "cmuscheme" "Switch to interactive Scheme buffer." t)
   (setq scheme-program-name "name-of-your-scheme-program")
   (add-hook 'scheme-mode-hook 'turn-on-font-lock)
   #+end_src

   The  major mode  does syntax-highlighting  and indentation.  The minor  mode,
   invoked  with =M-x  run-scheme=, executes  a Scheme  interpreter in  an Emacs
   buffer. You can evaluate sections of a  program in the buffer or type into it
   directly.

*** CMU Scheme Mode
For  more advanced  syntax-highlighting and  indenting, check  out the  various
extensions to the ~cmuscheme~ mode at

- http://www.cs.indiana.edu/proglang/scheme/iucs.html.

*** MIT Scheme Mode
MIT Scheme includes a specialized  mode (~mit-scheme.el~) that understands some
of MIT's extensions and provides a closer integration with the REPL.

*** Quack
=Quack= (http://www.neilvandyke.org/quack/)  provides numerous  enhancements to
Emacs support, works with numerous  Scheme implementations, and is a no-brainer
install  (unless you  are using  a rare  Scheme implementation  for which  even
better REPL integration exists).

*** Support for Scheme on Emacs
You can find descriptions of these modes,  as well as some other Emacs packages
that provide support for Scheme [[http://alexott.net/en/writings/emacs-devenv/EmacsScheme.html][here]].

* Racket
- https://racket-lang.org


Racket is a general-purpose programming language as well as the
world’s first ecosystem for language-oriented programming. Make your
dream language, or use one of the dozens already available.

Racket started life as a Scheme implementation, but then grew into new
areas.

** Command-Line Tools
Racket provides as part of its standard distribution a number of
command-line tools.

*** Racket Command
- =raco= :: provides a command-line interface to many additional tools
  for compiling Racket programs and maintaining a Racket installation.
  The =raco= program supports various Racket tasks from a command line.

  See https://docs.racket-lang.org/raco/index.html

- =raco help= :: to get a complete list of available commands for your
  installation.

- =raco make= :: compiles Racket source to bytecode

- =raco exe= :: create stand-alone executables

- =raco setup= :: manages a Racket installation, including manually
  installed packages.

- =raco pkg= :: manages packages that can be installed through the
  Racket package manager.

- =raco test= :: run tests

- =raco doc= :: documentation search

- =raco scribble= :: building documentation

- =raco read= :: reading and pretty-printing

** Racket and Emacs

*** Racket Mode
[[https://github.com/greghendershott/racket-mode][Racket mode]] provides thorough syntax highlighting and DrRacket-style
REPL and buffer execution support for Emacs.

- Racket Mode Guide :: https://www.racket-mode.com

- Scheme Mode :: as a major mode, plus Quack and Geiser minor modes
* Clojure
"Clojure is  a robust, practical, and  fast programming language with  a set of
useful features that together form a simple, coherent, and powerful tool."

- https://clojure.org

#+texinfo: @heading The Clojure Programming Language

#+attr_texinfo: :author Rich Hickey, author of Clojure and CTO Cognitect
#+begin_quote
Clojure  is  a dynamic,  general-purpose  programming  language, combining  the
approachability and  interactive development  of a  scripting language  with an
efficient and robust infrastructure for multithreaded programming. Clojure is a
compiled language, yet remains completely  dynamic – every feature supported by
Clojure  is supported  at runtime.  Clojure provides  easy access  to the  Java
frameworks, with optional  type hints and type inference, to  ensure that calls
to Java can avoid reflection.

Clojure is a dialect of Lisp,  and shares with Lisp the code-as-data philosophy
and a powerful macro system.  Clojure is predominantly a functional programming
language, and  features a  rich set of  immutable, persistent  data structures.
When mutable  state is needed,  Clojure offers a software  transactional memory
system  and reactive  Agent system  that ensure  clean, correct,  multithreaded
designs.
#+end_quote

** Why Clojure?

 Why did I write yet another programming language? Basically because I wanted:

 - A Lisp
 - for Functional Programming
 - symbiotic with an established Platform
 - designed for Concurrency
 and couldn’t find one.

 #+texinfo: @subheading Lisp is a good thing

 - Often emulated/pillaged, still not duplicated
 - Lambda calculus yields an extremely small core
 - Almost no syntax
 - Core advantage still code-as-data and syntactic abstraction
 - What about the standard Lisps (Common Lisp and Scheme)?
   - Slow/no innovation post standardization
   - Core data structures mutable, not extensible
   - No concurrency in specs
   - Good implementations already exist for JVM (ABCL, Kawa, SISC et al)
   - Standard Lisps are their own platforms
 - Clojure is a Lisp not constrained by backwards compatibility
   - Extends the code-as-data paradigm to maps and vectors
   - Defaults to immutability
   - Core data structures are extensible abstractions
   - Embraces a platform (JVM)

 #+texinfo: @subheading Functional programming is a good thing

 - Immutable data + first-class functions
 - Could always be done in Lisp, by discipline/convention
   - But if a data structure can be mutated, dangerous to presume it won’t be
   - In traditional Lisp, only the list data structure is structurally recursive
 - Pure functional languages tend to strongly static types
   - Not for everyone, or every task
 - Clojure is a functional language with a dynamic emphasis
   - All data structures immutable & persistent, supporting recursion
   - Heterogeneous collections, return types
   - Dynamic polymorphism

#+texinfo: @subheading Object Orientation is overrated

- Born of simulation, now used for everything, even when inappropriate
  - Encouraged by Java/C#  in all situations, due to their  lack of (idiomatic)
    support for anything else
- Mutable stateful objects are the new spaghetti code
  - Hard to understand, test, reason about
  - Concurrency disaster
- Inheritance is not the only way to do polymorphism
- "It is  better to have  100 functions operate on  one data structure  than to
  have 10 functions operate on 10 data structures." - Alan J. Perlis
- Clojure  models  its data  structures  as  immutable objects  represented  by
  interfaces, and otherwise does not offer its own class system.
- Many  functions defined  on few  primary data  structures (seq,  map, vector,
  set).
- Write Java in Java, consume and extend Java from Clojure.

#+texinfo: @subheading Polymorphism is a good thing

- Switch statements, structural matching etc yield brittle systems
- Polymorphism yields extensible, flexible systems
- Clojure multimethods decouple polymorphism from OO and types
  - Supports multiple taxonomies
  - Dispatches via static, dynamic or external properties, metadata, etc

** Getting Started
- https://clojure.org/guides/getting_started


- [[https://clojure.org/guides/learn/syntax][Learn Clojure Syntax]]
- [[https://clojure.org/community/resources][Community Resources]]
- [[https://clojure.org/community/books][Books]]


*** Dependencies
Clojure requires Java. Clojure officially supports Java LTS releases (currently
Java  8 and  Java  11). You  can  use  any Java  installation,  whether it’s  a
commercial release from Oracle or an open source version based on OpenJDK (like
adoptopenjdk).

The Clojure tools require that either the ~java~ command is on the path or that
the =JAVA_HOME= environment variable is set.

*** CLI Tools
Clojure provides [[https://clojure.org/guides/deps_and_cli][command line tools]] that can be used to  start a Clojure repl,
use Clojure and Java libraries, and start Clojure programs.

- ~clj~ ::
- ~clojure~ ::
- ~lein~ :: https://leiningen.org
- ~boot~ :: http://boot-clj.com

**** CLI Guide
- https://clojure.org/guides/deps_and_cli

Clojure provides command line tools for:

- Running an interactive REPL (Read-Eval-Print Loop)
- Running Clojure programs
- Evaluating Clojure expressions

In  all the  above scenarios  you  might want  to  use other  Clojure and  Java
libraries. These may  be libraries you are writing locally,  projects in git or
libraries available in  the Maven ecosystem and hosted  by central repositories
like Maven Central or Clojars.

Using a library involves:

- a) specifying  which library you  want to use,  providing its name  and other
  aspects like version
- b) getting it (once) from the git or maven repositories to your local machine
- c) making it available on the JVM classpath so Clojure can find it while your
  REPL or program is running

Clojure  tools specify  a syntax  and file  (~deps.edn~) for  (a), given  which
they’ll handle (b) and (c) automatically.

***** Clojure REPL

Start a =REPL= by running the ~clj~ tool:
: $ clj
: Clojure 1.10.1
: user=>

Once in the =REPL= you can type Clojure expressions and press enter to evaluate
them. Type =Control-D= to exit the =REPL=:

***** Java Libraries

There are  many Clojure  and Java  libraries available  that provide  access to
practically  any  functionality  you  might need.  For  example,  consider  the
commonly used  Clojure library ~clojure.java-time~  for working with  dates and
times.

To work with this  library, you need to declare it as a  dependency so the tool
can ensure it  has been downloaded and  add it to the classpath.  The readme in
most projects shows the name and version to use.

- Create a ~deps.edn~ file to declare the dependency
- Restart the =REPL= with the ~clj~ tool
- You will see messages about a library being downloaded the first time you use
  a dependency. Once the  file is downloaded, it will be  reused in the future.
- You can use the  same process to add other libraries  to your ~deps.edn~ file
  and explore Clojure or Java libraries.

#+begin_src clojure
  {:deps
   {clojure.java-time/clojure.java-time {:mvn/version "0.3.2"}}}
#+end_src

#+begin_example
$ clj
Downloading: clojure/java-time/clojure.java-time/0.3.2/clojure.java-time-0.3.2.pom from clojars
Downloading: clojure/java-time/clojure.java-time/0.3.2/clojure.java-time-0.3.2.jar from clojars
Clojure 1.10.1
user=> (require '[java-time :as t])
nil
user=> (str (t/instant))
"2020-09-01T03:42:47.691119Z"
#+end_example

***** Write a Clojure Program
Create a new directory and copy the ~deps.edn~ file you created above into it:

#+begin_src sh
$ mkdir hello-world
$ cp deps.edn hello-world
$ cd hello-world
$ mkdir src
#+end_src

By default, the ~clj~ tool will look  for source files in the ~src/~ directory.
Create ~src/hello.clj~:

#+begin_src clojure
  (ns hello
    (:require [java-time :as t]))

  (defn time-str
    "Returns a string representation of a datetime in the local time zone."
    [instant]
    (t/format
      (t/with-zone (t/formatter "hh:mm a") (t/zone-id))
      instant))

  (defn run [opts]
    (println "Hello world, the time is" (time-str (t/instant))))
#+end_src

This program has  an entry function ~run~  that can be executed  by ~clj~ using
=-X=:

#+begin_example
$ clj -X hello/run
Hello world, the time is 10:53 PM
#+end_example

***** Using a Local Library

You might  decide to move  part of this application  into a library.  The ~clj~
tool uses local  coordinates to support projects that exist  only on your local
disk.

Let’s extract the ~java-time~ parts of this application out into a library in a
parallel directory  ~time-lib~. The  final structure  will look  something like
this:

#+begin_example
├── time-lib
│   ├── deps.edn
│   └── src
│       └── hello_time.clj
└── hello-world
    ├── deps.edn
    └── src
        └── hello.clj
#+end_example

Under  ~time-lib~, use  a copy  of the  ~deps.edn~ file  you already  have, and
create a file ~src/hello_time.clj~:

#+begin_src clojure
  (ns hello-time
    (:require [java-time :as t]))

  (defn now
    "Returns the current datetime"
    []
    (t/instant))

  (defn time-str
    "Returns a string representation of a datetime in the local time zone."
    [instant]
    (t/format
      (t/with-zone (t/formatter "hh:mm a") (t/zone-id))
      instant))
#+end_src

Update  the  application at  ~hello-world/src/hello.clj~  to  use your  library
instead:

#+begin_src clojure
  (ns hello
    (:require [hello-time :as ht]))

  (defn run [opts]
    (println "Hello world, the time is" (ht/time-str (ht/now))))
#+end_src

Modify ~hello-world/deps.edn~ to use a local coordinate that refers to the root
directory of  the ~time-lib~  library (make  sure to update  the path  for your
machine):

#+begin_src clojure
  {:deps
   {time-lib/time-lib {:local/root "../time-lib"}}}
#+end_src

You can  then test  everything from  the hello-world  directory by  running the
application:

#+begin_src sh
$ clj -X hello/run
Hello world, the time is 02:07 PM
#+end_src

** Clojure Reference
*** The Reader
 https://clojure.org/reference/reader

*** API
 https://clojure.org/api/api
* Bel

** About Bel
- http://www.paulgraham.com/bel.html

** A Guide to the Bel Language
- https://sep.yimg.com/ty/cdn/paulgraham/bellanguage.txt?t=1595850613&

** Bel Source
- https://sep.yimg.com/ty/cdn/paulgraham/bel.bel?t=1595850613&

** Bel Examples for Lisp Programmers
- https://sep.yimg.com/ty/cdn/paulgraham/belexamples.txt?t=1595850613&

* Build Tools
:PROPERTIES:
:appendix: t
:custom_id: build-tools
:org-template-version: 0.6.29
:END:
** Makefile					:dependencies:env_vars:perl:
:PROPERTIES:
:appendix: t
:dependency1: make
:dependency2.0: AWS User account at https://aws.amazon.com
:dependency2.1: AWS cli v2 in PATH https://docs.aws.amazon.com/cli/index.html
:dependency2.2: See how to Install AWS CLI v2 at https://docs.aws.amazon.com/cli/latest/userguide/install-cliv2-mac.html
:dependency2.3: aws credentials: access token and secret access token stored in ~/.aws/credentials
:dependency2.4: AWS S3 buckets set up for serving a static web page
:dependency3: GitHub Account with personal access token stored in GITHUB_TOKEN
:dependency4: texinfo @6.7._
:dependency5: Emacs, Org-mode, Babel language 'shell' enabled
:env_var1: SYNC_ORG_TEMPLATE: holds the full path to this Template.org file
:env_var2: GITHUB_TOKEN: holds the GitHub personal access token
:env_var3: EDITOR: must hold a reference to a working emacsclient server
:env_var4: COLORS
:org-template-version: 0.6.29
:END:

#+name:Makefile
#+header: :tangle Makefile
#+begin_src makefile

  ###############################################################################
  ### USER-DEPENDENT VARIABLES
  ### USE ENVIRONMENT VARIABLES WHENEVER POSSIBLE

  # NOTE: All environment variables need to be exported PRIOR to starting the
  # Emacs server as EDITOR in your shell startup files; otherwise, they will not
  # be available to Emacs.
  # When I moved from using Bash to Zsh, I inadvertently changed the order of
  # import, and started the Emacs server before importing, and caused a horrible
  # bug which caused the program to work on one computer but fail on another.

  # The absolute path to this Template file
  TEMPLATE := $(SYNC_ORG_TEMPLATE)


  ### TOOLS & RESOURCES
  # tools is a directory holding tangled scripts, such as cmprpl
  # resources is a directory holding static resources for the project
  # images is a directory holding jpg and png image files
  TOOLS	:= tools
  CMPRPL	:= $(TOOLS)/cmprpl
  RESOURCES := resources
  IMAGES  := $(RESOURCES)/images

  # Use emacsclient as $EDITOR; make sure it is set in a shell startup file and
  # the server has been started.
  EMACS	  := $(EMACS)
  EDITOR	  := $(EDITOR)

  # User’s personal GitHub token for authentication to GitHub
  # DO NOT HARD-CODE THIS VALUE
  GITHUB_TOKEN := $(GITHUB_TOKEN)

  # The AWS Command Line Interface (AWS CLI) is an open source tool
  # that enables you to interact with AWS services using commands in
  # your command-line shell.  It must be present on your system.  Run the 'make'
  # command 'install-aws-cli' to install it if you do not have it.  Be sure to
  # run 'aws configure' after installing it.  This will place your AWS
  # credentials into ~/.aws/credentials.
  AWS := aws
  S3  := $(AWS) s3

  # The AWS region of choice; this can also be in .aws/config
  REGION := --region us-west-2

  ### END OF USER-DEPENDENT VARIABLES
  ###############################################################################
  ### MAKE-GENERATED VARIABLES

  ### PROJ AND ORG
  # ORG is the name of this Org file with extension .org
  # PROJ is the project name---the Org file name without extension.

  ### NOTE: there can be only one Org file in the project directory;
  # so far this has not been a problem, but it might be.

  PWD  := $(shell pwd)
  ORG  := $(shell ls *.org)
  PROJ := $(basename $(ORG))

  ### NOTE: S is needed only for the Template file because of the way it is nested
  # one level deep in the Templates GitHub repo, which uses the plural form
  # of Templates, whereas this file uses the singular form, Template.  So when
  # the homepage link is updated, the curl command must be told to use the plural
  # form.	 This is obviously a hack only for my own use and can be removed once
  # I clean up this anomaly.

  ifeq ($(PROJ),$(basename $(notdir $(TEMPLATE))))
  S := s
  endif

  # The AWS S3 bucket to use to store the html source file; it is found at the
  # key #+bucket towards the beginning of the file and should include the appropriate
  # suffix (.com, .net, .org, etc)
  BUCKET       := $(shell $(EDITOR) --eval \
		 '(with-current-buffer (find-file-noselect "$(ORG)") \
		    (save-excursion \
		      (goto-char (point-min)) \
		      (re-search-forward "^\#[+]bucket:\\(.*\\)$$" nil t) \
		      (match-string-no-properties 1)))')
  S3_BUCKET    := s3://$(BUCKET)
  HTTPS_BUCKET := https://$(BUCKET)

  ### DIR, SRC
  # DIR is the .info name found at '#+texinfo_filename:<DIR>.info' (at
  # the bottom of this file in the export configuration settings)
  # without its extension, used as the INFO filename and the name of the
  # HTML export directory; this code uses the lowercased PROJ name if
  # there is no '#+texinfo_filename'.
  # SRC is HTML directory based upon the DIR name

  #DIR := $(shell $(EDITOR) --eval \
  #	'(with-current-buffer (find-file-noselect "$(ORG)") \
  #		(save-excursion \
  #		(goto-char (point-min)) \
  #		(re-search-forward "^\#[+]\\(?:texinfo_filename\\|TEXINFO_FILENAME\\):\\(.*\\).info$$" nil t) \
  #		(match-string-no-properties 1)))')

  DIR := $(shell sed -E -n "/^\#\+texinfo_filename/s/^.*:(.*)\.info$$/\1/p" $(ORG))
  ifeq ($(DIR),$(EMPTY))
	  DIR := $(shell echo $(PROJ) | tr "[:upper:]" "[:lower:]")
  endif

  SRC := $(DIR)/

  ### VERS: v1.2.34/
  # VERS is the version number of this Org document.
  # When sync is run after the version number has been updated, then VERS
  # picks up the newly-changed value.  VERS used to be staticly imbedded
  # when the Makefile was tangled, but it needs to be dynamic for
  # development.

  # QUERY: should this number be formatted like this, or should it be just the numbers?
  # The reason it includes them is the S3PROJ obtains the name from the S3 bucket, and
  # it includes them.  But it only includes them because I have made it so.  Not a good
  # reason just by itself.  The ending slash is not actually a part of the version, but
  # comes from the way the 'aws2 ls' command returns its values.	So VERS should probably
  # not include the trailing slash, although it doesn’t hurt anything.

  VERS := v$(shell $(EDITOR) --eval \
	  '(with-current-buffer (find-file-noselect "$(ORG)") \
		  (save-excursion \
		    (goto-char (point-min)) \
		    (re-search-forward "^\#[+]\\(?:macro\\|MACRO\\):version Version \\(\\(?:[[:digit:]]+[.]?\\)\\{3\\}\\)") \
		    (match-string-no-properties 1)))')/

  ### AWS
  # PROJ_LIST contains the list of projects currently uploaded to
  # the S3 bucket; each item contains the name of the project and its
  # current version.

  # Created function using elisp instead of the shell.
  # This variable contains an elisp list of strings of the form '("proj1-v1.2.3/" "proj2-v4.5.6/" ...)'
  # However, when it prints to the shell, the quotes are lost.
  # Need to make sure elisp's variable 'exec-path contains the proper $PATH instead of adding to 'exec-path.

  PROJ_LIST := $(shell $(EDITOR) --eval \
	  "(progn \
		  (require (quote seq)) (add-to-list (quote exec-path) (quote \"/usr/local/bin\")) \
		  (seq-map (lambda (s) (replace-regexp-in-string \"^\s+PRE \" \"\" s)) \
			  (seq-filter (lambda (s) (string-match-p (regexp-quote \" PRE \") s)) \
			  (process-lines \"$(AWS)\" \"s3\" \"ls\" \"$(S3_BUCKET)\"))))")

  ### S3PROJ
  # The name of the current project as obtained from S3: 'proj-v1.2.34/'
  # If there is no current project in the S3 bucket, then assign a value equal to
  # the Org project and version instead.  It is set to the project if found, and
  # NO if not found, then updated in the ifeq block below.
  S3PROJ := $(shell $(EDITOR) --eval \
		  '(let ((proj (seq-find (lambda (s) (string-match-p "$(DIR)" s)) (quote $(PROJ_LIST))))) \
		     (or proj (quote NO)))')

  ### PROJINS3
  # is used by make sync; this allows the index.html file to be generated the first
  # time the project is synced.  It is set to NO if this project is not currently in an
  # S3 bucket, and it is set to YES if it is.
  PROJINS3 :=

  ### S3VERS
  # The version of this project currently installed in the S3 bucket: 'v1.2.34/'
  # If there is no current version in the S3 bucket, then assign the version from
  # this Org file instead.
  S3VERS   :=

  # Update S3PROJ, S3VERS, and PROJINS3
  ifeq ($(S3PROJ), NO)
	  S3PROJ := $(DIR)-$(VERS)
	  S3VERS := $(VERS)
	  PROJINS3 := NO
  else
	  S3VERS := $(subst $(DIR)-,,$(S3PROJ))
	  PROJINS3 := YES
  endif

  ### GITHUB
  # USER is the current user's GitHub login name.

  # The user name used to be statically embedded into the Makefile
  # during tangle, but in an effort to make the Makefile dynamically
  # indepedent, dynamic code has replaced the static code.  The code
  # that placed the static name in the Makefile was a 'node' script that
  # ran in a separate Org process during tangle.	An unfortunate fact of
  # 'make' is that 'make' strips the quote marks from the string
  # obtained from the 'curl' command when the 'make shell' command
  # returns the string.	 This makes the string malformed JSON and
  # unparsable by most JSON parsers, including 'node’.	However,
  # 'perl'’s core module JSON::PP (but not JSON::XS) has facilities to
  # parse very malformed JSON strings.	Therefore, this dynamic code
  # uses 'perl' and the core module JSON::PP to parse the 'curl' string
  # into a 'perl' JSON object which can return the login name.	This
  # code should work with any version of 'perl' without having to
  # install any modules.

  USER := $(shell \
	    curl -sH "Authorization: token $(GITHUB_TOKEN)" https://api.github.com/user \
	    | \
	    perl -MJSON::PP -e \
		'$$/ = ""; \
		 my $$json = JSON::PP->new->loose->allow_barekey->decode(<STDIN>); \
		 print $$json->{login};' \
	    )
  SAVE	:= resources

  ### TEXINFO
  TEXI	:= $(PROJ).texi
  INFO	:= $(DIR).info
  INFOTN	:= $(shell $(EDITOR) --eval "(file-truename \"$(INFO)\")")
  PDF	:= $(PROJ).pdf
  INDEX	:= index.html
  HTML	:= $(DIR)/$(INDEX)
  DIR_OLD	:= $(DIR)-old

  ### AWS S3
  DST_OLD	:= $(S3_BUCKET)/$(S3PROJ)
  DST_NEW	:= $(S3_BUCKET)/$(DIR)-$(VERS)
  EXCL_INCL   := --exclude "*" --include "*.html"
  INCL_IMAGES := --exclude "*" --include "*.jpg" --include "*.png"
  GRANTS	:= --grants read=uri=http://acs.amazonaws.com/groups/global/AllUsers
  S3SYNC	:= $(S3) sync --delete $(EXCL_INCL) $(SRC) $(DST_OLD) $(REGION) $(GRANTS)
  S3MOVE	:= $(S3) mv --recursive $(DST_OLD) $(DST_NEW) $(REGION) $(GRANTS)
  S3COPY	:= $(S3) cp $(INDEX) $(S3_BUCKET) $(REGION) $(GRANTS)
  S3REMOVE:= $(S3) rm $(S3_BUCKET)/$(S3PROJ) --recursive
  S3IMAGESYNC := $(S3) sync $(INCL_IMAGES) $(IMAGES) $(S3_BUCKET)/$(IMAGES) $(REGIONS) $(GRANTS)

  ###############################################################################

  default: check texi info html pdf

  PHONY: default all check values boot \
	    texi info html pdf \
	    open-org open-texi open-html open-pdf \
	    clean dist-clean wiped-clean \
	    help sync update delete-proj \
	    install-aws-cli \
	    index-html upload-index-html

  values: check
	    @printf "$${BLUE}Values...$${CLEAR}\n"
	    @echo TEMPLATE:	$(TEMPLATE)
	    @echo EDITOR:	$(EDITOR)
	    @echo USER:		$(USER)
	    @echo PWD:		$(PWD)
	    @echo ORG:		$(ORG)
	    @echo TEXI:		$(TEXI)
	    @echo INFO:		$(INFO)
	    @ECHO INFOTN:	$(INFOTN)
	    @echo BUCKET:	$(BUCKET)
	    @echo PROJ:		$(PROJ) $S
	    @echo S3_BUCKET:	$(S3_BUCKET)
	    @echo HTTPS_BUCKET:	$(HTTPS_BUCKET)
	    @echo VERS:		$(VERS)
	    @echo S3PROJ:	$(S3PROJ)
	    @echo S3VERS:	$(S3VERS)
	    @echo DIR:		$(DIR)
	    @echo DIR_OLD:	$(DIR_OLD)
	    @echo SRC:		$(SRC)
	    @echo DST_OLD:	$(DST_OLD)
	    @echo DST_NEW:	$(DST_NEW)
	    @echo PROJ_LIST:	"$(PROJ_LIST)"
	    @echo PROJINS3:	$(PROJINS3)

  check:
	    @printf "$${BLUE}Checking dependencies...$${CLEAR}\n"

	    @[[ -z $(BUCKET) ]] && \
	       { printf "$${RED}$(BUCKET) $${CYAN}must be set.$${CLEAR}\n"; exit 1; } || \
	       printf "$${CYAN}BUCKET: $${GREEN}$(BUCKET)$${CLEAR}\n";

	    @[[ -z $${GITHUB_TOKEN} ]] && \
	       { printf "$${RED}GITHUB_TOKEN $${CYAN}must be set.$${CLEAR}\n"; exit 1; } || \
	       printf "$${CYAN}GITHUB_TOKEN: $${GREEN}SET$${CLEAR}\n";

	    @[[ (-d ~/.aws) && (-f ~/.aws/credentials) && (-f ~/.aws/config) ]] && \
	       printf "$${CYAN}AWS credentials and config: $${GREEN}SET$${CLEAR}\n" || \
	       { printf "$${RED}~/.aws 'credentials' and 'config' must be set.$${CLEAR}\n"; exit 1; }

	    @[[ "$(shell $(EDITOR) --eval '(member (quote texinfo) org-export-backends)')" = "(texinfo)" ]] && \
		  printf "$${CYAN}Texinfo backend: $${GREEN}INSTALLED.$${CLEAR}\n" || \
		  { printf "$${YELLOW}Texinfo backend:$${CLEAR} $${RED}NOT INSTALLED; it must be installed.$${CLEAR}\n"; exit 1; }

	    @[[ $(shell $(EDITOR) --eval '(symbol-value org-confirm-babel-evaluate)') == "t" ]] && \
		  { printf "$${YELLOW}org-confirm-babel-evaluate:$${CLEAR} $${RED}T; set to NIL.$${CLEAR}\n"; exit 1; } || \
		  printf "$${CYAN}org-confirm-babel-evaluate: $${GREEN}OFF.$${CLEAR}\n\n"

  open-org: $(ORG)
	    @$(EDITOR) -n $(ORG)
  $(ORG):
	    @echo 'THERE IS NO $(ORG) FILE!!!'
	    exit 1

  texi: $(TEXI)
  $(TEXI): $(ORG)
	   @echo Making TEXI...
	   @$(EDITOR) -u --eval \
		  "(with-current-buffer (find-file-noselect \"$(ORG)\" t) \
			  (save-excursion \
			  (org-texinfo-export-to-texinfo)))"
	   @echo Done making TEXI.
  open-texi: texi
	   @$(EDITOR) -n $(TEXI)

  info: $(INFO)
  $(INFO): $(TEXI)
	   @echo Making INFO...
	   @makeinfo -o $(INFO) $(TEXI)
	   @$(EDITOR) -u -eval \
		  "(when (get-buffer \"$(INFO)\") \
			  (with-current-buffer (get-buffer \"$(INFO)\") \
				  (revert-buffer t t t)))"
	   @echo Done making INFO.

  open-info: info
	   @$(EDITOR) -u -eval \
		  "(if (get-buffer \"*info*\") \
			  (with-current-buffer (get-buffer \"*info*\") \
				(when (not (string= \"(symbol-value (quote Info-current-file))\" \"$(INFOTN)\")) \
					(info \"$(INFOTN)\")) \
				(revert-buffer t t t)) \
		      (info \"$(INFOTN)\"))"

  html: $(HTML)
  $(HTML): $(TEXI)
	   @echo Making HTML INFO..
	   @makeinfo --html -o $(DIR) $(TEXI)
	   @echo Done making HTML.
	   $(CMPRPL) $(DIR) $(DIR_OLD)
  open-html: html
	   @open $(HTML)

  # If pdftexi2dvi produces an error, it may still produce a viable PDF;
  # therefore, use --tidy.  If it produces an error, try to link the PDF;
  # if it does not produce an error, the PDF will be added to the top dir
  # and there will be no attempt to link.
  pdf:	$(PDF)
  $(PDF): $(TEXI)
	  @echo Making PDF INFO...
	  @-pdftexi2dvi --quiet --build=tidy $(TEXI) || ln -s $(PROJ).t2d/pdf/build/$(PDF) $(PDF)
	  @echo Done making PDF.
  open-pdf:pdf
	   @open $(PDF)

  sync:   $(HTML)
	  @echo Syncing version $(VERS) onto $(S3VERS)...
	  $(S3SYNC)
	  $(S3IMAGESYNC)
	  @echo Done syncing.
	  [[ $(VERS) != $(S3VERS) ]] && { echo Moving...; $(S3MOVE); echo Done moving.;  make homepage; } || :
	  [[ $(PROJINS3) = "NO" ]] && make homepage || :

  # This is a target-specific variable for updating the “description”
  # key on the GitHub repo page with the current version number.  It
  # first makes a curl call to the GitHub project repo, finds the
  # “description” line, pulls out the description only (leaving the old
  # version) and then prints the value with the current version number.
  # This value is used by the “homepage:” target in the PATCH call.
  # This method is arguably harder to code but faster to run than using
  # Perl with the JSON::PP module.

  homepage: description = $(shell \
	  curl -s \
		  -H "Authorization: token $(GITHUB_TOKEN)" \
		  https://api.github.com/repos/$(USER)/$(PROJ)$S | \
		  (perl -ne 'if (/^\s*\"description\":\s*\"(.*): v(?:(?:[[:digit:]]+[.]?){3})/) {print $$1}'))

  ### NOTE the use of the S variable at the end of PROJ; this is to handle
  # the singular case of the GitHub repo using the plural form, Templates
  # whereas the the Template.org file uses the singular form.
  homepage: $(ORG) upload-index-html
	    @echo Updating homepage...
	    @echo DESCRIPTION: $(description)
	    @echo VERS: $(VERS)
	    @curl -i \
		  -H "Authorization: token $(GITHUB_TOKEN)" \
		  -H "Content-Type: application/json" \
		  -X PATCH \
		  -d "{\"homepage\":\"$(HTTPS_BUCKET)/$(DIR)-$(VERS)\",\
		       \"description\":\"$(description): $(VERS)\"}" \
		  https://api.github.com/repos/$(USER)/$(PROJ)$S
	    @echo Done updating homepage.

  delete-proj:
	  @echo Deleting project $(PROJ)...
	  @curl -i \
		  -H "Authorization: token $(GITHUB_TOKEN)" \
		  -H "Accept: application/vnd.github.v3+json" \
		  -X DELETE \
		  https://api.github.com/repos/$(USER)/$(PROJ)$S
	  @$(S3REMOVE)
	  @make dist-clean
	  @make upload-index-html
	  @$(EDITOR) -u --eval "(kill-buffer \"$(ORG)\")"
	  @rm -rf "../$(PROJ)"
	  @echo Done deleting project.

  index-html: $(INDEX)
  $(INDEX): $(ORG)
	  @echo making index.html...
	  $(EDITOR) --eval \
	  "(with-current-buffer (find-file-noselect \"$(ORG)\") \
		  (save-excursion \
		    (org-link-search \"#project-index-title\") \
		    (org-export-to-file (quote html) \"index.html\" nil t)))"
	  @echo Done making index.html.

  upload-index-html: $(INDEX)
	   @echo Uploading index.html...
	   $(S3COPY)
	   @echo Done uploading index.html

  install-aws-cli:
	    curl "https://awscli.amazonaws.com/AWSCLIV2.pkg" -o "AWSCLIV2.pkg" && \
	    sudo installer -pkg AWSCLIV2.pkg -target / && \
	    which aws && aws --version
	    rm -rf AWSCLIV2.pkg

  clean:
	  @echo Cleaning...
	    -@rm *~ 2>/dev/null
	    -@for file in *.??*; \
	    do \
		    ext=$${file#$(PROJ).}; \
		    [[ ! $${ext} =~ org|texi|info|pdf|html ]] && rm -rv $${file}; \
	    done

  dist-clean: clean
	  @echo Dist Cleaning...
	    @${EDITOR} -u --eval \
	      "(kill-buffer \"$(ORG)\")"
	    -@rm -rf *.{texi*,info*,html*,pdf*} $(DIR) $(TOOLS)
	    -@for dir in *; \
		do \
		    [ -d $$dir -a $$dir != "$(DIR_OLD)" -a $$dir != $(SAVE) ] && \
		    rm -vr $$dir; \
		done

  wipe-clean: dist-clean
	  @echo Wipe Clean...
	    -@rm -rf Makefile Readme.md $(DIR_OLD)
	    @git checkout Makefile README.md

  git-ready: dist-clean
	    git checkout Makefile
	    git checkout README.md
	    git status

  help:
	    @echo '"make boot" tangles all of the files in Template'
	    @echo '"make default" makes the .texi file, the .info file, \
	    the html files, and the .pdf file.'
	    @echo

	    @echo '"make check" checks for prerequistes'
	    @echo '"make values" runs check and prints variable values'
	    @echo

	    @echo '"make texi" makes the .texi file'
	    @echo '"make info" makes the .info file'
	    @echo '"make html" makes the html distribution in a subdirectory'
	    @echo '"make pdf" makes the .pdf file'
	    @echo

	    @echo '"make open-org" opens the ORG program using emacsclient for editing'
	    @echo '"make open-texi" opens the .texi file using emacsclient for review'
	    @echo '"make open-html" opens the distribution index.html file \
	    in the default web browser'
	    @echo '"make open-pdf" opens the .pdf file'
	    @echo

	    @echo '"make sync" syncs the html files in the AWS S3 bucket BUCKET; \
	    you must have your AWS S3 bucket name in the env var AWS_S3_BUCKET; \
	    You must have your AWS credentials installed in ~/.aws/credentials'
	    @echo

	    @echo '"make install-aws-cli" installs the "aws cli v2" command-line tools'
	    @echo 'You also need to run "aws configure" and supply your Access Key and Secret Access Key'
	    @echo

	    @echo '"make clean" removes the .texi, .info, and backup files ("*~")'
	    @echo '"make dist-clean" cleans, removes the html distribution, \
	    and removes the build directory'
	    @echo '"make wipe-clean" wipes clean the directory, including old directories'
	    @echo

	    @echo '"make delete-proj" deletes the project from the file system, GitHub and AWS'

#+end_src

*** TODO Next
1. The CloudFront configuration needs to be updated recognize the new version
   directory that is created as part of the ~sync~ operation.

2. Update the GitHub HOME website link for each new sync operation.

3. Store on GitHub a version of each other format upon a sync operation (i.e.,
   the INFO and PDF versions)

** Compare Replace

#+begin_comment
The following source  code tangles all files during an  export operation.  This
is  to make  sure the  ~cmprpl~ source  code exists  in the  ~tools/~ directory
before  running the  Makefile target  =html=.  It  also makes  sure there  is a
Makefile on an initial export. The following code is not exported.
#+end_comment

#+name:tangle-org-file
#+header: :exports results :eval yes :results silent
#+begin_src emacs-lisp
(org-babel-tangle-file (buffer-file-name))
#+end_src

The  AWS ~sync~  command  relies  upon time  stamps  to  determine whether  two
programs are identical or not, as  well as content.  If two otherwise identical
files have  different time stamps,  ~sync~ will  assume they are  different and
will  process the  newer.   However, the  ~texinfo~  ~makeinfo --html~  command
produces all  new files even  if some files  (or most files)  remain unchanged.
This  means that  all files  will be  uploaded to  the AWS  S3 bucket  on every
iteration, even though the majority of the files are actually unchanged.

The ~cmprpl~  source code attempts to  resolve the issue of  identical exported
code having different  time stamps, thus defeating the benefit  provided by the
~aws2 s3 sync~ command uploading only changed files.

This program makes sure that a generated HTML directory exists: =$DIR_NEW=.  If
it doesn’t, then it is in an improper state and the program stops with an error
message.

The  program then  checks  if  an old  directory  exists,  =$DIR_OLD=.  If  one
doesn’t,  then one  is  created by  copying the  current  new directory.   This
provides a baseline  for comparisons going forward.  The program  exits at that
point. It is very important that  the =$DIR_OLD= directory not be deleted going
forward.

Given  that =$DIR_OLD=  exists, the  program then  loops through  all files  in
=$DIR_NEW= and  compares them  to the  files in =$DIR_OLD=.   If the  files are
identical, the =$DIR_OLD= file replaces the =$DIR_NEW= file while retaining the
old time stamp (using the ~-p~ option of ~cp~. If a file is different, then the
=$DIR_NEW= file  replaces the =$DIR_OLD=  file, thus giving it  updated content
and  an updated  time stamp.   If the  file does  not exist  in the  =$DIR_OLD=
directory, then it is added.

The  program then  loops through  all of  the files  in the  old directory  and
deletes  any that  do not  exist in  the new  directory.  Now  both directories
should be in sync.

#+caption:Compare Replace program
#+name:cmprpl
#+header: :mkdirp t
#+header: :shebang "#!/usr/bin/env bash"
#+begin_src sh :tangle tools/cmprpl
  [[ $# -eq 2 ]] || { echo "ERROR: Incorrect command line arguments"; exit 1; }
  DIR_NEW=$1
  DIR_OLD=$2

  [[ -d $DIR_NEW ]] || { echo "ERROR: $DIR_NEW does not exist"; exit 1; }
  [[ -d $DIR_OLD ]] || { echo "CREATING: $DIR_OLD does not exist"; cp -a $DIR_NEW $DIR_OLD; exit 0; }

  for newfile in $DIR_NEW/*
  do
      oldfile=$DIR_OLD/$(basename $newfile)
      if [[ -e $oldfile ]]
      then
	 if cmp -s $newfile $oldfile
	 then
	     printf "${GREEN}copying OLD to NEW${CLEAR}: "
	     cp -vp $oldfile $newfile
	 else
	     printf "${PURPLE}copying NEW to OLD${CLEAR}: "
	     cp -vp $newfile $oldfile
	 fi
      else
	  printf "${BLUE}creating NEW in OLD${CLEAR}: "
	  cp -vp $newfile $oldfile
      fi
  done

  for oldfile in $DIR_OLD/*
  do
      newfile=$DIR_NEW/$(basename $oldfile)
      if [[ ! -e $newfile ]]
      then
	  printf "${RED}removing OLD${CLEAR}: "
	  rm -v $oldfile
      fi
  done
#+end_src


** Update Utility Commands
*** Get Parsed Org Tree
This function looks for an Org file in the present working directory, and if it
finds one returns  a parsed tree using  ~org-element-parse-buffer~.  It returns
=nil= if there is no Org file or if the found file is not in ~org-mode~.

#+name:get-parsed-org-tree
#+header: :results silent
#+begin_src emacs-lisp
(defun get-parsed-org-tree (&optional org-dir)
  "This function takes an optional directory name, changes to
that directory if given, otherwise uses the pwd, and finds an Org
file and returns its parsed tree, or nil if none found."
  (when org-dir
      (cd (file-name-as-directory org-dir)))
  (let ((buf (car-safe (find-file-noselect "*.org" nil nil t))))
    (if buf
	(with-current-buffer buf (org-element-parse-buffer))
      nil)))
#+end_src

*** Check for CID
This code  checks whether an  Org file contains  a =custom_id= of  a particular
value.  It accepts  a ~cid-value~ and an optional directory.   If the directory
is not given, then it defaults to the current directory.  If throws an error if
the directory does not exist.  It returns =nil= if the given directory does not
contain an Org file.   It returns =t= if the Org file  contains a node property
of   =custom_id=  and   value  ~cid-value~,   or   =nil=  if   not.   It   uses
~get-parsed-org-tree~.

#+name:org-tree-cid-p
#+header: :results silent
#+begin_src emacs-lisp
(defun org-tree-cid-p (cid-value &optional org-dir)
  "Check whether an org file contains a custom_id of CID"
  (let ((tree (get-parsed-org-tree org-dir)))
    (car (org-element-map tree 'property-drawer
	   (lambda (pd) (org-element-map (org-element-contents pd) 'node-property
			  (lambda (np)
			    (and
			     (string= "custom_id" (org-element-property :key np))
			     (string= cid-value (org-element-property :value np))))))
	   nil t))))
#+end_src

#+name:run-org-tree-cid-p
#+header: :var cid="build-tools"
#+header: :var dir="/usr/local/dev/programming/MasteringEmacs"
#+header: :var gpot=get-parsed-org-tree()
#+header: :var otcp=org-tree-cid-p()
#+header: :results value
#+header: :eval never-export
#+begin_src emacs-lisp
(org-tree-cid-p cid dir)
#+end_src

#+call: run-org-tree-cid-p(dir="/usr/local/dev/programming/MasteringEmacs")

** Bucket Index HTML
The bucket should contain a master ~index.html~  file that links to each of the
individual project  ~index.html~ files.  The  master ~index.html~ file  will be
placed at the root of  the bucket, ~https://<bucket-name>.com/~, and the bucket
must be set up to serve this ~index.html~ when the user hits the root.

*** Get Bucket Name
 This  code searches  for  the keyword-value  pair =bucket:<BUCKET-NAME>=  that
 should be  located towards the  beginning of the  file, and returns  the value
 =BUCKET-NAME= or nil if not found.

#+name: get-bucket-name
#+header: :results value
#+begin_src emacs-lisp
   (save-excursion
     (goto-char (point-min))
     (re-search-forward "^#\\+bucket:\\s*?\\(.*\\)$" nil t)
     (match-string-no-properties 1))
#+end_src

For some reason, ~get-bucket-name~ does not  work when called from the headline
[[#project-index-links][=Links for  bucket=]] below  when creating  =index.html=, even  if it  returns as
~(prin1 ...)~ and is  set up to ~:return output~; the  call receives =nil=. The
following code from ~bucket-name~, however, works. I don't know why.

#+name: bucket-name
#+header: :results output
#+header: :var bucket-name=get-bucket-name()
#+begin_src emacs-lisp
(prin1 bucket-name)
#+end_src

*** Bucket HTTPS URL
This  code calls  ~get-bucket-name~ and  returns the  value returned  as a  URL
string or nil.

#+name: bucket-https-url
#+header: :results value
#+header: :var b=get-bucket-name()
#+begin_src emacs-lisp
(concat "https://" b)
#+end_src

*** S3 Bucket URL
This code calls ~get-bucket-name~ and returns the AWS S3 bucket url.

#+name: s3-bucket-url
#+header: :results value
#+header: :var b=get-bucket-name()
#+begin_src emacs-lisp
(concat "s3://" b)
#+end_src

*** Bucket Projects List
This code uses the ~s3-bucket-url~ result to obtain the list of projects in the
bucket.  It does  this by calling the  AWS S3 high-level command  ~ls~ and then
removing the  =PRE= string in  each result.  The result  that is returned  is a
single  string that  can be  separated into  individual links  by breaking  the
string on spaces.

#+name: bucket-projects-list
#+header: :results output
#+header: :var bucket=s3-bucket-url()
#+begin_src sh
/usr/local/bin/aws s3 ls ${bucket} | sed -ne 's/^.*PRE //p'
#+end_src

*** Bucket Project Links
This code  uses the result  from ~bucket-projects-list~ to create  an unordered
list of  links written to  bucket projects, written  in Org-mode syntax.  It is
executed by a =#+call:= in [[*Bucket Index][*Bucket  Index]] during an HTML export of that subtree
to a file called =index.html=.

#+name: bucket-project-links
#+header: :var b-url=bucket-https-url()
#+header: :var projects=bucket-projects-list()
#+header: :results output raw
#+begin_src emacs-lisp
(seq-do (lambda (u) (princ (format "- [[%s/%sindex.html][~%s~]]
" b-url u u))) (split-string projects))
#+end_src

*** Bucket Index
    :PROPERTIES:
    :custom_id: project-index-title
    :export_file_name: index.html
    :export_subtitle: {{{version}}} created {{{upload-date}}}
    :END:
#+html_doctype: html5
#+options: toc:nil html5-fancy:t

#+html: <hr>

**** Links for bucket call_bucket-name()
     :PROPERTIES:
     :unnumbered: t
     :custom_id: project-index-links
     :END:

#+call: bucket-project-links()
** Project Readme
This adds the README.md template to a project. It should be customized uniquely
for the project.

#+name:project-readme
#+header: :tangle README.md
#+begin_src markdown
# TITLE
## Subtitle
## Author
## Date
## Version
# ABSTRACT
This is the Org Template file.	It is the parent of all other Org Info blogs,
and provides the source code for processing them in various different ways.
# INTRODUCTION
# CHAPTER
## Section
### Subsection
#+end_src

** Boot Template
:PROPERTIES:
:dependency1: EMACS:=:/Applications/MacPorts/Emacs.app/Contents/MacOS/Emacs or similar
:dependency2: EDITOR:=:emacsclient
:dependency3: =SYNC_ORG_TEMPLATE= defined as $DEV/Templates/Org/Template.org
:END:
Although running the command ~org-babel-tangle~ (=C-c C-v t=) from within Emacs
will install  everything, it would  be nice to have  a simple Makefile  that is
downloaded with this  file that could be  invoked to do the  same thing without
starting Emacs and Org-mode and keying in the ~org-babel-tangle~ command.  This
little Makefile should be stored on  GitHub along with the ~Template.org~ file.
When  the source  is extracted  to a  directory, then  running this  Makefile's
default rule  as simply ~make~  will extract the ~preprocess.el~  script, which
updates  =DEV= and  then  extracts the  full Makefile.   Because  this file  is
tangled along with the full Makefile, it simply gets tacked onto the end of the
big Makefile as an additional rule.   Now, running ~make~ runs the default rule
from the  main Makefile, which is  to extract everything, then  export to TEXI,
INFO, HTML, and PDF forms.

It is assumed that an Emacs server is running, and that the $EDITOR environment
variable is set to use ~emacsclient~.

#+name:boot-template
#+header: :tangle Makefile
#+begin_src makefile
boot:
	$(EDITOR) -u --eval \
		"(with-current-buffer (car (find-file-noselect \"./*.org\" nil nil t)) \
			(goto-char (point-min)) \
			(re-search-forward \"^#[+]name:preprocess.el$$\") \
			(org-babel-tangle (quote (4))) \
                        (save-buffer) \
			(kill-buffer))"
	./tools/preprocess.el
#+end_src

** Preprocess Env Vars
The environment variable DEV can be  in different locations and will be spelled
differently based  on how the  local machine is set  up.  For instance,  on one
system,  it will  be at  ~$HOME/Dev~  while in  another  system it  will be  at
~/usr/local/dev~.  However, the =:tangle= keyword  does not expand variables in
the form ~${DEV}~,  but rather requires absolute  paths, like ~/usr/local/dev~.
Therefore, this program works like a preprocessor for environment variables set
up  as part  of  =:tangle= lines,  changing them  to  their system  environment
variable values prior to tangling.  It lives in the ~tools~ directory.

#+name:preprocess.el
#+header: :mkdirp t
#+header: :tangle tools/preprocess.el
#+header: :shebang "#!/opt/local/bin/emacs -Q --script"
#+begin_src emacs-lisp
  (with-current-buffer (car (find-file-noselect "./*.org" nil nil t))
    (save-excursion
    (goto-char (point-min))
    (let ((re-search-str "\\(?::tangle\\|load-file \\(?:[\\]*\\)?[\"]\\)\s*\\(.*?/[dD]ev\\)/")
          (dev (getenv "DEV")))
      (while
              (re-search-forward re-search-str nil t)
              (replace-match dev t nil nil 1)))
    (save-buffer)
    (require 'org)
    (org-babel-tangle)))
#+end_src

** Samples
#+begin_comment
(cd "~/Dev/Emacs/MasteringEmacs/")
"/Users/pine/Dev/Emacs/MasteringEmacs/"

(defun add-bucket (org bucket)
  "Add a bucket keyword BUCKET to the org file ORG."
  (interactive "fFile: \nsBUCKET: ")
  (with-current-buffer (find-file-noselect org)
    (let* ((tree (org-element-parse-buffer))
	   (ins (car (org-element-map tree (quote section)
		 (lambda (s)
		   (org-element-map s (quote keyword)
		     (lambda (kw) (when (equal "MACRO" (org-element-property :key kw)) (1- (org-element-property :end kw))))
		     nil nil :keyword))
		 nil t nil nil))))
      (goto-char ins)
      (insert (format "#+bucket:%s\n" bucket))
      ())))

(add-bucket "MasteringEmacs.org" "pinecone-forest")
nil

(defun hl-region (raw-hl)
  "Obtain the begin and end positions for a headline."
  (with-current-buffer (find-file-noselect (getenv "SYNC_ORG_TEMPLATE"))
    (let* ((tree (get-parsed-tree))
	   (hl (car-safe (org-element-map tree 'headline
			   (lambda (hl) (when
					    (string= raw-hl
						     (org-element-property :raw-value hl))
					  (org-element-context)))
			   nil nil t))))
      (cons
       (org-element-property :begin hl)
       (org-element-property :end hl))
      )))

(hl-region "Build Tools")

(4888 . 29646)

(defun get-hl-with-prop (org-dir hl-prop)
  "Given a directory containing an Org template file and a custom_id property name, return the headline containing that custom_id, or nil if none."
  (progn
    (cd org-dir)
    (let ((org-buf (car-safe (find-file-noselect "*.org" nil nil t))))
      (if org-buf
	  (with-current-buffer org-buf
	    (let ((tree (org-element-parse-buffer)))
	      (org-element-map tree 'headline
		(lambda (hl)
		  (let ((cid (org-element-property :CUSTOM_ID hl)))
		    (when (string= hl-prop cid)
		      (and
		       (message (format "Found the headline %s containing property %s." (org-element-property :raw-value hl) hl-prop))
		       hl))))
		nil t)))
	(and
	 (message (format "The directory %s does not contain an Org file." org-dir))
	 nil)))))

(get-hl-with-prop "~/Dev/Templates/Org" "build-tools")

(headline (:raw-value "Build Tools" :begin 4888 :end 29646 :pre-blank 0 :contents-begin 4902 :contents-end 29645 :level 1 :priority nil :tags nil :todo-keyword nil :todo-type nil :post-blank 1 :footnote-section-p nil :archivedp nil :commentedp nil :post-affiliated 4888 :FROM-FILE "Template" :CUSTOM_ID "build-tools" :APPENDIX "t" :title "Build Tools"))









;;; Add a keyword named 'bucket' just after the version macro.
;;; This function should be run from within the directory containing the Org file.
(defun add-bucket (org-file s3-bucket)
  "Add the name of the associated AWS S3 bucket to an Org templated file."
  (with-current-buffer (find-file-noselect org-file)
    (goto-char (point-min))
    (let* ((tree (org-element-parse-buffer))
	   ;; find the beginning position of the first headline to act as a limit
	   (hl1 (org-element-map tree (quote headline) (lambda (hl) (org-element-property :begin hl)) nil t)))
      ;; Check for the presence of a bucket keyword before the first headline
      (unless (re-search-forward "^#\\+bucket:" hl1 t)
	;; If no bucket keyword is found, search for a keyword MACRO with the value 'version'
	(org-element-map tree (quote keyword)
	  (lambda (kw) (when (and (string= "MACRO" (org-element-property :key kw))
				  (string-match-p "version" (org-element-property :value kw)))
			 ;; return the end position of the MACRO; subtract an empty line if there is one
			 (goto-char (- (org-element-property :end kw) (org-element-property :post-blank kw)))
			 (insert "#+bucket:" s3-bucket)
			 (newline)
			 (basic-save-buffer)
			 (message (format "Added bucket %s" s3-bucket))))
	  nil t)))))

(add-bucket "MasteringEmacs.org" "pinecone-forest.com")
nil

"Added bucket pinecone-forest.com"









(keyword (:key "MACRO" :value "version Version 0.0.108" :begin 148 :end 181 :post-blank 1 :post-affiliated 148 ...))
("TITLE" "SUBTITLE" "AUTHOR" "DATE" "MACRO" "TEXINFO" "TEXINFO" "CINDEX" "CINDEX" "CINDEX" "CINDEX" "CINDEX" ...)







((keyword (:key "MACRO" :value "version Version 0.0.107" :begin 148 :end 181 :post-blank 1 :post-affiliated 148 ...)))
#+end_comment

* List of Programs
:PROPERTIES:
:appendix: t
:END:
#+texinfo:@listoffloats Listing

* List of Examples
:PROPERTIES:
:appendix: t
:END:
#+texinfo:@listoffloats Example

* Copying
:PROPERTIES:
:copying:  t
:END:

Copyright \copy 2020 by {{{author}}}


* Concept Index
:PROPERTIES:
:index: cp
:END:

* Program Index
:PROPERTIES:
:index: pg
:END:

* Function Index
:PROPERTIES:
:index: fn
:END:

* Variable Index
:PROPERTIES:
:index: vr
:END:


* Configuration							   :noexport:
#+todo: SOMEDAY(s@) TODO(t@) INPROGRESS(i@) WAIT(w@) | CANCEL(c@) DONE(d!)

#+options: H:4

#+texinfo_class: info
#+texinfo_header:
#+texinfo_post_header:
#+texinfo_dir_category:<DIR CATEGORY>
#+texinfo_dir_title:<DIR TITLE>
#+texinfo_dir_desc:<DIR DESCRIPTION>
#+texinfo_printed_title:LispLang---The Universe Known as LISP


* Footnotes

[fn:10] Also, the tremendous CommonSQL tutorial that Nick Levine gave at
ILC2002 is an excellent introduction to CLSQL. Even though his tutorial is
targetted towards Xanalys CommonSQL, the examples work equally well in CLSQL
(with the occasional minor tweak). 

[fn:1] Runtime Compilation: https://wiki.c2.com/?RuntimeCompilation

[fn:2] MetaObjectProtocol: https://wiki.c2.com/?MetaObjectProtocol

[fn:3]Recursive Functions of Symbolic Expressions and Their Computation by
Machine, Part I, by John McCarthy, April 1960 @
http://www-formal.stanford.edu/jmc/recursive/recursive.html.
Note: Part II never appeared.

[fn:4]The  name "Steel  Bank Common  Lisp" is  a reference  to Carnegie  Mellon
University Common Lisp from which SBCL forked: Andrew Carnegie made his fortune
in the steel industry and Andrew Mellon was a successful banker.

[fn:5]The libraries were last updated on July 15, 2020.

[fn:6]*namestring*:  a  string that  represents  a  filename using  either  the
standardized    notation    for    naming    logical    pathnames    or    some
implementation-defined notation for naming a physical pathname.

[fn:7]A stream  on which it  makes sense  to perform interactive  querying. The
general intent of having some streams be classified as /interactive/ streams is
to allow them to be distinguished  from streams containing batch (or background
or command-file) input. Output to batch streams is typically discarded or saved
for later  viewing, so interactive queries  to such streams might  not have the
expected effect.

[fn:8]In the browser, add =index.text= to the end of the URL to see the source.

[fn:9]Markdown requires the standard Perl library module Digest::MD5.

* Local Variables						   :noexport:
# Local Variables:
# fill-column: 79
# eval: (auto-fill-mode)
# time-stamp-pattern: "8/^\\#\\+date:%:y-%02m-%02d %02H:%02M$"
# End:

# -*- mode:org; -*-

#+title:The Universe Known as LISP
#+subtitle:{{{version}}} {{{date}}}
#+author:LOLH
#+date:2020-10-28 11:59
#+macro:version Version 0.0.40
#+macro:upload-date (eval (current-time-string))
#+bucket:pinecone-forest.com

{{{version}}} {{{date}}}

#+texinfo:@insertcopying


"CommonLisp, the  mud ball of strength,  [is] the acting patriarch  of the Lisp
family." (https://wiki.c2.com/?CommonLisp)

#+texinfo: @ifnothtml
[[./resources/images/MfcSJ3gl.jpg]]
#+texinfo: @end ifnothtml
#+texinfo: @ifhtml
[[../resources/images/MfcSJ3gl.jpg]]
#+texinfo: @end ifhtml
(https://wiki.c2.com/?SmugLispWeenie)


#+texinfo: @heading Creator of Organisms
#+attr_texinfo: :author Alan Perlis
#+begin_quote
"Pascal is for building pyramids  -- imposing, breathtaking structures built by
armies pushing heavy blocks into place. Lisp is for building organisms..."
#+end_quote
- https://www.cons.org/cmucl/


#+begin_quote
Alan Jay  Perlis (April 1,  1922 – February 7,  1990) was an  American computer
scientist and  professor at Purdue  University, Carnegie Mellon  University and
Yale  University. He  is  best known  for his  pioneering  work in  programming
languages   and    was   the   first    recipient   of   the    Turing   Award.
[fn::https://amturing.acm.org/award_winners/perlis_0132439.cfm]
#+end_quote

- [[https://web.archive.org/web/19990117034445/http://www-pu.informatik.uni-tuebingen.de/users/klaeren/epigrams.html][Alan Perlis' Epigrams]]


#+texinfo: @heading Local Optimum
#+attr_texinfo: :author John McCarthy, 1980
#+begin_quote
"LISP  has survived  for 21  years [61  years  as of  2020!] because  it is  an
approximate local optimum in the space of programming languages."
#+end_quote



- http://jmc.stanford.edu/articles/lisp20th.html
- [[http://jmc.stanford.edu/articles/index.html][Articles by John McCarthy]]


#+texinfo: @heading LISP: A Point of High Ground

#+attr_texinfo: :author Paul Graham in "The Roots of Lisp", May 2001
#+begin_quote
"It seems  to me that  there have been two  really clean, consistent  models of
programming so far:  the C model and  the Lisp model. These two  seem points of
high ground,  with swampy lowlands between  them. As computers have  grown more
powerful, the  new languages being  developed have been moving  steadily toward
the Lisp model. A  popular recipe for new programming languages  in the past 20
years has been to take the C model of computing and add to it, piecemeal, parts
taken from the Lisp model, like runtime typing and garbage collection."
#+end_quote

- [[http://www.paulgraham.com/articles.html][Essays by Paul Graham]]


#+texinfo: @heading Why Common Lisp for Scientific Programming?
- https://drmeister.wordpress.com

#+attr_texinfo: :author Christian Schafmeister, 2015-11-23, creator of CLASP
#+begin_quote
I’ve programmed  in many languages  and Common Lisp  is the best  at expressing
ideas. Every language  gets translated into an abstract syntax  tree on its way
to native code, Lisp  code is an abstract syntax tree.  There is no programming
concept that can’t  be expressed compactly in  Lisp, this is not  true in other
languages.  You  cannot  yet   express  multiple  dispatch  functions,  dynamic
variables  or Common  Lisp style  macros (a  few CL  features) compactly  in R,
Fortran, C++, or Python.

Why are R, Fortran, C++, or Python considered suitable for scientific
computing?

It is the wrong  question – those languages are just  the languages that people
started using and so they keep using them.  It is not a choice most people make
– it is inertia.

I choose Common Lisp.
#+end_quote

#+texinfo: @subheading About Christian Schafmeister
- https://drmeister.wordpress.com/about/

#+begin_quote
I’m a chemistry  professor who writes software to design  molecules that I hope
will make  the world a better  place. I’ve been  programming since I was  12, I
have  written code  in  a lot  of programming  languages  including Basic,  X86
assembler, Pascal,  Prolog, Fortran,  Smalltalk, TCL, PHP,  Python, C,  C++ and
Common Lisp....

I run  a research  group in  the Chemistry Department  at Temple  University in
Philadelphia, PA. We have developed a way to make the largest, most complex and
most “programmable” molecules outside of biology. We call them “spiroligomers”,
they are large, shape-programmable  and functional group programmable molecules
that  let  us  construct  molecules  that bind  proteins  as  therapeutics  and
accelerate chemical  reactions the way that  enzymes do. The goal  is to create
molecules  that  can do  everything  that  proteins can  do  in  nature but  be
designable and evolvable by human beings.
#+end_quote

#+texinfo: @heading The Power of Runtime Compilation

#+attr_texinfo: :author https://wiki.c2.com/?RuntimeCompilation (2005)
#+begin_quote
While there are projects to implement CL on top of a C compiler (see ECL), that
behaviour is  the exception,  not the  rule. There are,  however, very  good CL
compilers  (see  CMUCL for  a  free  one) which  will  compile  CL to  Assembly
Language, generally within a factor of 2  of a good optimizing C compiler. This
is  pretty amazing,  considering how  much more  power you  get in  CL compared
to  C.  To  put it  another  way:  a  lot  of  people like  languages  such  as
tcl/perl/python, because it's abstractions let  them code much faster than they
would in C. However, the "abstraction penalty", if you want to call it that, is
sometimes quite high, often a couple or  even three of orders of magnitude.  So
often people  optimize by  going back and  writing critical bits  in C  or C++,
which is  a bit of  a mess. With  CL, you get  more power and  abstraction than
these languages, and  with appropriately written code you can  have very little
penalty.  Why  this hasn't  sunk it for  more people I  am not  sure (actually,
that's a fib - I have some ideas). [[https://wiki.c2.com/?WhyNotLisp][(Why Not Lisp?)]]
#+end_quote


* Introduction to Lisp
:PROPERTIES:
:unnumbered: t
:END:

- Common Lisp :: https://wiki.c2.com/?CommonLisp

  Descended  from  one of  the  oldest  surviving programming  languages  (only
  Fortran is older),  CommonLisp is the first language  with integrated support
  for ObjectOrientedProgramming to get ANSI standardized.

  It  is a  rich  language with  clear semantics  which  allows programming  in
  procedural, functional, object oriented and logical (rule based) style all in
  the same program.

- Standardized Features ::
  - A well designed, well integrated object system (CLOS)
  - A well designed exception/condition handling mechanism
  - A not so easy to use/understand, but working, Package system
  - Support for Runtime Compilation[fn:1]
  - A MetaObjectProtocol (the MOP is supplied in most implementations)[fn:2]

- Common-Lisp :: https://common-lisp.net

  ``This site is one among many gateways to Common Lisp. Its goal is to provide
  the  Common Lisp  community  with  development resources  and  to  work as  a
  starting point for new programmers.''

  Common   Lisp   is   the  *modern*,   *multi-paradigm*,   *high-performance*,
  *compiled*,   *ANSI-standardized*,  most   prominent   (along  with   Scheme)
  descendant of the long-running family of Lisp programming languages.

  Common Lisp is  known for being extremely flexible,  having excellent support
  for object oriented  programming, and fast prototyping  capabilities. It also
  sports  an extremely  powerful macro  system that  allows you  to tailor  the
  language to your application, and a flexible run-time environment that allows
  modification and debugging of running applications (excellent for server-side
  development  and  long-running critical  software).  It  is a  multi-paradigm
  programming  language that  allows you  to choose  the approach  and paradigm
  according to your application domain.


LISP  was  originally  specified  in  1958 and  derives  its  name  from  =LISt
Processing= (or Lots of Insignificant Silly Parentheses).

[[http://www.maclisp.info][Maclisp]] is a dialect  of Lisp developed at MIT in 1966.  It added many features
that we  take for  granted in  Lisp today: functions  with variable  numbers of
arguments, macros, arrays,  and non-local dynamic exits. It  was influential on
the development of EmacsLisp, Scheme, ZetaLisp and CommonLisp. The first Scheme
interpreter and  the first Emacs  with Lisp facilities (see  MulticsEmacs) were
written in MacLisp.

- [[http://www.maclisp.info/pitmanual/index.html][The MacLISP Manual]]

- [[https://www.gnu.org/software/emacs/emacs-paper.html][EMACS: The Extensible, Customizable Display Editor (RMS 1981)]]
** What is Common Lisp?
Common  Lisp is  well  suited  to large  programming  projects and  explorative
programming. The language  has a dynamic semantics which  distinguishes it from
languages  such as  C  and Ada.  It features  automatic  memory management,  an
interactive  incremental  development environment,  a  module  system, a  large
number  of  powerful  data  structures,  a large  standard  library  of  useful
functions, a  sophisticated object  system supporting multiple  inheritance and
generic functions, an  exception system, user-defined types and  a macro system
which allows programmers to extend the language.

** The Roots of Lisp
*** John McCarthy and LISP
 - http://jmc.stanford.edu/articles/recursive.html


 #+texinfo: @heading Recursive Functions of Symbolic Expressions and Their Computation by Machine, Part I

 #+texinfo: @subheading This was the original paper on LISP.

 - http://jmc.stanford.edu/articles/recursive.html

 It is copied with  minor notational changes from CACM, April  1960. If you want
 the exact typography,  look there. A few typographical changes  have been made,
 but the notation  has not been modernized. There are  also some new explanatory
 footnotes. Part  II, which never appeared,  was to have had  some Lisp programs
 for algebraic computation.

 In  this  article,  we  first  describe  a  formalism  for  defining  functions
 recursively. We  believe this  formalism has advantages  both as  a programming
 language and  as a  vehicle for  developing a theory  of computation.  Next, we
 describe S-expressions and  S-functions, give some examples,  and then describe
 the universal S-function apply which plays  the theoretical role of a universal
 Turing machine and  the practical role of an interpreter.  Then we describe the
 representation of S-expressions in the memory of the IBM 704 by list structures
 similar to  those used  by Newell,  Shaw and Simon,  and the  representation of
 S-functions  by  program.  Then  we  mention the  main  features  of  the  LISP
 programming  system for  the  IBM 704.  Next comes  another  way of  describing
 computations  with  symbolic  expressions,  and finally  we  give  a  recursive
 function interpretation of flow charts.

 [[http://jmc.stanford.edu/articles/recursive/recursive.pdf][Download the article in PDF]]

*** Paul Graham's "The Roots of Lisp"

 - [[http://www.paulgraham.com/rootsoflisp.html][The Roots of Lisp, by Paul Graham]] January 18, 2002

(I  wrote  this  article  to  help  myself  understand  exactly  what  McCarthy
discovered. You don't need to know this stuff to program in Lisp, but it should
be helpful to anyone who wants to understand  the essence of Lisp — both in the
sense of its origins and its semantic core. The fact that it has such a core is
one  of  Lisp's distinguishing  features,  and  the  reason why,  unlike  other
languages, Lisp has dialects.) -- Paul Graham

 #+begin_quote
 Paul Graham's  The Roots of Lisp,  a cogent essay dealing  with John McCarthy's
 astonishing 1960's  paper[fn:3] which  introduced the  LISP language,  and more
 importantly, the functional model of programing.

 Graham stresses  his essay is  more important today  than ever, given  how more
 languages have  moved (albeit in a  piecemeal fashion) towards the  LISP model.
 Working with seven primitive operators, the paper shows how the entire language
 is built.  Most importantly, the paper  shows the LISP trademark,  how to write
 the language in itself.

 An interesting aspect  for Scheme programmers like myself is  the discussion of
 dynamic versus lexical scoping.

 Reading the paper reminds us of why functional languages, especially LISP based
 ones, aren't just the best for  expressing algorithms, but are the most elegant
 models  of  programming  since  the  are  easily  transcribed  in  mathematical
 notation.

 I can't  recommend The Roots  of Lisp enough. The  paper is available  for free
 download on Paul Graham's site.
 #+end_quote

 Posted by Robert D. Skeels * rdsathene Saturday, January 2, 2010 @
 http://tech-rdsathene.blogspot.com/search/label/Scheme

*** History of Lisp

- http://jmc.stanford.edu/articles/lisp.html


The history  of LISP according to  McCarthy's memory in 1978,  presented at the
ACM SIGPLAN History of Programming Languages Conference.

This  paper concentrates  on the  development of  the basic  ideas of  LISP and
distinguishes two  periods - Summer 1956  through Summer 1958 when  most of the
key ideas were  developed (some of which were implemented  in the FORTRAN based
FLPL), and Fall 1958 through 1962 when the programming language was implemented
and applied to problems of artificial intelligence. After 1962, the development
of LISP  became multi-stranded, and  different ideas were pursued  in different
places.

- [[http://jmc.stanford.edu/articles/lisp/lisp.pdf][Download the article in PDF.]]

*** LISP --- Notes on its Past and Future --- 1980

- http://jmc.stanford.edu/articles/lisp20th.html


This paper  was published in 1980.  I put it  up since it mostly  represents my
present opinions. There are some 1999 footnotes.

LISP has survived for 21 years because it is an approximate local optimum in
the space of programming languages. However, it has accumulated some barnacles
that should be scraped off, and some long-standing opportunities for
improvement have been neglected. It would benefit from some co-operative
maintenance especially in creating and maintaining program libraries. Computer
checked proofs of program correctness are now possible for pure LISP and some
extensions, but more theory and some smoothing of the language itself are
required before we can take full advantage of LISP's mathematical basis.LISP
has survived for 21 years because it is an approximate local optimum in the
space of programming languages. However, it has accumulated some barnacles that
should be scraped off, and some long-standing opportunities for improvement
have been neglected. It would benefit from some co-operative maintenance
especially in creating and maintaining program libraries. Computer checked
proofs of program correctness are now possible for pure LISP and some
extensions, but more theory and some smoothing of the language itself are
required before we can take full advantage of LISP's mathematical basis.

- [[http://jmc.stanford.edu/articles/lisp20th/lisp20th.pdf][Download the article in PDF.]]
*** Common Lisp --- The Untold Story
    :PROPERTIES:
    :author:   Kent M. Pitman
    :date:     2008
    :END:

This paper summarizes a talk given  at “Lisp50@OOPSLA,” the 50th Anniversary of
Lisp workshop, Monday, October 20, 2008, an event co-located with the OOPSLA’08
in Nashville, TN, in  which I offered my personal, subjective  account of how I
came to be involved with Common Lisp  and the Common Lisp standard, and of what
I learned from the process.
*** Lisp 1 Programmer's Manual
    :PROPERTIES:
    :author:   Phyllis Fox
    :date:     1960
    :END:
- http://history.siam.org/sup/Fox_1960_LISP.pdf

*** Lisp 1.5 Programmer's Manual
- http://www.softwarepreservation.org/projects/LISP/book/LISP%201.5%20Programmers%20Manual.pdf


By John McCarthy, Paul W. Abrahams, Daniel J. Edwards, Timothy P. Hart and
Michael I. Levin, 1962

#+texinfo: @heading Summary

The LISP language  is designed primarily for symbolic data  processing used for
symbolic calculations in differential and integral calculus, electrical circuit
theory,  mathematical  logic, game  playing,  and  other fields  of  artificial
intelligence. The manual  describes LISP, a formal  mathematical language. LISP
differs from most programming languages in  three important ways. The first way
is in the nature of the data. In the LISP language, all data are in the form of
symbolic  expressions  usually  referred  to as  S-expressions,  of  indefinite
length, and which have a branching  tree-type of structure, so that significant
subexpressions can  be readily isolated.  In the LISP  system, the bulk  of the
available  memory  is used  for  storing  S-expressions  in  the form  of  list
structures. The  second distinction  is that  the LISP  language is  the source
language  itself which  specifies  in  what way  the  S-expressions  are to  be
processed. Third, LISP  can interpret and execute programs written  in the form
of S-expressions. Thus, like machine language, and unlike most other high level
languages, it can be used to generate programs for further executions.

** Essays About Lisp
*** What's Wrong With Lisp
    :PROPERTIES:
    :author:   Robert Standh
    :END:
- http://metamodular.com/Essays/wrong.html


Contrary to what the title says,  we don't think there is anything particularly
wrong with  the Lisp programming  language. However,  a large number  of people
seem  to  have very  strong  and  very  strange  reactions to  this  particular
programming language.

I will ... attempt  to analyze some commonly recurring criticism  of Lisp in an
attempt to shed some light on the question and why it is often asked.

Today,  it is  a modern,  multi-paradigm language  which has  perhaps the  most
sophisticated  features of  all general-purpose  languages in  use (the  object
system, macros,  reader macros, conditions,  etc, etc). The first  question one
might ask is then "If Lisp is so good, why is it not more popular?". People who
ask such  a question typically assume  that "good" implies "popular",  and thus
look for some part of Lisp that is  NOT good, which would explain why it is not
popular. However, there  is absolutely no reason to assume  that "good" implies
"popular", so the question is really quite naive.

\dots

Lisp is not THAT unpopular (and now I will include Emacs Lisp for convenience).
In a  recent line count, Lisp  came in as number  4 when it comes  to number of
source lines of code (SLOC) in the Debian GNU/Linux (Woody) distribution, after
C, C++, and  shell with some 4  million SLOC (around 4%),  before Perl, Python,
ML, Fortran, etc.

\dots

Lisp is sufficiently different from what most people already know and expect in
a programming language, that they just aren't  willing to make the effort. In a
different  essay,  I  called  these people  "performance  oriented",  and  they
(unfortunately) make up the vast majority  of people in general, though perhaps
disproportionally so in software developers.  To summarize that essay, they are
simply victims of an incredibly strong  psychological force (that exist to some
degree in all  of us) that makes  the person attempt to  explain away something
new as being bad or useless, just in  order to avoid the hard work of having to
learn it.  The stranger  the new thing  is (like Lisp),  the harder  the victim
estimates the work to learn it, and the more important it becomes to declare it
bad or useless.

\dots

Why should all that counts in a programming language be popularity?

I often see the  very revealing parallel drawn between Lisp  and a fine violin.
Should we alter violins in order to  attract people who are used to playing the
accordion, and who are  not willing to learn the violin because  it is too hard
and too different from the accordion? Of  course not! The violin has its place,
and is a great instrument when played by someone who really masters it. Lisp is
a great  programming language  when used by  someone who knows  how to  use it.
Dumbing it down to attract mediocre performance-oriented programmers would be a
grave mistake.
*** Lisp---Good News Bad News How to Win Big
    :PROPERTIES:
    :author:   Richard P. Gabriel
    :date:     1991
    :END:

#+texinfo: @heading Abstract
Lisp has done quite well over the last ten years: becoming nearly standardized,
forming  the basis  of a  commercial sector,  achieving excellent  performance,
having good environments, able to  deliver applications. Yet the Lisp community
has  failed to  do as  well as  it  could have.  In this  paper I  look at  the
successes, the failures, and what to do next.
*** Parenthetically Speaking (with Kent M. Pitman)
- http://www.nhplace.com/kent/PS/About-PS.html


Parenthetically Speaking expresses opinions and  analysis about the Lisp family
of languages. Except as explicitly  indicated otherwise, the opinions expressed
are those of  the author and do not necessarily  reflect the official positions
of any organization or company with which the author is affiliated.
*** Alan Kay’s advice to computer science students
    :PROPERTIES:
    :date:     2018-11-09
    :author:   Mark Miller
    :cite:     https://tekkie.wordpress.com/2018/11/09/alan-kays-advice-to-computer-science-students/
    :END:
#+texinfo: @heading Tekkie
- https://tekkie.wordpress.com/2018/11/09/alan-kays-advice-to-computer-science-students/
- by Mark Miller, Nov 9, 2018

"I’m once again going to quote a Quora answer verbatim, because I think there’s
a lot of value in it. Alan Kay answered /What book(s) would you recommend to a
computer science student?/"

#+attr_texinfo: :author Alan Kay
#+begin_quote
My basic answer is: read a lot outside of the computer field.

It is worth trying to understand what “science” means in “Computer Science” and
what “engineering” means in “Software Engineering”.

“Science” in its  modern sense means trying to reconcile  phenomena into models
that are as  explanatory and predictive as possible. There  can be “Sciences of
the Artificial”  (see the important  book by Herb Simon).  One way to  think of
this is that if people (especially engineers) build bridges, then these present
phenomena for  scientists to understand  by making models.  The fun of  this is
that  the science  will almost  always  indicate new  and better  ways to  make
bridges, so  friendly collegial relationships between  scientists and engineers
can really make progress.

An example in  computing is John McCarthy thinking about  computers in the late
50s, the really large  range of things they can do (maybe  AI?), and creating a
model  of computing  as a  language that  could serve  as its  own metalanguage
(LISP).  MY FAVORITE  BOOK ON  THIS IS  “The Lisp  1.5 Manual”  from MIT  Press
(written by McCarthy et al.). THE FIRST PART OF THIS BOOK IS STILL A CLASSIC ON
HOW TO THINK IN GENERAL, AND ABOUT COMPUTING IN PARTICULAR.

(A  later  book inspired  by  all  this is  “Smalltalk:  the  language and  its
implementation” (by  Adele Goldberg and  Dave Robson  — the “Blue  Book”). Also
contains a complete implementation in Smalltalk written in itself, etc.)

A still later  book that I like a  lot that is “real computer  science” is “The
Art of the  Metaobject Protocol” by Kiszales, Bobrow, Rivera,).  The early part
of this book especially is quite illuminating.

An early thesis  (1970) that is real computer science  is “A Control Definition
Language” by Dave Fisher (CMU).

Perhaps  my favorite  book about  computing might  seem far  afield, but  it is
wonderful  and the  writing  is wonderful:  “Computation:  Finite and  Infinite
Machines” by Marvin Minsky (ca 1967). Just a beautiful book.

To  help with  “science”,  I usually  recommend a  variety  of books:  Newton’s
“Principia” (the ultimate  science book and founding  document), “The Molecular
Biology of  the Cell”  by Bruce  Alberts, et  al. There’s  a book  of Maxwell’s
papers, etc.

You need to  wind up realizing that “Computer Science”  is still an aspiration,
not an accomplished field.

“Engineering” means “designing and building  things in principled expert ways”.
The level of this is very high for the engineering fields of Civil, Mechanical,
Electrical, Biological, etc. Engineering. These  should be studied carefully to
get the larger sense of what it means to do “engineering”.

To help  with “engineering” try  reading about the  making of the  Empire State
Building, Boulder Dam, the Golden Gate Bridge, etc. I like “Now It Can Be Told”
by  Maj Gen  Leslie  Groves (the  honcho  on the  Manhattan  Project). He’s  an
engineer, and this history  is very much not from the Los  Alamos POV (which he
also  was in  charge of)  but about  Oak Ridge,  Hanford, etc  and the  amazing
mobilization of  600,000 plus people  and lots of  money to do  the engineering
necessary to create the materials needed.

Then think about  where “software engineering” isn’t — again,  you need to wind
up realizing that “software engineering” in  any “engineering” sense is at best
still an aspiration not a done deal.

Computing  is  also a  kind  of  “media” and  “intermediary”,  so  you need  to
understand what these do for us and to us. Read Marshall McLuhan, Neil Postman,
Innis, Havelock,  etc. Mark Miller (comment  below) just reminded me  that I’ve
recommended “Technics  and Human Development,”  Vol. 1 of Lewis  Mumford’s “The
Myth  of  the  Machine” series,  as  a  great  predecessor  of both  the  media
environment ideas and of an important facet of anthropology.

I don’t know of a great anthropology  book (maybe someone can suggest), but the
understanding of human beings is the most important thing to accomplish in your
education. In a  comment below, Matt Gaboury recommended  “Human Universals” (I
think he means  the book by Donald  Brown.) This book certainly  should be read
and understood  — it  is not in  the same  class as books  about a  field, like
“Molecular Biology of the Cell”.

I like Ed Tufte’s books on “Envisioning Information”: read all of them.

Bertrand Russell’s  books are  still very  good just  for thinking  more deeply
about “this and that” (“A History of Western Philosophy” is still terrific).

Multiple points  of view  are the only  way to fight  against human  desires to
believe and create  religions, so my favorite current history  book to read is:
“Destiny Disrupted” by Tamim Ansary. He grew up in Afghanistan, moved to the US
at age 16, and is able to write  a clear illuminating history of the world from
the time of Mohammed from the point  of view of this world, and without special
pleading.
#+end_quote

* Common Lisp Implementations
- [[https://www.cliki.net/Common%20Lisp%20implementation][Cliki Comparison of Actively Developed Common Lisp Implementations]]
  - All the implementations provide an FFI and sockets interface
- [[https://en.wikipedia.org/wiki/Common_Lisp#Implementations][Wiki Common Lisp Implementations]]
- [[https://common-lisp.net/implementations]]
- [[http://web.archive.org/web/20161105160832/https://common-lisp.net/~dlw/LispSurvey.html][Daniel Weinreb Survey of Common Lisp Implementations (2010)]]
  - This paper is a November, 2007 (updated February, 2010) survey of Common
    Lisp implementations that are currently being actively maintained


Common Lisp comes in many different flavors, or implementations.

Common  Lisp   is  defined  by   its  standard---there  is  neither   a  single
implementation controlled  by a benevolent  dictator, as with Perl  and Python,
nor a canonical implementation controlled by  a single company, as with VB, C#,
and Java. Anyone who  wants to read the standard and  implement the language is
free to do so.

Changes to the standard have to be made in accordance with a process controlled
by  the  standards body  American  National  Standards Institute  (ANSI).  That
process is designed to keep any one entity, such as a single vendor, from being
able to  arbitrarily change the standard.  Thus, the Common Lisp  standard is a
contract  between any  Common  Lisp  vendor and  Common  Lisp programmers.  The
contract tells you  that if you write  a program that uses the  features of the
language  the way  they're described  in the  standard, you  can count  on your
program behaving the same in any conforming implementation.

On the other hand, the standard may not  cover everything you may want to do in
your programs---some  things were  intentionally left  unspecified in  order to
allow continuing  experimentation by implementers  in areas where  there wasn't
consensus about the  best way for the language to  support certain features. So
every implementation offers some features  above and beyond what's specified in
the standard. Depending  on what kind of programming you're  going to be doing,
it may make sense  to just pick one implementation that  has the extra features
you need and use that. On the other hand, if we're delivering Lisp source to be
used by  others, such as libraries,  you'll want--as far as  possible--to write
portable Common Lisp. For writing code  that should be mostly portable but that
needs facilities not  defined by the standard, Common Lisp  provides a flexible
way to write  code "conditionalized" on the features available  in a particular
implementation.

** CMU Common Lisp
- [[https://cmucl.org][CMUCL Home]]
- [[https://gitlab.common-lisp.net/cmucl/cmucl/-/wikis/home][CMUCL Wiki]]
- [[https://www.cons.org/cmucl/doc/index.html][CMUCL Documentation]]
- Current Released Version is [[https://cmucl.org/downloads/release/21d/][CMUCL 21d]] (12/08/2018) ([[https://gitlab.common-lisp.net/cmucl/cmucl/blob/master/src/general-info/release-21d.md][see release notes]])
- [[https://common-lisp.net/project/cmucl/downloads/snapshots/2020/04/][Latest Snapshot 2020-04]] issued on 2020-03-28 ([[https://common-lisp.net/project/cmucl/downloads/snapshots/2020/04/release-21e.md][see release notes]])
- [[https://common-lisp.net/project/cmucl/downloads/][Downloads]]
- [[https://gitlab.common-lisp.net/cmucl/cmucl/-/wikis/GitAndCmucl][Git and CMUCL]]
- [[https://www.cons.org/cmucl/FAQ.html][FAQ]]


*NOTE:* CMUCL does not appear to run on modern Mac systems as it is 32bit only.


CMUCL is a free, high performance implementation of the Common Lisp programming
language which  runs on most  major Unix platforms.  It mainly conforms  to the
ANSI Common Lisp standard. CMUCL provides:
- a sophisticated native code compiler;
- a powerful  foreign function interface;
- an  implementation of  CLOS, the  Common Lisp  Object System;  which includes
  multimethods;
- a  metaobject protocol;
- a source-level debugger and  code profiler; and
- an  Emacs-like editor implemented in Common Lisp.


#+texinfo: @heading Summary of Main Features
- Support for static arrays that are never moved by GC but are properly removed
  when no longer referenced.
- Unicode support, including  many of the most common external  formats such as
  UTF-8 and support for handling Unix, DOS, and Mac end-of-line schemes.
- native  double-double  floats  including  complex  double-double  floats  and
  specialized  arrays for  double-double floats  and and  complex double-double
  floats that give approximately 106 bits (32 digits) of precision.
- a  sophisticated  native-code compiler  which  is  capable of  powerful  type
  inferences, and generates code competitive in speed with C compilers.
- generational  garbage collection  and multiprocessing  capability on  the x86
  ports.
- a foreign function interface which allows  interfacing with C code and system
  libraries, including shared libraries on most platforms, and direct access to
  Unix system calls.
- support for interprocess communication and remote procedure calls.
- an  implementation of  CLOS, the  Common Lisp  Object System,  which includes
  multimethods and a metaobject protocol.
- a  graphical  source-level debugger  using  a  Motif  interface, and  a  code
  profiler.
- an interface  to the X11 Window  System (CLX), and a  sophisticated graphical
  widget library (Garnet).
- programmer-extensible input and output streams.
- an Emacs-like editor implemented in Common Lisp.
- freely redistributable

** Steel Bank Common Lisp
- http://www.sbcl.org
- [[http://www.sbcl.org/manual/index.html][SBCL Manual]]


A branch from CMUCL. "Broadly speaking, SBCL  is distinguished from CMU CL by a
greater  emphasis on  maintainability.  SBCL  does not  use  an interpreter  by
default; all expressions  are compiled to native code unless  the user switches
the interpreter on. The SBCL compiler generates fast native code according to a
previous version of The Computer Language Benchmarks Game.

- SBCL ::
  - Steel Bank Common Lisp[fn:4]
  - In doubt, just get [[http://www.sbcl.org/platform-table.html][SBCL]]
  - Articulate Lisp also [[http://articulate-lisp.com/implementations/summary.html][recommends SBCL]] for beginners
  - A high performance Common Lisp compiler and runtime system
  - provides  an interactive  environment  including  a debugger,  a
    statistical  profiler,  a code  coverage  tool,  and many  other
    extensions
  - [[http://www.sbcl.org/manual/index.html][SBCL 2.0.8 User Manual]]

*** Running and Stopping SBCL
To run SBCL type =sbcl= at the command  line. You should end up in the toplevel
REPL (read,  eval, print  -loop), where  you can interact  with SBCL  by typing
expressions.

#+begin_example
▶ which sbcl
/opt/local/bin/sbcl

▶ sbcl
This is SBCL 2.0.7, an implementation of ANSI Common Lisp.
More information about SBCL is available at <http://www.sbcl.org/>.

SBCL is free software, provided as is, with absolutely no warranty.
It is mostly in the public domain; some portions are provided under
BSD-style licenses.  See the CREDITS and COPYING files in the
distribution for more information.
,* 
#+end_example

SBCL can be stopped at any  time by calling ~sb-ext:exit~, optionally returning
a specified numeric value to the calling process.

By default  SBCL also  exits on end  of input, caused  either by  user pressing
=Control-D= on an attached terminal, or end of input when using SBCL as part of
a shell pipeline.

**** SBCL as an inferior Lisp in Emacs

To run SBCL as an inferior-lisp from Emacs in your =.emacs= do something like:

#+begin_src elisp
;;; The SBCL binary and command-line arguments
(setq inferior-lisp-program "/opt/local/bin/sbcl --noinform")
#+end_src

=--noinform= suppress the printing of any banner or other informational message
at startup. This makes  it easier to write Lisp programs  which work cleanly in
Unix pipelines.

See [[http://www.sbcl.org/manual/index.html#Editor-Integration][Editor Integration]]

**** SBCL as a Shell Script
Standard Unix tools that are interpreters follow a common command line protocol
that is  necessary to work with  “shebang scripts”. SBCL supports  this via the
--script command line option.

#+name:hello.lisp
#+begin_src sh
#!/opt/local/bin/sbcl --script
(write-line "Hello, World!")
#+end_src

#+begin_example
$ ./hello.lisp
Hello, World!
$ sbcl --script hello.lisp
Hello, World!
#+end_example

** Clozure Common Lisp --- CCL
- https://ccl.clozure.com
- [[https://ccl.clozure.com/manual/][Clozure CL Documentation]]
- [[https://ccl.clozure.com/docs/ccl.html][CCL Manual (one page HTML)]]
- [[https://github.com/Clozure/ccl][CCL on GitHub]]
- [[https://ccl.clozure.com/openmcl-overview.pdf][Overview]]

"Clozure CL is a fast, mature, open source Common Lisp implementation that runs
on Linux, Mac OS X, FreeBSD, and Windows. Clozure CL was forked from Macintosh
Common Lisp (MCL) in 1998 and the development has been entirely separate
since."


Some  distinguishing features  of the  implementation include:
- fast compilation speed,
- native  threads,
- a precise, generational,  compacting garbage collector, and
- a convenient foreign-function interface.


Clozure CL is available for the following platforms:

- Mac OS X 10.6 and later (x86, x86-64)
- Linux (x86, x86-64, ppc32, ppc64, armv7l/armv6)
- FreeBSD (x86, x86-64)
- Solaris (x86, x86-64)
- Microsoft Windows XP and later (x86, x86-64)


- CCL ::
  - [[https://ccl.clozure.com][Clozure CL]]
  - Clozure CL compiles to native code and supports multithreading
    using native OS threads.
  - supports both Lisp code that calls external code, and external
    code that calls Lisp code.
  - Clozure CL can create standalone executables on all supported
    platforms.
  - A good implementation with very fast build times
  - fast compilation speed,
  - native threads,
  - a precise, generational, compacting garbage collector, and
  - a convenient foreign-function interface.
  - On Mac OS X, Clozure CL supports building GUI applications that
    use OS X's native Cocoa frameworks, and the OS X distributions
    include an IDE written with Cocoa, and distributed with complete
    sources.
  - On all supported platforms, Clozure CL can run as a command-line
    process, or as an inferior Emacs process using either SLIME or
    ILISP.
  - Documentation for CCL is written in a notation called [[https://github.com/Clozure/ccldoc][CCLDoc]].
  - [[https://ccl.clozure.com/docs/ccl.html][Clozure CL Manual]]

*** Running CCL

You should have a directory on your system named ~ccl~. This directory is
called the ~ccl directory~.

: /opt/local/share/ccl/<ver>

Clozure CL is made up of two parts:

- the lisp kernel ::

  The binary executable program that implements the lowest levels of the Lisp
  system.

- a heap image ::

  The  in-memory state  of a  running Lisp  system, containing  functions, data
  structures, variables, and  so on. Also, a file  containing archived versions
  of these data  in a format that  can be loaded and reconstituted  by the Lisp
  lisp kernel.


When the lisp kernel starts up, it locates the heap image, maps it into memory,
and starts running the lisp code contained  in the image. In the ccl directory,
you  will find  pre-built  lisp kernel  executables and  heap  images for  your
platform. The  heap images  have the  same basename  as the  corresponding lisp
kernel, but with an added ~.image~ suffix.

By default, the lisp kernel will look for a heap image with an appropriate name
in the same directory  that the lisp kernel itself is in.  Thus, it is possible
to start Clozure  CL simply by running ~./dx86cl64~ (or  whatever the appropriate
binary is called) directly from the ~ccl~ directory.

- OS X x86, x86-64 ::

  - ~dx86cl~, ~dx86cl.image~
  - ~dx86cl64~, ~dx86cl64.image~


If you  always run  Clozure CL  from Emacs, it  is sufficient  to use  the full
pathname of the lisp kernel binary directly.  That is, in your Emacs init file,
you could write something like:

: (setq inferior-lisp-program "/opt/local/share/ccl/1.12/dx86cl64")

or make the equivalent changes to =slime-lisp-implementations=, a list of known
Lisp implementations of the form:

: ((NAME (PROGAM PROGRAM-ARGS...) &key KEYWORD-ARGS) ...)
:
: ((ccl
:  ("/opt/local/share/ccl/1.12/dx86cl64"))
: (sbcl
:  ("/opt/local/bin/sbcl")
:  :coding-system utf-8-unix))


**** Running CCL from the Command-Line as a Script

It can also be handy to run Clozure  CL straight from a terminal prompt. In the
~scripts/~ directory of the ~ccl~ directory, there are two files named:

 - ~ccl~
 - ~ccl64~


Copy these files into ~/usr/local/bin~ or  some other directory that is on your
path, and then edit them so that the value of

: CCL_DEFAULT_DIRECTORY

is your ~ccl~ directory or add this environment variable to a startup file. You
can then start up the lisp by typing:

 : ccl
 or
 : ccl64

You may  wish to  install ~scripts/ccl64~ with  the name ~ccl~  if you  use the
64-bit lisp more. If you want the 32-bit  lisp to be available as well, you can
install  ~scripts/ccl~ as  ~ccl32~. Note  that there  is nothing  magical about
these scripts. You should feel free to edit them as desired.

*NOTE*: the  scripts start the kernel  using the shell's ~exec~  command, which
replaces  the current  process  with the  new ~ccl~  process.   The process  is
stopped using the:
: (ccl:quit) ; or
: (quit)
command, which  terminates the process.   If you  are running ~tmux~,  and have
only one window with one pane open, this instantly terminates that session, and
~tmux~ will exit.  There are two options to get around this.  One is not to use
~exec~.   The other  is to  have an  additional window  or pane  in the  ~tmux~
session, which will become current when the ~ccl~ process exits.

To obtain a list of available command-line options, type:
: ccl --help

**** The CCL Init File

By default, Clozure CL will look for a file named:

: ~/.ccl-init.lisp

in your home directory, and load it  upon startup. If you wish, you can compile
your init file,  and Clozure CL will  load the compiled version if  it is newer
than the  corresponding source file. Because  the init file is  loaded the same
way as normal Lisp  code is, you can put anything you want  in it. For example,
you can change the working directory, and load code that you use frequently.

To suppress the loading of this init-file, invoke Clozure CL with the:

: --no-init (or -n)

option.

*** CCLDoc Documentation System
- [[https://github.com/Clozure/ccldoc][CCLDoc on GitHub]]


CCLDoc is  a system for creating  Lisp documentation. It uses  S-expressions to
represent document structure, markup, cross  references, and contents. It has a
small number  of basic  operators, supports macros  for syntax  extensions, and
supports  a  simple syntax  for  embedding  expressions  in strings  for  added
convenience.

To use CCLDoc to format the CCL documentation, follow these steps:

1. Install CCL.
2. Install Quicklisp.
3. Check out the CCLDoc sources into =~/quicklisp/local-projects=


Now, start CCL, and do the following:

#+begin_src lisp
  (load "home:quicklisp;setup")
  (ql:quickload :ccldoc)
  (defparameter *d* (ccldoc:load-document "ccl:doc;manual;ccl.ccldoc"))
  (ccldoc::output-html *d* "/tmp/ccl.html" :stylesheet "ccl.css"
#+end_src

You can then view the generated ~ccl.html~ file in your browser. The generated
HTML expects to use a style file named ~ccl.css~ in the same directory.

There  is   also  a   not-quite-complete  LaTeX  converter.   To  use   it,  do
=(output-latex  *d*  "ccl.tex")=  and  then process  the  ~ccl.tex~  file  with
~xelatex~  to produce  a PDF  file. The  version of  ~xelatex~ that  comes with
MacTeX 2014 works.

*** CCL History
- 1984 :: Coral Software began the development of a Common Lisp for the
  Macintosh, called Coral Common Lisp (CCL).
- 1987 :: CCL 1.0 was released. It ran on a 1 MB Macintosh Plus.
- 1988 :: Coral  entered into a marketing relationship with  Franz, under which
  CCL was  renamed to Macintosh  Allegro Common  Lisp (MACL). That  didn't last
  long.
- 1988 ::  Coral was acquired  by Apple, who released  the Lisp under  the name
  Macintosh Common Lisp (MCL).
- 1994 ::  In the midst of  switching from the 68K  to the PowerPC CPU  for its
  Macintosh line, Apple transferred MCL to Digitool.
- 1995 :: Digitool completed the PowerPC port and released a PowerPC version of
  MCL.
- 1998  ::  Erann Gat  (now known  as Ron Garret)  of JPL  wanted to  develop a
  small-footprint Lisp  for use on  PowerPC-based robots and flight  systems. A
  source  license for  MCL was  acquired from  Digitool.  Gary  Byers ported  a
  version of the MCL compiler and runtime to VxWorks and LinuxPPC.
- 2007 ::  Alice  Hartley of Digitool announced that the  code for the original
  MCL would  be released  under an  open source license.   Largely in  order to
  avoid confusion  with this  newly open  sourced version  of MCL,  OpenMCL was
  renamed to Clozure CL.

** Armed Bear Common Lisp---JVM
- https://common-lisp.net/project/armedbear/
- [[https://github.com/slyrus/abcl][ABCL on GitHub]]


- Java has great GUI libraries
: <religious-statement>
:   but it's not the world's greatest programming language
: </religious-statement>

- Lisp on the other hand
: <religious-statement>
:   is the world's greatest programming language
: </religious-statement>
: but has no standard GUI libraries.

- Therefore:
: Write great applications using Java for your front-end GUI...
: backed with Lisp code and ...
: get the best of both worlds.


- ABCL ::
  - [[https://common-lisp.net/project/armedbear/][Armed Bear Common Lisp]]
  - A full implementation of the Common Lisp language
  - To interface with the JVM
  - features both an interpreter and a compiler, running in the JVM.
  - [[https://abcl.org/doc/abcl-user.html][User Documentation]]
  - [[https://abcl.org/releases/1.7.1/abcl-1.7.1.pdf][Armed Bear Common Lisp User Manual Version 1.7.1 July 2020]]
*** Install ABCL
- Go to [[https://abcl.org/][ABCL Home]] and download ABCL
- Build according to [[http://common-lisp.net/project/armedbear/doc/abcl-install-with-java.html][instructions]]
- or install using MacPorts: ~port install abcl~
- Add ~<abcl-dir>/dist/abcl.jar~ to your =CLASSPATH= for ABCL projects
- when installed with MacPorts, ~abcl.jar~ is at:
: /opt/local/share/java/abcl/abcl.jar

** GNU Common Lisp
- https://www.gnu.org/software/gcl/


- GNU Common Lisp ::
  - [[https://en.wikipedia.org/wiki/GNU_Common_Lisp][GNU Common Lisp]]
  - the GNU Project's ANSI Common Lisp compiler, an evolutionary
    development of Kyoto Common Lisp. It produces native object code
    by first generating C code and then calling a C compiler.

** CLISP
- https://clisp.sourceforge.io
- [[https://clisp.sourceforge.io/impnotes/clisp.html][CLISP Manual]]


- CLISP ::
  - [[https://clisp.sourceforge.io][CLISP Home]]
  - [[https://en.wikipedia.org/wiki/CLISP][GNU ANSI Common Lisp implementation]]
  - CLISP is an implementation of the programming language Common
    Lisp originally developed by Bruno Haible and Michael Stoll for
    the Atari ST

** CLASP---C++
- [[https://github.com/clasp-developers/clasp][CLASP on GitHub]]
- [[https://github.com/roswell/clasp][CLASP on Roswell on GitHub]]


"Bringing Common Lisp and C++ Together"

Clasp is an implementation of  Common Lisp primarily designed for compatibility
with C++-language programs and libraries.  Clasp conforms with the requirements
of =ANSI INCITS 226-1994= (R2004) with  some exceptions. Any deviation from the
standard  not   listed  there   is  a   bug,  and   should  be   reported  (see
"Contributing"). Clasp  is the project  of Dr. Christian  Schafmeister. Clasp's
source code is derived substantially from that  of [[*Embeddable Common Lisp---C][Embeddable Common Lisp]]. Code
from [[*Steel Bank Common Lisp][SBCL]] and SICL has been incorporated as well. Most notably, the compiler is
SICL's Cleavir compiler with some minor customizations.

Clasp is  a new Common  Lisp implementation that seamlessly  interoperates with
C++ libraries  and programs  using [[http://llvm.org][LLVM]]  for compilation  to native  code. This
allows Clasp  to take advantage  of a vast  array of preexisting  libraries and
programs, such as out of the  scientific computing ecosystem. Embedding them in
a  Common  Lisp environment  allows  you  to  make  use of  rapid  prototyping,
incremental  development,  and  other  capabilities that  make  it  a  powerful
language.

*** CLASP Manual
- https://github.com/clasp-developers/clasp/wiki/Manual

*** Build CLASP
- https://github.com/clasp-developers/clasp/wiki/Build-Instructions


#+texinfo: @heading MacOS installation of dependencies
While Clasp  requires a  specific release of  llvm and does  not use  the Xcode
version, it does use Xcode files.  You will need to first install Homebrew.

1. ~brew install cmake llvm@6 libffi bdw-gc gmp boost libunwind-headers sbcl~
2. git clone https://github.com/clasp-developers/clasp.git
3. If on mojave, after reinstalling xcode execute (from the gui):
   - ~/Library/Developer/CommandLineTools/Packages/macOS_SDK_headers_for_macOS_10.14.pkg~
     to get the headers in ~/usr/include/~
4. ~cd clasp~
5. ~./waf configure~; if ~./waf configure~ fails, see hint in linux instructions.
6. ~./waf build_cboehm~


The executables will be in ~clasp/build/boehm/cclasp-boehm~ and
~clasp/build/mps/cclasp-mps~

** Embeddable Common Lisp---C
- https://common-lisp.net/project/ecl/
- [[https://gitlab.com/embeddable-common-lisp/ecl/][ECL on GitLab]]
- [[https://common-lisp.net/project/ecl/static/manual/][ECL Manual]]


- Embeddable CL ::
  Compiles to C

** Spice List
- 

** Allegra Common Lisp

- Allegra CL ::
  Proprietary

** LispWorks

- LispWorks ::
  Proprietary

** SICL
- [[https://github.com/robert-strandh/SICL][SICL on GitHub]]


"A fresh implementation of Common Lisp"

SICL is a  new implementation of Common Lisp. It  is intentionally divided into
many  implementation-independent  modules that  are  written  in a  totally  or
near-totally portable way, so as  to allow other implementations to incorporate
these modules  from SICL,  rather than  having to  maintain their  own, perhaps
implementation-specific versions.

** Kyoto Common Lisp
- [[https://www.cs.cmu.edu/afs/cs/project/ai-repository/ai/lang/lisp/impl/kcl/0.html][KCL: Kyoto Common Lisp]]
- [[http://web.cecs.pdx.edu/~mperkows/=LISP/kcl][Frequently Asked Questions about KCL and AKCL]]
- https://en.wikipedia.org/wiki/Kyoto_Common_Lisp
- https://www.cs.cmu.edu/afs/cs/project/ai-repository/ai/lang/lisp/impl/kcl/kcl.faq
- http://www.aiai.ed.ac.uk/project/pub/packages/lisp/kcl/
- https://www.cs.cmu.edu/afs/cs/project/ai-repository/ai/lang/lisp/impl/kcl/kcl/broadcst.txt

* Common Lisp Documentation Resources
** Common Lisp Hyper Spec
 - https://wiki.c2.com/?CommonLispHyperSpec


 The  CommonLisp Hyperspec  is  an HTMLified  version of  the  ANSI Common  Lisp
 language standard  (X3.226-1994). You can  view it  online or download  it from
 Xanalys (formerly Harlequin) at:

 - http://www.lispworks.com/reference/HyperSpec/
** Common Lisp Cookbook
- [[http://cl-cookbook.sourceforge.net/index.html][The Common Lisp Cookbook home]]
- [[https://lispcookbook.github.io/cl-cookbook/getting-started.html][The Common Lisp Cookbook – Getting started]]


This is a  collaborative project that aims to provide  for Common Lisp
something similar to the Perl Cookbook published by O'Reilly

** Common Lisp The Language 2nd Edition
- http://www.cs.cmu.edu/afs/cs.cmu.edu/project/ai-repository/ai/html/cltl/clm/clm.html
- https://wiki.c2.com/?CommonLispTheLanguage
- [[https://www.cs.cmu.edu/Groups/AI/html/cltl/cltl2.html][Common Lisp the Language, 2nd Edition from CMU]]
- [[https://icem.folkwang-uni.de/~finnendahl/cm_kurse/doc/cltl2/cltl2.html][Common Lisp the Language, 2nd Edition]]
- Publisher: Digital Press; 2nd edition (June 15, 1990) ISBN 978-1555580414, ISBN 1555580416

** ANSI Common Lisp---Paul Graham
- http://www.paulgraham.com/acl.html
- Prentice Hall, 1995, 432 pages, paperback. ISBN 0133708756.
- https://wiki.c2.com/?AnsiCommonLisp


ANSI  Common  Lisp  combines  an   introduction  to  Lisp  programming,  and  a
convenient, up-to-date  reference manual for  ANSI Common Lisp.  Beginners will
find  that  its  careful  explanations   and  interesting  examples  make  Lisp
programming  easy  to  learn.  Professional  programmers  will  appreciate  its
thorough, practical approach.

*** Features

- An up-to-date reference manual for ANSI Common Lisp.
- An in-depth look at object-oriented programming. Explains the Common Lisp
  Object System (CLOS), and also shows how to write your own object-oriented
  language.
- Over 20 substantial examples, including programs for ray-tracing, text
  generation, pattern-matching, logical inference, generating HTML, sorting and
  searching, file I/O, compression, and date arithmetic.
- Special attention to critical concepts, including prefix syntax, code
  vs. data, recursion, functional programming, types, implicit pointers,
  dynamic allocation, closures, macros, class precedence, and generic functions
  vs. message-passing.
- A complete guide to optimization.
- The clearest and most thorough explanation of macros in any introductory
  book.
- Examples that illustrate Lisp programming styles, including rapid
  prototyping, bottom-up programming, object-oriented programming, and embedded
  languages.
- An appendix on debugging, with examples of common errors.

** Lisp Documentation Resources
 - Documentation :: https://common-lisp.net/documentation

 - QuickDocs :: http://quickdocs.org
   Ready and Up-to-Date Documentation for All Common Lisp Projects.

 - QuickRef :: https://quickref.common-lisp.net/index-per-library.html
   Reference manuals for Quicklisp libraries

 - Common Lisp in the Wild :: https://www.darkchestnut.com/book-common-lisp-application-deployment/

 - Books on CL :: https://cliki.net/Lisp+Books

 - The CL Cookbook :: https://lispcookbook.github.io/cl-cookbook/

 - The CL Ecosystem 2015 ::  https://borretti.me/article/common-lisp-sotu-2015

** Articulate Common Lisp
- http://articulate-lisp.com


How to write Common Lisp in 2018 - an initiation manual for the
uninitiated.

* Common Lisp Resources
** Lisp-Lang
- [[https://lisp-lang.org][Home]]
*** Recommended Libraries
- https://lisp-lang.org/wiki/article/recommended-libraries

** Common-Lisp dot Net
 - https://common-lisp.net


This site is one among many gateways to Common Lisp. Its goal is to
provide the Common Lisp community with development resources and to
work as a starting point for new programmers.

*** Getting Started in Common Lisp
 - https://common-lisp.net/downloads

*** Common Lisp Documentation
 - https://common-lisp.net/documentation

** Planet Lisp
- http://planet.lisp.org


Planet Lisp is  a meta blog that collects the  contents of various Lisp-related
blogs.

** CLiki
- https://cliki.net


CLiki  is a  Common  Lisp wiki  hosted  by The  Common  Lisp Foundation.  CLiki
contains resources for learning about and using the programming language Common
Lisp, and information about DFSG-compliant  free software implemented in Common
Lisp.

** Common Lisp Books
- https://wiki.c2.com/?DefinitiveCommonLispBooks

- [[http://metamodular.com/Common-Lisp/bibliography.html][Bibliography of documents related to Common Lisp]]

  - Peter Seibel, Practical Common Lisp ::

    This is an  excellent introduction to the Common Lisp  language. Instead of
    focusing on mechanisms the way most  other books do, this book is organized
    around practical examples related to contemporary problems.

  - Paul Graham, ANSI Common Lisp, Prentice Hall ::

    This book is  an introduction to the Common Lisp  programming language. The
    programming style of Paul  Graham is a bit different from  the one you will
    find in most  modern Common Lisp programs,  but this fact is  not likely to
    make a big difference to the debutant.

  - Paul Graham, On Lisp, Prentice Hall ::

    This book is  about advanced programming Common Lisp,  and specifically how
    to use the Common Lisp language  to create Domain Specific Languages (DSLs)
    using a technique called embedded  languages. This entire book is available
    as a free download.

  - Sonya E. Keene, Object-Oriented Programming  in Common Lisp, Addison Wesley ::

    The Common  Lisp object system (CLOS) is quite  different from, and more
    power than  that of  other object-oriented languages.  This books  gives an
    introduction to object-oriented  programming using CLOS. The book  is a bit
    old,  and this  is  particularly obvious  in the  examples  given, but  the
    mechanisms discussed have not changed, of course.

  - Peter  Norvig,  Paradigms  of  Artificial  Intelligence  Programming:  Case Studies in Common Lisp, Morgan Kaufmann  ::

    This  is a  very  good programming  book.  Peter Norvig  shows  how to  use
    advanced  features of  the  Common Lisp  language to  program  some of  the
    traditional problems  of Artificial Intelligence (search  problems, natural
    languages,  etc.), but  it is  definitely not  a book  about AI,  but about
    programming techniques, so  it is worth reading for everyone,  and not only
    for those who are interested in AI.

  - Gregor  Kiczales, Jim  des  Rivières,  Daniel G.  Bobrow,  The  Art of  the Metaobject Protocol ::

    In this book, the authors show how the Common Lisp Object System (CLOS) can
    be  defined in  a meta-circular  way, i.e.,  as an  object-oriented program
    using CLOS. Though this might sound like  a cute exercise with little or no
    practical use, this is definitely not the case, because that is in fact how
    CLOS  is written.  The  authors also  discuss  bootstrapping problems  that
    invariably occur with  such systems, and how these problems  were solved in
    their  implementation of  CLOS  called PCL.  The second  part  of the  book
    contains a complete  specification of CLOS, and that part  is available for
    free as online html.

  - David Touretzky, COMMON LISP: A Gentle Introduction to Symbolic Calculation ::

    The 1990 edition  of this book is available as download  for free. For a
    long time  it was out  of print, but  now it is  back in print  "with minor
    revisions".

  - Guy L. Steele, [[https://www.cs.cmu.edu/Groups/AI/html/cltl/cltl2.html][Common Lisp the Language, second Edition]] ::

    This book  is as close to  a reference manual  for Common Lisp at  it gets.
    Unfortunately,  the book  was  published before  the  Common Lisp  standard
    process was entirely finished, and there are some discrepancies between the
    contents of the book and what finally ended up in the standard. Having said
    that, I  think it  is a  great book, and  it explains  many things  in much
    greater depth than what the  HyperSpec is able to communicate. Furthermore,
    the entire books is available to download for free, or to consult as HTML.

*** Practical Common Lisp by Peter Seibel
- [[https://wiki.c2.com/?PracticalCommonLisp][About Practical Common Lisp]]
- [[http://www.gigamonkeys.com/book/][Practical Common Lisp in HTML]]

*** ANSI Common Lisp by Paul Graham
- [[https://wiki.c2.com/?AnsiCommonLisp][About ANSI Common Lisp]]
- https://courses.cs.northwestern.edu/325/readings/graham/graham-notes.html

*** Common Lisp---A Gentle Introduction to Symbolic Computation
- https://www.cs.cmu.edu/~dst/LispBook/book.pdf
- https://wiki.c2.com/?CommonLispaGentleIntroductionToSymbolicComputation
- http://www.cs.cmu.edu/~dst/LispBook/index.html

*** On Lisp by Paul Graham
- https://wiki.c2.com/?OnLisp
- http://www.paulgraham.com/onlisptext.html
- http://www.paulgraham.com/lisp.html

"This is simply the best book written about any computing topic that I
have ever come  across. Even if you  don't know lisp, you  can get the
general gist of this book and enjoy it."

*** Paradigms Of Artificial Intelligence Programming by Peter Norvig
- https://wiki.c2.com/?ParadigmsOfArtificialIntelligenceProgramming
- https://github.com/norvig/paip-lisp

*** Common Lisp, the Language 2nd Edition by Guy L. Steele, Jr.

Useful as  a reference book. However,  this isn't a good  tutorial for
learning CommonLisp--it assumes  that the reader is  familiar with the
language.

- https://wiki.c2.com/?CommonLispTheLanguage
- http://www.cs.cmu.edu/Groups/AI/html/cltl/cltl2.html
  This document contains the complete text of the book

*** The Common Lisp Cookbook
- https://lispcookbook.github.io/cl-cookbook/getting-started.html

*** Successful Lisp---How to Understand and Use Common Lisp
    :PROPERTIES:
    :author:   David Lamkins
    :cite:     http://ebixio.com/online_docs/SuccessfulLisp.pdf
    :END:
- [[http://ebixio.com/online_docs/SuccessfulLisp.pdf][Successful Lisp HTML]]

** Lisp Tutorials
*** Iwanna Learn Lisp
 - https://wiki.c2.com/?IwannaLearnLisp

*** Lisp Quickstart
 - https://cs.gmu.edu/~sean/lisp/LispTutorial.html


Lisp is a  deep language with many  unusual and powerful features.  The goal of
this tutorial is not to teach you  many of those powerful features: rather it's
to teach you just enough of Lisp that  you can get up and coding quickly if you
have a previous background in a procedural  language such as C or Java. Notably
this tutorial  does not teach  macros, CLOS,  the condition system,  much about
packages and symbols, or very much I/O.

**** Running Lisp
On your laptop you have several options for running Lisp:

- ~sbcl~
- ~clisp~
- ~ccl~

***** Run SBCL

#+begin_quote
$ sbcl

This is SBCL 2.0.9, an implementation of ANSI Common Lisp.
More information about SBCL is available at <http://www.sbcl.org/>.

SBCL is free software, provided as is, with absolutely no warranty.
It is mostly in the public domain; some portions are provided under
BSD-style licenses.  See the CREDITS and COPYING files in the
distribution for more information.
#+end_quote

***** Run CLISP
#+begin_quote
$ clisp

  i i i i i i i       ooooo    o        ooooooo   ooooo   ooooo
  I I I I I I I      8     8   8           8     8     o  8    8
  I  \ `+' /  I      8         8           8     8        8    8
   \  `-+-'  /       8         8           8      ooooo   8oooo
    `-__|__-'        8         8           8           8  8
        |            8     o   8           8     o     8  8
  ------+------       ooooo    8oooooo  ooo8ooo   ooooo   8

Welcome to GNU CLISP 2.49.92 (2018-02-18) <http://clisp.org/>
#+end_quote

***** Run CCL
#+begin_quote
$ ccl

Clozure Common Lisp Version 1.12  DarwinX8664

For more information about CCL, please see http://ccl.clozure.com.

CCL is free software.  It is distributed under the terms of the Apache
Licence, Version 2.0.
#+end_quote

**** Breaking Lisp
Pressing =Control-C=  in Lisp halts  whatever is presently running  and returns
you to the command line. After  you press =Control-C=, the command line changes
to a  "subsidiary" command line  to reflect  that you are  in a break  or error
condition. Kinda like pressing =Control-C=  in a debugger. These conditions can
be stacked: if you  keep working while in a condition, and  then get in another
condition and so on, you're piling up conditions on a stack.

#+begin_example
$ sbcl

,* (loop)
^C
debugger invoked on a SB-SYS:INTERACTIVE-INTERRUPT in thread
#<THREAD "main thread" RUNNING {1001890143}>:
  Interactive interrupt at #x52BB2ED0.

Type HELP for debugger help, or (SB-EXT:EXIT) to exit from SBCL.

restarts (invokable by number or by possibly-abbreviated name):
  0: [CONTINUE] Return from SB-UNIX:SIGINT.
  1: [ABORT   ] Exit debugger, returning to top level.

((LAMBDA ()))
   source: (PROGN)
#+end_example

#+begin_example
$ clisp

[1]> (loop)
^C
,** - Continuable Error
EVAL: User break
If you continue (by typing 'continue'): Continue execution
The following restarts are also available:
ABORT          :R1      Abort main loop
#+end_example

Just like in a  debugger, at any break or error condition, you  have a bunch of
options (like  examining the stack, changing  what the return value  should be,
etc.) You  can even continue the  infinite loop we  just broke out of.  But you
probably just  want to escape. The  easiest option is  to escape out of  all of
your error conditions, right back up to the top.

- SBCL :: In SBCL on your laptop, this is done by typing :top or :n (where n is
  the largest number presented to you -- here it's 1).

- CLISP :: In clisp on zeus, you'd type :R1
**** Quitting Lisp
Type ~(quit)~ to exit from Lisp.
*** Brief Guide to CLOS
- http://www.aiai.ed.ac.uk/project/pub/packages/lisp/random/clos-guide

** Planet SBCL
 http://planet.sbcl.org

 "Planet SBCL is a meta blog that collects the contents of various
 SBCL-related blogs. It was inspired by Planet Lisp."
** Common Lisp Application Software
https://github.com/azzamsa/awesome-cl-software

This is a list of awesome application software built with Common Lisp.

*** CL-Ledger
https://github.com/ledger/cl-ledger

CL-Ledger is a Common Lisp port of the [[http://ledger-cli.org/][Ledger]] double-entry accounting
system.
*** Brain
- http://www.aiai.ed.ac.uk/project/pub/packages/lisp/random/coherent.l

** CMU Common Lisp Repository
- http://www.cs.cmu.edu/afs/cs.cmu.edu/project/ai-repository/ai/lang/lisp/0.html

* Quicklisp Library Manager
https://www.quicklisp.org/beta/


Quicklisp is  a library manager  for Common Lisp.  It works with  your existing
Common Lisp  implementation to download,  install, and  load any of  over 1,500
[[https://www.quicklisp.org/beta/releases.html][libraries]] with a few simple commands.[fn:5]  It works with:

- ABCL,
- Allegro CL,
- Clasp,
- Clozure CL,
- CLISP,
- CMUCL,
- ECL,
- LispWorks,
- MKCL,
- SBCL, and
- Scieneer CL, on
- Linux,
- Mac OS X, and
- Windows.


QuickLisp depends on ASDF files to define Lisp "systems." A Lisp system is what
other languages call a  library or module, i.e., a set of files,  and a list of
any other systems that this system depends on.<

** QuickLisp Setup
To get started with the Quicklisp beta, download and load:
: https://beta.quicklisp.org/quicklisp.lisp

The following  command will  setup ~quicklisp~  for your  user account
using Clozure  Common Lisp  (CCL)[fn::Other implementations  will have
slightly different commandline requirements.]:

#+header: :dir ~
#+begin_src sh :exports code :results verbatim output
  [[ ! -d ".quicklisp" ]] && { \
  echo "Installing quicklisp...";
  mkdir -v ./.quicklisp;
  curl -O https://beta.quicklisp.org/quicklisp.lisp;
  echo "\n" | \
  ccl    --load  quicklisp.lisp \
         --eval '(quicklisp-quickstart:install :path "./.quicklisp")' \
         --eval '(ql:add-to-init-file)';
  rm quicklisp.lisp;
  echo "Done installing.";
  } || { echo "Quicklisp is already installed."; }
#+end_src

To load Quicklisp into your Common Lisp session after the initial installation,
(unless ~add-to-init-file~ has been run) load the file ~setup.lisp~:

: (load "~/quicklisp/setup.lisp")

To get updated software, use:

: (ql:update-dist "quicklisp")

To update the Quicklisp client, use:

: (ql:update-client)

** QuickLisp Libraries
To find out what's available in Quicklisp, use:

: (ql:system-apropos substring)

To see what systems depend on a particular system, use:

: (ql:who-depends-on system-name)

** QuickLisp Load
To load software, use:

: (ql:quickload "system-name")

Quicklisp will automatically download any  supporting software it needs to load
the system.

By default, ~ql:quickload~ hides most compilation and loading output, including
warnings, and shows progess as a series  of dots. You can show full compilation
and loading output by passing =:verbose t= as arguments to ~ql:quickload~. This
output can be especially helpful when reporting and troubleshooting problems.

** QuickLisp Unload
To remove software, use:

: (ql:uninstall system-name)

An uninstall does the following:

- Deletes the system's tarball archive and unpacked source files
- Deletes Quicklisp metadata files associated with the system
- Clears ASDF's system cache via asdf:clear-system.


Uninstalling does not alter  the current Lisp session in any  other way; if the
given  system has  been  loaded, it  remains loaded  and  accessible until  the
session is ended.

* Common Lisp IO
#+texinfo: @heading File System Concepts
This section  discusses the Common  Lisp interface  to file systems.  The model
used by this interface assumes that:

- files are named by filenames ([[a-file][files)]]
- a filename can be represented by a pathname object ([[a-filename][filename)]] ([[pathname--class][pathname]])
- given a pathname, a  stream can be constructed that connects  to a file whose
  filename it represents ([[a-stream][stream)]].


Pathnames and  namestrings[fn:6] are two  kinds of objects that  substitute for
filenames in Common Lisp ([[pathname--class][pathname class]])

** Files and Filenames

#+texinfo: @heading Files
A  ~file~   <<a-file>>  is  a  named   entry  in  a  file   system,  having  an
implementation-defined nature.

#+texinfo: @heading Filenames
#+cindex:filename
#+attr_texinfo: :options Handle filename
#+begin_deftp
<<a-filename>>
A  ~filename~ is  a handle,  not necessarily  ever directly  represented as  an
object, that can be used to refer to a file in a file system ([[a-file][file]])
#+end_deftp

<<truename-function>>
#+attr_texinfo: :options truename filespec => truename
#+begin_defun
~truename~ tries to  find the file indicated  by @@texinfo:@var{filespec}@@ and
returns its @@texinfo:@var{truename}@@.  If the filespec designator  is an open
stream, its associated file is used.

- ~FILESPEC~  ::   a  pathname  designator.  If filespec  is  a  /pathname/  it
  represents the name used to open the file

- ~TRUENAME~ :: a physical pathname
#+end_defun

*** Reading File Streams
    #+cindex:stream, file
    #+findex:open
The most basic file I/O task is to read the contents of a file.  To do so, you
obtain a stream from which you can read a file's contents.  You do this with
the ~open~ function.
#+caption:The Open Function
#+name:open
#+attr_texinfo: :options open filespec &key direction element-type if-exists if-does-not-exist external-format
#+begin_defun
~Open~ returns a character-based input stream that can be passed along to other
functions that read characters of text.

- ~FILESPEC~  ::   The name  of the file to read.  This can be  one of a string
  ("namestring"),  a pathname  object,  or a  stream  object, all  collectively
  called /pathname designators/. Pathnames  represent filenames in a structured
  way that  makes them easy  to manipulate without  tying them to  a particular
  filename syntax.

#+end_defun

** Pathnames and Pathspecs

#+cindex:pathname
<<pathname--class>>
#+attr_texinfo: :options {Structured Object} pathname
#+begin_deftp
A /pathname/ is a structured object which represents a filename.

There are two kinds of pathnames:

- physical pathnames ([[physical-pathname][physical pathname]])
- logical pathnames ([[logical-pathname][logical pathname]])
#+end_deftp

#+cindex:logical pathname
<<logical-pathname>>
#+attr_texinfo: :options Pathname {logical pathname}
#+begin_deftp
An object of type ~logical-pathname~.

A    /pathname/     that    uses     a    /namestring/    syntax     that    is
implementation-independent,   and   that   has  component   values   that   are
implementation-independent.  Logical   pathnames  do  not  refer   directly  to
filenames.
#+end_deftp

#+cindex:physical pathname
<<physical-pathname>>
#+attr_texinfo: :options Pathname {physical pathname}
#+begin_deftp
A pathname that is not a logical pathname.

An object of  type ~pathname~ is a  structured representation of the  name of a
file. A pathname has six components:

- host
- device
- directory
- name
- type
- version
#+end_deftp

#+attr_texinfo: :options pathname pathspec => pathname
#+begin_defun
Returns the @@texinfo:@var{pathname}@@ denoted by @@texinfo:@var{pathspec}@@.

- PATHSPEC ::  If the  @@texinfo:@var{pathspec}@@ designator  is a  file stream
  created   by   opening   a   logical  pathname,   a   logical   pathname   is
  returned.

- PATHNAME  ::  the  @@texinfo:@var{pathname}@@  returned  corresponds  to  the
  filename used to open the file.
#+end_defun

#+cindex:pathname designator
<<pathname-designator>>
#+attr_texinfo: :options Object {pathname designator} pathspec
#+begin_deftp
A designator for a pathname; that is, an object that denotes a pathname and
that is one of:

- pathname namestring[fn:6] (denoting the corresponding pathname)
- a stream associated with a file (denoting the pathname used to open the file)
- pathname (denoting itself)
#+end_deftp

** Streams
<<a-stream>>
#+attr_texinfo: :options Object stream
#+begin_deftp
A ~stream~ is  an object that can be  used with an input or  output function to
identify  an  appropriate source  or  sink  of  characters  or bytes  for  that
operation.

A stream can be a:

- character stream :: A character stream is a source or sink of characters.

- binary stream :: A binary stream is a source or sink of bytes.



A stream can be a/n:

- input stream :: source of data
- output stream :: sink for data
- bidirectional stream :: a stream that is both an input and an output stream.
- neither :: when =:direction-probe= is given to ~open~


A stream associated with a file is either:

- a file stream :: an object of class /file stream/ is used to represent a file
  stream. The  basic operation for  opening a  file is ~open~,  which typically
  returns a /file stream/. The basic operation for closing a stream is ~close~.

  #+findex:with-open-file
  The macro ~with-open-file~ is useful to express the common idiom of opening a
  file  for the  duration  of a  given  body  of code,  and  assuring that  the
  resulting stream is closed upon exit from that body.

- a synonym stream :: whose target is a stream associated with a file.


Such streams can be used as pathname designators (see
[[pathname-designator][pathname designator]]).

Normally,  when  a  stream  associated  with  a file  is  used  as  a  pathname
designator, it denotes the pathname used to  open the file; this may be, but is
not required to be, the actual name of the file.

Some  functions,  such  as  ~truename~ and  ~delete-file~,  coerce  streams  to
pathnames in a  different way that involves referring to  the *actual file that
is open*, which might or might not be the file whose name was opened originally
([[truename-function][truename function]]).

Streams are either:

- open ::  in general, operations that create and return streams return open
  streams.

- closed :: the action of closing a stream marks the end of its use as a source
  or sink of  data, permitting the implementation to reclaim  its internal data
  structures, and to  free any external resources which might  have been locked
  by the stream when it was opened.

  Coercion of streams to pathnames is permissible for closed streams;

#+end_deftp

*** Stream Subclasses
The class /stream/ has a number of subclasses defined by this specification.
The following are subclasses of /stream/.

- /broadcase-stream/ ::

  - ~make-broadcase-string~

  - ~broadcast-stream-streams~

- /concatenated-stream/ ::

  - ~make-concatenated-stream~

  - ~concatenated-stream-streams~

- /echo-stream/ ::

  - ~make-echo-stream~

  - ~echo-stream-input-stream~

  - ~echo-stream-output-stream~

- /string-stream/ ::

  - ~make-string-input-stream~

  - ~with-input-from-string~

  - ~make-string-output-stream~

  - ~with-output-to-string~

  - ~get-output-stream-string~

- /synonym-string/ ::

  - ~make-synonym-stream~

  - ~synonym-stream-symbol~

- /two-way-stream/ ::

  - ~make-two-way-stream~

  - ~two-way-stream-input-stream~

  - ~two-way-stream-output-stream~

*** Predefined Streams---Stream Variables

#+texinfo: @heading The Standardized I/O Customization Variables

#+cindex:stream variables
Variables whose values must be streams are sometimes called /stream variables/.

#+cindex:standardized i/o customization variables
These  variables are  collectively called  the /standardized  I/O customization
variables/.  They can  be bound  or  assigned in  order to  change the  default
destinations for input and/or output used by various standardized operators and
facilities.

  #+cindex:standard input
  #+vindex:*standard-input*
- =*standard-input*= ::

  implementation-dependent,  but it  must  be  an open  stream  that  is not  a
  generalized synonym stream  to an I/O customization variables  but that might
  be  a generalized  synonym  stream to  the value  of  some I/O  customization
  variable.

  The value of =*standard-input*=, called /standard input/, is a stream that is
  used by many  operators as a default  source of input when  no specific input
  stream is explicitly supplied.

  #+cindex:standard output
  #+vindex:*standard-output*
- =*standard-output*= ::

  The value of =*standard-output*=, called  /standard output/, is a stream that
  is  used by  many  operators as  a  default destination  for  output when  no
  specific output stream is explicitly supplied.

  #+cindex:error output
  #+vindex:*error-output*
- =*error-output*= ::

  The value  of =*error-output*=, called /error  output/, is a stream  to which
  warnings and non-interactive error messages should be sent.

  #+cindex:query i/o
  #+vindex:*query-io*
- =*query-io*= ::

  The value of  =*query-io*=, called /query I/O/, is a  bidirectional stream to
  be used when asking  questions of the user. The question  should be output to
  this stream, and the answer read from it.

  #+cindex:debug i/o
  #+vindex:*debug-io*
- =*debug-io*= ::

  The value  of =*debug-io*=, called  /debug I/O/, is a  stream to be  used for
  interactive debugging purposes.


*** Redirecting the Standard Output of your Program
    :PROPERTIES:
    :source:   http://cl-cookbook.sourceforge.net/io.html#bulk
    :END:

#+cindex:standard output, redirect
#+cindex:redirect standard output
To redirect the standard output of your program:

#+begin_src lisp
  (let ((*standard-output* <some form generating a stream>))
    ...)
#+end_src

#+cindex:dynamic variable
#+cindex:variable, dynamic
#+attr_texinfo: :author The Common Lisp Cookbook---I/O
#+begin_quote
Because  =*STANDARD-OUTPUT*= is  a  *dynamic variable*,  all  references to  it
during execution  of the body of  the =LET= form  refer to the stream  that you
bound it to. After exiting the =LET= form, the old value of =*STANDARD-OUTPUT*=
is restored,  no matter if  the exit was  by normal execution,  a =RETURN-FROM=
leaving  the  whole  function,  an   exception,  or  what-have-you.  (This  is,
incidentally, why global variables lose much of their brokenness in Common Lisp
compared to  other languages: since  they can be bound  for the execution  of a
specific form without the risk of losing  their former value after the form has
finished, their  use is quite  safe; they  act much like  additional parameters
that are passed to every function.)
#+end_quote

#+findex:with-open-file
To send the output to a file:

#+begin_src lisp
  (with-open-file (*standard-output* "somefile.dat" :direction :output
				     :if-exists :supersede)
    ...)
#+end_src

#+attr_texinfo: :author The Common Lisp Cookbook---I/O
#+begin_quote
~WITH-OPEN-FILE~  opens  the  file  ---  creating it  if  necessary  ---  binds
=*STANDARD-OUTPUT*=,  executes   its  body,  closes  the   file,  and  restores
=*STANDARD-OUTPUT*= to its  former value. It doesn't get  more comfortable than
this!
#+end_quote

#+attr_texinfo: :options with-open-file (stream filespec options*) declaration* form* => results
#+begin_defun
Uses   ~open~   to   create   a   /file    stream/   to   a   file   named   by
@@texinfo:@var{@@filespec@@texinfo:}@@.  When control  leaves the  body, either
normally or abnormally  (such as by use of ~throw~),  the file is automatically
closed. If a  new output file is being written,  and control leaves abnormally,
the file is aborted and the file system  is left, so far as possible, as if the
file had never been opened.

The keyword arguments to ~open~ specify  the characteristics of the file stream
that is returned, and how to handle errors.

- STREAM :: The stream object to which the stream variable is bound has dynamic
  extent; its extent ends when the form is exited.

- FILESPEC :: Filespec is the name of the file to be opened.

- OPTIONS    ::   are used as  keyword arguments to  ~open~:
  - =:direction= ::  one of =:input=, =:output=, =:io=, or =:probe=. The default
    is =:input=.

  - =:if-exists=    ::    one    of   =:error=,    =:new-version=,    =:rename=,
    =:rename-and-delete=, =:overwrite=, =:append=, =:supersede=, or =nil=.

  - =:if-does-not-exist=  :: one of =:error=,  =:create=, or =nil=. The default
    is:
    - =:error=  if direction  is  =:input= or  =if-exists=  is =:overwrite=  or
      =:append=;
    - =:create= if direction is =:output= or =:io=, and =if-exists= is neither =:overwrite=
       nor =:append=; or
    - =nil= when direction is =:probe=.

  - =:element-type= :: The default is =character=.

  - =:external-format= :: default is =:default=

- DECLARATION :: a declare expression; not evaluated.

- FORMS    ::    The  forms   are  evaluated  as   an  implicit   ~progn~  with
  @@texinfo:@var{@@stream@@texinfo:}@@ bound to the value returned by ~open~.

- RESULTS :: the values returned by the forms.
#+end_defun


#+texinfo:@heading Example

#+begin_lisp
(setq p (merge-pathnames "test"))
=>  #<PATHNAME :HOST NIL :DEVICE device-name :DIRECTORY directory-name
    :NAME "test" :TYPE NIL :VERSION :NEWEST>

 (with-open-file (s p :direction :output :if-exists :supersede)
    (format s "Here are a couple~%of test data lines~%")) =>  NIL

 (with-open-file (s p)
    (do ((l (read-line s) (read-line s nil 'eof)))
        ((eq l 'eof) "Reached end of file.")
     (format t "~&*** ~A~%" l)))

>>  *** Here are a couple
>>  *** of test data lines
=>  "Reached end of file."
#+end_lisp

*** Stream Functions
Some operations may be performed on any kind of stream; the following is a list
of standardized operations that are potentially useful with any kind of stream.

#+texinfo: @heading Some General-Purpose Stream Operations

- ~close~
- ~input-stream-p~
- ~output-stream-p~
- ~interactive-stream-p~
- ~stream-element-type~
- ~streamp~
- ~with-open-stream~

#+attr_texinfo: :options close stream &key abort => result
#+begin_defun
~close~ closes stream.  Closing a stream means  that it may no longer  be used in
input  or  output  operations. The  act  of  closing  a  file stream  ends  the
association between  the stream and  its associated file; the  transaction with
the file system  is terminated, and input/output may no  longer be performed on
the stream.

- STREAM :: a stream (either open or closed).

- ABORT ::  a boolean  with a  =false= default  value. If  abort is  =true=, an
  attempt is  made to clean  up any side effects  of having created  stream. If
  stream  performs output  to  a file  that  was created  when  the stream  was
  created,  the  file is  deleted  and  any  previously  existing file  is  not
  superseded.

#+end_defun

#+attr_texinfo: :options input-stream-p stream => boolean
#+begin_defun
#+texinfo: @defunx output-stream-p stream => boolean

~input-stream-p~ returns  =true= if stream is an input  stream; otherwise, returns
=false=.

~output-stream-p~ returns =true= if stream is an output stream; otherwise, returns
=false=.

#+end_defun

#+attr_texinfo: :options interactive-stream-p stream => boolean
#+begin_defun
Returns =true= if stream is an interactive stream[fn:7]; otherwise, returns
=false=.
#+end_defun

#+attr_texinfo: :options stream-element-type stream => typespec
#+begin_defun
~stream-element-type~  returns a  type specifier  that indicates  the types  of
objects that may be  read from or written to stream.  Streams created by ~open~
have an element type restricted to integer or a subtype of type character.
#+end_defun

#+attr_texinfo: :options streamp object => boolean
#+begin_defun
Returns =true= if object is of type stream; otherwise, returns =false=.
#+end_defun

#+attr_texinfo: :options with-open-stream (var stream) declaration* form* => results
#+begin_defun
~with-open-stream~ performs a series of operations on @@texinfo:@var{stream}@@,
returns a value, and then closes  the stream. @@texinfo:@var{Var}@@ is bound to
the  value of  @@texinfo:@var{stream}@@, and  then @@texinfo:@var{form}@@s  are
executed as an implicit ~progn~.

- VAR :: a variable name; bound to @@texinfo:@var{stream}@@.

- STREAM  :: a  form; evaluated  to produce  a stream.  The stream  has dynamic
  extent; its extent ends when the form is exited.

- DECLARATION :: a ~declare~ expression; not evaluated.

- FORM :: an implicit ~progn~.

- RESULTS :: the values returned by the @@texinfo:@var{form}@@s.


#+caption:Example of ~with-open-stream~
#+name:example-with-open-stream
#+begin_src lisp
(with-open-stream (s (make-string-input-stream "1 2 3 4"))
    (+ (read s) (read s) (read s))) =>  6
#+end_src
#+end_defun

*** Input Stream Functions
The following are operators relating to input streams:

- ~clear-input~
- ~listen~
- ~peek-char~
- ~read~
- ~read-byte~
- ~read-char~
- ~read-char-no-hang~
- ~read-delimited-list~
- ~read-from-string~
- ~read-line~
- ~read-preserving-whitespace~
- ~unread-char~

*** Output Stream Functions
The following are operators relating to output streams:

- ~clear-output~
- ~finish-output~
- ~force~output~
- ~format~
- ~fresh-line~
- ~pprint~
- ~prin1~
- ~prin1-to-string~
- ~princ~
- ~princ-to-string~
- ~print~
- ~terpri~
- ~write~
- ~write-byte~
- ~write-char~
- ~write-line~
- ~write-string~
- ~write-to-string~

*** Bidirectional Functions
Any of the operators listed above under *Input Stream Functions* and *Output
Stream Functions* can be used on bidirectional streams.  In addition, the
following operators relate specifically to bidirectional streams:

- ~y-or-n-p~
- ~yes-or-no-p~

*** Functions Taking Stream Arguments
**** Either Open or Closed Streams
These operators accept stream arguments that might be either open or closed
streams.

- ~broadcast-stream-streams~
- ~close~
- ~compile-file~
- ~compile-file-pathname~
- ~concatenated-stream-streams~
- ~delete-file~
- ~directory~
- ~directory-namestring~
- ~dribble~
- ~echo-stream-input-stream~
- ~echo-stream-ouput-stream~
- ~ed~
- ~enough-namestring~
- ~file-author~
- ~file-namestring~
- ~file-write-date~
- ~host-namestring~
- ~load~
- ~logical-pathname~
- ~merge-pathnames~
- ~namestring~
- ~open~
- ~open-stream-p~
- ~parse-namestring~
- ~pathname~
- ~pathname-match-p~
- ~pathnamep~
- ~probe-file~
- ~rename-file~
- ~streamp~
- ~synonym-stream-symbol~
- ~translate-logical-pathname~
- ~translate-pathname~
- ~truename~
- ~two-way-stream-input-stream~
- ~two-way-stream-output-stream~
- ~wild-pathname-p~
- ~with-open-file~

**** Open Streams
These opertors require open streams:

- clear-input
- clear-output
- file-length
- file-position
- file-string-length
- finish-output
- force-output
- format
- fresh-line
- get-output-stream-string
- input-stream-p
- interactive-stream-p
- listen
- make-broadcast-stream
- make-concatenated-stream
- make-echo-stream
- make-synonym-stream
- make-two-way-stream
- output-stream-p
- peek-char
- pprint
- pprint-fill
- pprint-indent
- pprint-linear
- pprint-logical-block
- pprint-newline
- pprint-tab
- pprint-tabular
- prin1
- princ
- print
- print-object
- print-unreadable-object
- read
- read-byte
- read-char
- read-char-no-hang
- read-delimited-list
- read-line
- read-preserving-whitespace
- stream-element-type
- stream-external-format
- terpri
- unread-char
- with-open-stream
- write
- write-byte
- write-char
- write-line
- write-string
- y-or-n-p
- yes-or-no-p
- 

* Common Lisp Help System
** Apropos
   #+findex:apropos
Common Lisp defines 978 symbols. There  are probably hundreds of others as well
for language extensions,  libraries, a graphical user interface,  etc. You will
not remember all  of the names, but  you will probably remember  parts of them.
Once you  have a good  guess at a  part of  the name, you  can find all  of the
matching names by using a tool called ~APROPOS~.

#+begin_src sh
$ sbcl
,* (apropos "MAP" :cl)
MAP (fbound)
MAP-INTO (fbound)
MAPC (fbound)
MAPCAN (fbound)
MAPCAR (fbound)
MAPCON (fbound)
MAPHASH (fbound)
MAPL (fbound)
MAPLIST (fbound)
#+end_src

#+begin_src sh
$ clisp
[1]> (apropos "MAP" :cl)
MAP                                        function
MAP-DEPENDENTS                             function
MAP-INTO                                   function
MAPC                                       function
MAPCAN                                     function
MAPCAR                                     function
MAPCON                                     function
MAPHASH                                    function
MAPL                                       function
MAPLIST                                    function
#+end_src

APROPOS expects a string or a symbol --- this provides the fragment of the name
that you’d like to find. An  optional second argument designates a package; use
it if you’d like  to limit your search to the symbols  in a particular package.
The package designator can be a string  or symbol matching the name or nickname
of a package  or it can be the  package object itself. If you  omit the package
designator, then APROPOS will search for symbols in all packages.

** Describe
   #+findex:describe
Once you know the name of a symbol, you can get additional information by using
the ~DESCRIBE~ function.

~DESCRIBE~ =object=  =stream= sends information  about an =object= to  a stream
(=standard-output= by default). =object= can be a symbol, string, or function.

~DESCRIBE~  prints,   to  the  stream  in   the  variable  =*standard-output*=,
information  about the  object. Sometimes  it will  describe something  that it
finds  inside   something  else;  such  recursive   descriptions  are  indented
appropriately. For instance,  ~DESCRIBE~ of a symbol will  exhibit the symbol's
value,  its   definition,  and  each   of  its  properties.  ~DESCRIBE~   of  a
floating-point number will exhibit its internal representation in a way that is
useful for tracking  down round-off errors and the like.  The nature and format
of the output is implementation-dependent.

The output  is sent  to the specified  stream, which defaults  to the  value of
=*standard-output*=; the stream may also be =nil= (meaning =*standard-output*=)
or  =t= (meaning  =*terminal-io*=). ~DESCRIBE~  is forbidden  to prompt  for or
require user input when given exactly one argument.

#+begin_src sh
$ sbcl

,* (describe 'mapl)
COMMON-LISP:MAPL
  [symbol]

MAPL names a compiled function:
  Lambda-list: (FUNCTION LIST &REST SB-IMPL::MORE-LISTS)
  Dynamic-extent arguments: positional=(0)
  Declared type: (FUNCTION ((OR FUNCTION SYMBOL) LIST &REST LIST)
                  (VALUES LIST &OPTIONAL))
  Derived type: (FUNCTION (T T &REST T) (VALUES T &OPTIONAL))
  Documentation:
    Apply FUNCTION to successive tuples of CDRs of LIST and MORE-LISTS.
    Return LIST.
  Known attributes: call, foldable
  Source file: SYS:SRC;CODE;LIST.LISP
#+end_src

** Inspect
   #+findex:inspect
~INSPECT~  is  an  interactive  version   of  ~DESCRIBE~.  The  nature  of  the
interaction is  implementation-dependent, but  the purpose  of ~INSPECT~  is to
make it easy to wander through  a data structure, examining and modifying parts
of it.

~INSPECT~  is like  ~DESCRIBE~,  but  instead of  printing  the information  it
presents the information in some  kind of interactive display; typically either
a  command loop  in the  current listener  or a  new window  with its  own user
interface.

Implementations are encouraged to respond to the  typing of =?= or a ``help key''
by providing help, including a list of commands.

** Documentation
   #+findex:documentation
The  generic   function  ~DOCUMENTATION~   returns  the   documentation  string
associated  with the  given object  if it  is available;  otherwise it  returns
=nil=.  The  ~DOCUMENTATION~ function  gives  you  access to  the  programmer’s
innermost thoughts.

The ~DOCUMENTATION~ function expects two arguments.  The first is an object for
which you wish  to retrieve documentation, or a symbol  naming that object. The
second is  a symbol designating the  kind of documentation (there  are several)
you wish to retrieve.

- variable :: defvar, defparameter, defconstant
- function :: defun, defmacro, special forms
- structure :: defstruct
- type :: deftype
- setf :: defsetf
- compiler-macro :: define-compiler-macro
- method-combination :: define-method-combination

* Common Lisp on Emacs
** Emacs Lisp
*** Emacs Lisp vs Common Lisp
Learning Emacs Lisp is useful and similar (but different from CL
- Dynamic scope is everywhere
- There are no reader (or reader-related) functions
- Does not support all the types that are supported in CL
- Incomplete implementation of CLOS (with the add-on EIEIO package)
- Not all of CL is supported
- No numerical tower support


Some good Emacs Lisp learning resources
- [[https://www.gnu.org/software/emacs/manual/eintr.html][An Introduction to Programming in Emacs Lisp]]
- [[http://www.oreilly.com/catalog/gnuext/][Writing Gnu Emacs Extensions]]
- [[http://wikemacs.org/wiki/Category:Emacs_Lisp][Wikemacs]]

*** Emacs Lisp Reference
- An Introduction to Programming in Emacs Lisp ::

    https://www.gnu.org/software/emacs/manual/html_node/eintr/index.html

    https://www.gnu.org/software/emacs/manual/pdf/eintr.pdf

    https://github.com/RenWenshan/emacs-lisp-intro-solutions

- Emacs Lisp Reference Wiki ::

    https://www.emacswiki.org/emacs/EmacsLispReference

- Learn Emacs Lisp ::

    https://www.emacswiki.org/emacs/LearnEmacsLisp

- Emacs Lisp Cookbook ::

    https://www.emacswiki.org/emacs/ElispCookbook

- Category Code ::

    https://www.emacswiki.org/emacs/CategoryCode
*** Lisp-Mode
Emacs Lisp Mode is enabled for any files ending in =.el= or when
editing the Emacs InitFile.
**** Evaluating Expressions in Lisp-Mode
- sexp :: any readable Lisp expression --- code enclosed in
  parentheses, a string enclosed in double quotes, a variable name, a
  quoted expression, a numeral, and so on.

- eval-last-sexp :: =[C-u] C-x C-e=

  This prints the value of the immediately-preceding sexp in the echo
  area. Using a prefix argument =C-u= will insert the result of an
  evaluation into the current buffer at point.

  To make ‘C-x C-e’ pretty-print:

  : (global-set-key [remap eval-last-sexp] 'pp-eval-last-sexp)

- eval-defun :: =C-M-x=

  This evaluates the defun at point. If the cursor is inside or
  immediately after a variable declaration, then this function, unlike
  ‘C-x C-e’, resets the variable to the value contained in the
  declaration.

- eval-expression :: =M-:=

  runs the command eval-expression. Evaluate EXP and print value in
  the echo area. When called interactively, read an Emacs Lisp
  expression and evaluate it. This is especially useful when you are
  coding and testing. It lets you quickly invoke non-interactive
  functions (non-commands).

  To make `M-:’ pretty-print:

  : (global-set-key [remap eval-expression] 'pp-eval-expression)

- eval-region :: =M-x eval-region=

  This evaluates the EmacsLisp code in the region. To evaluate all of
  the code in the current buffer, mark it using =C-x h= first.

- describe-variable :: =C-h v=

  Checks the current value of a variable. This prints the variable’s
  doc string and value.

- set-variable :: =M-x set-variable=

  Set user options.
**** Inferior Emacs Lisp Mode
- ielm :: =M-x ielm=

  Interactively evaluate Emacs Lisp expressions. This creates a buffer
  much like a shell buffer. Whatever Lisp expressions you type are
  evaluated and the result is printed into the buffer.

**** Lisp Interaction Mode
It is useful for evaluating EmacsLisp expressions. Typing ‘C-j’ after
an expression will print the result on the next line.
** Lisp Mode
*** ILISP Mode
A GNU Emacs Interface for Interacting with Lisp

[[http://www.inf.ufsc.br/~aldo.vw/func/ilisp/ilisp.html][ILISP]] is an interface from GNU Emacs to an inferior LISP.

ILISP is  a powerful GNU  Emacs interface to  many dialects of  Lisp, including
Lucid, Allegro,  Xanalys/Harlequin LispWorks,  GCL, KCL,  AKCL, ECL,  IBCL, and
CMUCL. Also some Scheme implementations are  supported as well as a preliminary
version of Xlisp/XlispStat.

ILISP was a package designed  to integrate various Lisp implementations (mostly
Common Lisp systems and various Scheme dialects) within Emacs (or XEmacs).

ILISP development stopped in 2004. You should use SlimeMode instead.
** SLIME Mode
http://www.common-lisp.net/project/slime/images2/slime-small.png

 - https://common-lisp.net/project/slime/
 - [[https://github.com/slime][SLIME on GitHub]]
 - [[https://common-lisp.net/project/slime/doc/html/][SLIME User Manual]]

 SLIME is an  Emacs mode for Common Lisp development.  SLIME extends Emacs with
 support for interactive programming in Common Lisp. While ~lisp-mode~ supports
 editing Lisp  source files, ~slime-mode~  adds support for interacting  with a
 running Common Lisp process  for compilation, debugging, documentation lookup,
 and so on.

- Provides REPL which is hooked to implementation directly in Emacs
- Has integrated Common Lisp debugger with Emacs interface
- Interactive object-inspector in Emacs buffer
- Has its own minor mode which enhances ~lisp-mode~ in many ways
- Supports every common Common Lisp implementation
- Symbol completion
- Cross-referencing
- Can perform macroexpansions


#+texinfo: @heading Featured Highlights

- Superior Lisp Interactive Mode for Emacs :: https://common-lisp.net/project/slime/

    "SLIME is an  Emacs mode for Common Lisp development.  Inspired by existing
  systems such as Emacs Lisp and ILISP, we are working to create an environment
  for hacking Common Lisp in."

- ~slime-mode~ ::
    An Emacs minor-mode to enhance lisp-mode with:
  - Code evaluation, compilation, and macroexpansion
  - Online documentation
    - =describe=
    - =apropos=
    - =hyperspec=
  - Definition finding
  - Symbol and package name completion
  - Automatic macro indentation based on =&body=.
  - Cross-reference interface

- SLDB ::
    Common Lisp debugger with an Emacs-based user interface

- REPL ::
    The Read-Eval-Print Loop ("top-level") is written in Emacs Lisp for
    tighter integration with Emacs.

- Compilation Notes ::
  SLIME  is able  to take  compiler messages  and annotate  them directly  into
  source buffers.

- Inspector ::
  Interactive object-inspector in an Emacs buffer.

- The currently supported Common Lisp implementations are ::
  - Steel Bank Common Lisp (SBCL) ::
    ~/opt/local/bin/sbcl~
  - Clozure Common Lisp (a.k.a. OpenMCL) (CCL) ::
    ~/usr/local/dev/bin/ccl~
  - CLISP ::
    ~/opt/local/bin/clisp~
  - Armed Bear Common Lisp (ABCL) ::
    ~/opt/local/bin/abcl~
  - Embedded Common Lisp (ECL) ::
    *NOTE*: fails to install using Xcode 12
  - CMU Common Lisp (CMUCL) ::
  - LispWorks ::
  - Allegro CL ::
  - Scieneer CL ::
  - Corman CL ::

*** Setting Up SLIME
 - ~inferior-lisp-program~ ::
   Point the =inferior-lisp-program= variable to your favourite Common
   Lisp implementation:
   : (setq inferior-lisp-program "sbcl")

 - slime-setup ::

   : (slime-setup '(slime-fancy slime-quicklisp slime-asdf))

*** Using Multiple LISPs in SLIME
To setup SLIME with multiple Lisp's configure the variable:

: slime-lisp-implementations

This variable holds a list of programs  and if you invoke SLIME with a negative
prefix argument,
: M-- M-x slime
you can select a  program from that list. When called  without a prefix, either
the name specified in
: slime-default-lisp
or the first item of the list will be used.

The elements of the list should look like:

: (NAME (PROGRAM PROGRAM-ARGS...) &key CODING-SYSTEM INIT INIT-FUNCTION ENV)

#+begin_src elisp
(setq slime-lisp-implementations
      '((ccl ("/opt/local/share/ccl/1.12/dx86cl64"))
        (sbcl ("/opt/local/bin/sbcl") :coding-system utf-8-unix)))
#+end_src

- NAME :: is a symbol and is used to identify the program.
- PROGRAM :: is the filename of the program.
- PROGRAM-ARGS :: is a list of command line arguments.
- CODING-SYSTEM :: the coding system for the connection. (see slime-net-coding-system)
- INIT ::
  should be  a function which takes  two arguments: a filename  and a character
  encoding. The  function should  return a  Lisp expression  as a  string which
  instructs Lisp to start the Swank server  and to write the port number to the
  file. At startup, SLIME starts the Lisp  process and sends the result of this
  function to Lisp’s standard input. As default, slime-init-command is used. An
  example is shown in Loading Swank faster.
- INIT-FUNCTION :: should be a function  which takes no arguments. It is called
  after the connection is established. (See also slime-connected-hook.)
- ENV :: specifies a list of environment variables for the subprocess. E.g.

  #+begin_src elisp
    (sbcl-cvs ("/home/me/sbcl-cvs/src/runtime/sbcl"
	       "--core" "/home/me/sbcl-cvs/output/sbcl.core")
	      :env ("SBCL_HOME=/home/me/sbcl-cvs/contrib/"))
  #+end_src

  initializes =SBCL_HOME= in the subprocess.

*** Running SLIME
 SLIME is started with the Emacs command:
 : M-x slime

 This uses the  inferior-lisp package to start a Lisp  process, loads and starts
 the Lisp-side  server (known as  “Swank”), and establishes a  socket connection
 between Emacs and  Lisp. Finally a REPL  buffer is created where  you can enter
 Lisp expressions for evaluation.

 To tell SLIME which Lisp program to run, add a prefix argument:
 : C-u M-x slime

 To choose from multiple Lisp programs, add a negative prefix:

 : M-- M-x slime

 - ~slime-close-all-parens-in-sexp~ :: =C-c C-]=

   Balance parentheses of open s-expressions at point.

 - ~slime-reindent-defun~ :: =C-c M-q=

   Reindent the current defun, or refill  the current paragraph. If the current
   defun  has unbalanced  parens, an  attempt  will be  made to  fix it  before
   reindenting.

 - ~slime-beginning/end-of-defun~ :: =M-C-a/e=

 - ~slime-compile-defun~ :: =C-c C-c=

 - ~slime-switch-to-output-buffer~ :: =C-c C-z=

   Switch to the REPL.
=
 - ~slime-load-file~ :: =C-c C-l=

   Load a lisp file.

 - ~slime-compile-and-load-file~ :: =C-c C-k=

   Compile and load the buffer’s file and highlight compiler notes.

*** SLIME Contrib Modules

SLIME’s functionalities live  in packages and so-called  =contrib= modules must
be loaded to add further functionalities. The default ~slime-fancy~ includes:
- slime-autodoc
- slime-c-p-c
- slime-editing-commands
- slime-fancy-inspector
- slime-fancy-trace
- slime-fontifying-fu
- slime-fuzzy
- slime-mdot-fu
- slime-macrostep
- slime-presentations
- slime-references
- slime-repl
- slime-scratch
- slime-package-fu
- slime-trace-dialog

**** Loading Contrib Packages
 In  version   2.1  the   developers  moved   some  functionality   to  separate
 packages. This chapter tells you how to load contrib modules and describes what
 the particular packages do.

 Contrib packages aren’t loaded by default. You  have to modify your setup a bit
 so that Emacs knows where to find them and which of them to load.

 - ~slime-contribs~ :: variable holding the  list of package-names that you want
   to use.  Its default value is ~slime-fancy~ which loads almost everything.  a
   setup  to load  the slime-scratch  and slime-editing-commands  packages looks
   like:

   : (setq slime-contribs '(slime-scratch slime-editing-commands))

   After starting SLIME, the commands of both packages should be available.

   If you want to  enable more contribs after you start SLIME,  you can set the
   ~slime-contribs~ variable to another value and call:
   : M-x slime-setup.

   Note that packages will not be unloaded if they are removed from the list,
   and if you have more than one SLIME connection currently active, you must
   manually repeat ~slime-setup~ for each of them.


 You can unload contrib packages by calling a function whose name is obtained by
 adding =-unload= to  the contrib’s name, for every contrib  you wish to unload.
 So, to remove ~slime-repl~, you must call ~slime-repl-unload~.

**** The SLIME REPL
 SLIME uses  a custom Read-Eval-Print  Loop (REPL).  The REPL  user-interface is
 written in Emacs Lisp, which  gives more Emacs-integration than the traditional
 comint-based Lisp interaction:
 - Conditions signalled in REPL expressions are debugged with SLDB.
 - Return values are  distinguished from printed output by  separate Emacs faces
   (colours).
 - Emacs manages the REPL prompt with  markers. This ensures that Lisp output is
   inserted in the right place, and doesn’t get mixed up with user input.


 Load the REPL:
 : (add-to-list 'slime-contribs 'slime-repl)

 Select the output buffer, preferably in a different window.
 : M-x slime-switch-to-output-buffer (C-c C-z)

 Insert a call to the function defined around point into the REPL.
 : M-x slime-call-defun (C-c C-y)

 Inserts the last expression to the REPL and evaluates it there.
 : M-x slime-eval-last-expression-in-repl (C-c C-j)

**** SLIME-Helm

SLIME also has some nice extensions like Helm-SLIME which features, among
others:
- Fuzzy completion,
- REPL and connection listing,
- Fuzzy-search of the REPL history,
- Fuzzy-search of the apropos documentation.

**** User-interface Conventions
 There are a few "global" user-interface conventions.

***** Temporary Buffers
 Some SLIME commands create temporary buffers to display their results.

 - Temporary buffers can be dismissed by pressing =q=.
 - Pressing =<RET>= is supposed to “do the most obvious useful thing.”
 - Temporary buffers containing Lisp symbols use ~slime-mode~ in addition to any
   special mode of their own.
 - ~slime-description-autofocus~ (default =nil=); determines which buffer gets
   the initial focus.

***** =*inferior-lisp*= Buffer
 SLIME internally uses the ~comint~ package to start Lisp processes.

 - The buffer =*inferior-lisp*= contains the  Lisp process’s own top-level. This
   direct access to Lisp is useful for troubleshooting, and some degree of SLIME
   integration is available using the ~inferior-slime-mode~.
 - Many people  load the  better integrated =SLIME  REPL= ~contrib~  module (see
   REPL) and ignore the =*inferior-lisp*= buffer.

* Scheme
- [[https://schemers.org][Schemers.org]]
- [[http://www.scheme.dk/planet/][Planet Scheme]]

- [[https://wiki.c2.com/?SchemeLanguage]]

- [[https://icem.folkwang-uni.de/~finnendahl/cm_kurse/doc/schintro/schintro_toc.html][An Introduction to Scheme and its Implementation]]

- [[https://icem.folkwang-uni.de/~finnendahl/cm_kurse/doc/t-y-scheme/t-y-scheme.html][Teach Yourself Scheme in Fixnum Days]]

Scheme is a  member of the Lisp  family of languages. Scheme  was introduced in
1975  by Gerald  J. Sussman  and Guy  L.  Steele Jr..  Scheme is  defined in  a
document called  The Revised^5  Report on the  Algorithmic Language  Scheme, or
R5RS for short. A newer report, R6RS, was released in 2007, but this report has
attracted considerable controversy, and a number of Scheme implementations have
chosen not  to be compliant  with it. Yet another  report was released  in 2013
("R7RS"), that was less ambitious than R6RS and more minimal.

Even though Scheme is consciously minimalist,  it is recognized that a language
must be more than a minimal core in order to be useful. Accordingly, the Scheme
community uses a  process known as `Scheme Requests  For Implementation' (SRFI,
pronounced `SUR-fee') to define new  language features. A typical Scheme system
therefore complies  with one  of the  Scheme reports  plus some  or all  of the
accepted SRFIs.

Scheme is a  statically scoped and properly tail-recursive dialect  of the Lisp
programming language invented  by Guy Lewis Steele Jr. and  Gerald Jay Sussman.
It was  designed to have  an exceptionally clear  and simple semantics  and few
different ways  to form expressions.  A wide variety of  programming paradigms,
including imperative,  functional, and message passing  styles, find convenient
expression in Scheme.

It was the first dialect of Lisp to fully support:

- lexical scoping
- first-class procedures
- continuations


In its earliest  form it was a very small  language intended primarily
for research  and teaching. Scheme  is now a  complete general-purpose
programming language, though  it still derives its power  from a small
set of key concepts.

There are two standards for Scheme: an official standard with IEEE and
a de facto one, often called  "RnRS", short for the Revised^nth Report
on  the  Algorithmic  Language  Scheme.  In  colloquial  use,  "Scheme
standard" usually refers to the latter.

** What are some differences between Scheme and Common Lisp?
- http://community.schemewiki.org/?scheme-faq-general


Scheme  is a  dialect of  Lisp that  stresses conceptual  elegance and
simplicity.  It  is  much  smaller  than  Common  Lisp;  the  language
specification is about  50 pages, compared to Common  Lisp's 1300 page
draft standard.  Advocates of  Scheme often find  it amusing  that the
entire  Scheme standard  is shorter  than  the index  to Guy  Steele's
"Common Lisp: the Language, 2nd  Edition". Unlike the Scheme standard,
the Common Lisp  standard has a large library of  utility functions, a
standard   object-oriented   programming   facility  (CLOS),   and   a
sophisticated condition handling system.

#+begin_quote
"Some people prefer to teach Scheme in introductory courses because it
is so  much smaller  than Common  Lisp. But one  can easily  teach the
subset of Common  Lisp that is equivalent to Scheme,  so language size
isn't really  an issue  for beginners. A  more compelling  argument is
that there is a certain style of applicative programming, making heavy
use  of lexical  closures, that  can  be expressed  more elegantly  in
Scheme syntax. But there are also  areas where Common Lisp is superior
to Scheme,  such as its support  for user defined macros,  its elegant
unification of lists and vectors into a sequence datatype, and its use
of keyword  arguments to  greatly extend the  utility of  the sequence
functions. The combination of tremendous power, extensive manufacturer
support,  and a  built-in  object-oriented  programming facility  make
Common  Lisp   the  only  industrial  strength   Lisp.  Although  this
book[fn:8] does emphasize a  side-effect-free, applicative approach to
programming with which Scheme afficionados will feel quite at home, it
does so in purely Common Lisp style."
#+end_quote
- https://wiki.c2.com/?CommonLispaGentleIntroductionToSymbolicComputation


#+texinfo: @heading Namespaces

#+attr_texinfo: :author Peter Seibel in Practical Common Lisp
#+begin_quote
In Common Lisp  a symbol can name both  an operator---function, macro,
or  special  operator---and a  variable.  This  is  one of  the  major
differences  between  Common  Lisp   and  Scheme.  The  difference  is
sometimes described as  Common Lisp being a Lisp-2 vs.  Scheme being a
Lisp-1---a Lisp-2  has two namespaces,  one for operators and  one for
variables, but  a Lisp-1  uses a single  namespace. Both  choices have
advantages, and partisans can debate endlessly which is better.
#+end_quote

#+texinfo: @heading The False Value

#+attr_texinfo: :author Peter Seibel in Practical Common Lisp
#+begin_quote
Not all Lisps handle boolean values  the same way. Another of the many
subtle differences upon which a good  Common Lisp vs. Scheme flame war
can rage  for days  is Scheme's  use of a  distinct false  value =#f=,
which isn't  the same value  as either the  symbol =nil= or  the empty
list, which are also distinct from each other.
#+end_quote

** Standardizations of Scheme
Scheme has been standardized both formally and informally.

*** IEEE Standard for the Scheme Programming Language
describes the formal ANSI/IEEE Standard for Scheme.

*** Revised Reports on the Algorithmic Language Scheme
The Revised6 Report on the Algorithmic Language Scheme

- [[http://people.csail.mit.edu/jaffer/r3rs_toc.html][R3RS]]

  LaTeX has changed  with time; it no longer works  from R3RS and R4RS
  source. For that  reason, this page doesn't have  links to r3rs.pdf,
  r3rs.ps, and r3rs.dvi. They could be produced by an old installation
  of LaTeX, or by modification of r3rs.tar.

  - [[http://groups.csail.mit.edu/mac/ftpdir/scm/r3rs.info.tar.gz][R3RS INFO]]
  - [[http://groups.csail.mit.edu/mac/ftpdir/scm/r3rs.txi][R3RS TEXINFO]]
  - [[http://groups.csail.mit.edu/mac/ftpdir/scheme-reports/r3rs.tar][R3RS LaTeX]]

- [[http://people.csail.mit.edu/jaffer/r4rs_toc.html][R4RS]]

  - [[http://people.csail.mit.edu/jaffer/r4rs.pdf][R4RS PDF]]
  - [[http://groups.csail.mit.edu/mac/ftpdir/scm/r4rs.info.tar.gz][R4RS INFO]]
  - [[http://groups.csail.mit.edu/mac/ftpdir/scm/r4rs.txi][R4RS TEXINFO]]
  - [[http://groups.csail.mit.edu/mac/ftpdir/scheme-reports/r4rs.tar.gz][R4RS LaTeX]]

- [[http://people.csail.mit.edu/jaffer/r5rs_toc.html][R5RS]]

  - [[http://people.csail.mit.edu/jaffer/r5rs.pdf][R5RS PDF]]
  - [[http://groups.csail.mit.edu/mac/ftpdir/scm/r5rs.info.tar.gz][R5RS INFO]]
  - [[http://groups.csail.mit.edu/mac/ftpdir/scm/r5rs.txi][R5RS TEXINFO]]
  - [[http://groups.csail.mit.edu/mac/ftpdir/scheme-reports/r5rs.tar.gz][R5RS LaTeX]]

- [[http://www.r6rs.org][R6RS]]

= [[https://small.r7rs.org/attachment/r7rs.pdf][R7RS]]

document an evolving informal standard that most implementations
support.

- http://people.csail.mit.edu/jaffer/Scheme

**** The Revised6 Report on the Algorithmic Language Scheme
http://www.r6rs.org

** The Scheme Family
   :PROPERTIES:
   :author:   Paul McJones
   :last-modified: 2020-04-20 10:10
   :END:
- http://www.softwarepreservation.org/projects/LISP/scheme_family/

*** Creation of Scheme
- [[ftp://publications.ai.mit.edu/ai-publications/pdf/AIM-349.pdf][SCHEME: An Interpreter for Extended Lambda Calculus]]
  - Gerald Jay Sussman and Guy Lewis Steele, Jr.
  - AI Memo No. 349, Artificial Intelligence Laboratory, Massachusetts
    Institute of Technology, December 1975
- [[http://www.softwarepreservation.org/projects/LISP/scheme_family/][LAMBDA: The Ultimate Imperative]]
  - Guy Lewis Steele, Jr. and Gerald Jay Sussman
  - AI Memo No. 353, Artificial Intelligence Laboratory, Massachusetts
    Institute of Technology, March 10, 1976
- [[ftp://publications.ai.mit.edu/ai-publications/pdf/AIM-379.pdf][LAMBDA: The Ultimate Declarative]]
  - Guy Lewis Steele, Jr.
  - AI Memo No. 379, Artificial Intelligence Laboratory, Massachusetts
    Institute of Technology, November 1976
- [[ftp://publications.ai.mit.edu/ai-publications/pdf/AIM-443.pdf][Debunking the "Expensive Procedure Call" Myth; or, Procedure Call
  Implementations Considered Harmful; or, LAMBDA: The Ultimate GOTO]]
  - Guy Lewis Steele, Jr.
  - AI Memo No. 443, Artificial Intelligence Laboratory, Massachusetts
    Institute of Technology, October 1977
- [[ftp://publications.ai.mit.edu/ai-publications/pdf/AIM-452.pdf][The Revised Report on SCHEME: A Dialect of LISP]]
  - Guy Lewis Steele, Jr. and Gerald Jay Sussman
  - AI Memo No. 452, Artificial Intelligence Laboratory, Massachusetts
    Institute of Technology, January 1978
- [[ftp://publications.ai.mit.edu/ai-publications/pdf/AIM-453.pdf][The Art of the Interpreter; or, The Modularity Complex (Parts Zero, One, and
  Two)]]
  - Guy Lewis Steele, Jr. and Gerald Jay Sussman
  - AI Memo No. 453, Artificial Intelligence Laboratory, Massachusetts
    Institute of Technology, May 1978
- [[ftp://publications.ai.mit.edu/ai-publications/pdf/AITR-474.pdf][RABBIT: A Compiler for SCHEME (A Study in Compiler Optimization)]]
  - Guy Lewis Steele, Jr.
  - Technical Report 474, Artificial Intelligence Laboratory, Massachusetts
    Institute of Technology, May 1978
- [[ftp://publications.ai.mit.edu/ai-publications/pdf/AIM-514.pdf][Design of LISP-based Processors; or, SCHEME: A Dielectric LISP, or Finite
  Memories Considered Harmful; or, LAMBDA: The Ultimate Opcode.]]
  - Guy Lewis Steele, Jr. and Gerald Jay Sussman
  - AI Memo No. 514, Artificial Intelligence Laboratory, Massachusetts
    Institute of Technology, March 1979
- [[ftp://publications.ai.mit.edu/ai-publications/pdf/AIM-848.pdf][The Revised Revised Report on Scheme; or, An UnCommon Lisp]]
  - William Clinger, editor
  - AI Memo No. 848, Artificial Intelligence Laboratory, Massachusetts
    Institute of Technology, August 1985
- [[https://dl.acm.org/doi/10.1145/15042.15043][Revised3 Report on the Algorithmic Language Scheme]]
  - Jonathan Rees and William Clinger, editors
  - SIGPLAN Notices Volume 21, Number 12, December 1986
- [[https://legacy.cs.indiana.edu/ftp/scheme-repository/][Revised4 Report on the Algorithmic Language Scheme]]
  - William Clinger and Jonathan Rees, editors
  - ACM Lisp Pointers Volume 4, Number 3, July 1991
- [[https://web.archive.org/web/20160322115236/http://cs.au.dk/~hosc/local/HOSC-11-1-pp7-105.pdf][Revised5 Report on the Algorithmic Language Scheme]]
  - https://schemers.org/Documents/Standards/R5RS/
  - Richard Kelsey, William Clinger, and Jonathan Rees, editors
  - Higher-Order and Symbolic Computation, Volume 11, Number 1, August 1998
- [[http://www.r6rs.org][The Revised6 Report on the Algorithmic Language Scheme]]
  - Michael Sperber et al.
  - September 26, 2007
- [[http://www.cs.cmu.edu/afs/cs/project/ai-repository/ai/lang/scheme/impl/rabbit/0.html][Scheme compiler written in Lisp, 1978]]
  - Guy L. Steele, Jr.
- [[http://www.cs.cmu.edu/afs/cs/project/ai-repository/ai/lang/scheme/doc/intro/intro.txt][The Scheme programming language]]
  - Ken Dickey
- [[http://www.cs.cmu.edu/afs/cs.cmu.edu/project/ai-repository/ai/lang/scheme/0.html][CMU Scheme Repository]]
  - [[http://www.cs.cmu.edu/afs/cs/project/ai-repository/ai/lang/scheme/bookcode/0.html][Machine readable parts of various Scheme books]]
  - [[http://www.cs.cmu.edu/afs/cs/project/ai-repository/ai/lang/scheme/code/0.html][Scheme code for benchmarking, research, education, and fun]]
  - [[http://www.cs.cmu.edu/afs/cs/project/ai-repository/ai/lang/scheme/doc/0.html][Documentation, including standards and proposals]]
  - [[http://www.cs.cmu.edu/afs/cs/project/ai-repository/ai/lang/scheme/edu/0.html][Educational Materials for Teaching/Learning Scheme]]
  - [[http://www.cs.cmu.edu/afs/cs/project/ai-repository/ai/lang/scheme/faq/0.html][Scheme FAQ: Frequently Asked Questions (FAQ) posting for comp.lang.scheme newsgroup]]
  - [[http://www.cs.cmu.edu/afs/cs/project/ai-repository/ai/lang/scheme/doc/macros/0.html][Proposals and implementations for macros in Scheme.]]
  - [[http://www.cs.cmu.edu/afs/cs/project/ai-repository/ai/lang/scheme/oop/0.html][OOP: Code related to object-oriented programming.]]
  - [[http://www.cs.cmu.edu/afs/cs/project/ai-repository/ai/lang/scheme/util/0.html][Utilities for programming in Scheme.]]
  - [[http://www.cs.cmu.edu/afs/cs/project/ai-repository/ai/lang/scheme/doc/bib/0.html][This directory contains several bibliographies related to work on Scheme.]]
  - [[http://www.cs.cmu.edu/afs/cs/project/ai-repository/ai/lang/scheme/doc/notes/0.html][Summaries and interesting notes about Scheme-related stuff.]]
  - [[http://www.cs.cmu.edu/afs/cs/project/ai-repository/ai/lang/scheme/impl/0.html][Free/Shareware Scheme implementations]]

** Resources on Scheme
*** [[schemers.org][schemers.org]]
The main resource for all things Scheme


This is a collection of resources for the Scheme programming language.
It was initiated by the PLT group at Rice University.
*** [[http://www.scheme.dk/planet/][Planet Scheme]]
Planet Scheme is a meta blog. Blog posts on Scheme are collected here.

*** Scheme FAQ
- http://community.schemewiki.org/?scheme-faq-general

*** RnRS
- http://people.csail.mit.edu/jaffer/Scheme

*** MIT Scheme
- http://groups.csail.mit.edu/mac/projects/scheme/

*** The Scheme Programming Language Third Edition 2003
- https://www.scheme.com/tspl3/
  - by R. Kent Dybvig (3rd ed. 2003)

This book is intended to provide an introduction to the Scheme
programming language but not an introduction to programming in
general. The reader is expected to have had some experience
programming and to be familiar with terms commonly associated with
computers and programming languages.

The author recommends that readers unfamiliar with Scheme or Lisp also
read _The Little Schemer_ to become familiar with the concepts of
- list processing and
- recursion.


This book covers everything in both standards.

This book is organized into nine chapters, plus appendices.

1. Chapter 1 describes the properties and features of Scheme that make
   it a useful and enjoyable language to use. Also describes Scheme's
   notational conventions and the typographical conventions employed
   in this book.

2. Chapter 2 is an introduction to Scheme programming for the novice
   Scheme programmer that leads the reader through a series of
   examples, beginning with simple Scheme expressions and working
   toward progressively more difficult ones.

3. Chapter 3 continues the introduction but covers more advanced
   features and concepts.

4. Chapter 4 describes operations for creating procedures and variable
   bindings.

5. Chapter 5, program control operations

6. Chapter 6, operations on the various object types (including lists,
   numbers, and strings);

7. Chapter 7, input and output operations;

8. Chapter 8, syntactic extension.

9. Chapter 9 contains a collection of complete example programs or
   packages, each with a short overview, some examples of its use, the
   implementation with brief explanation, and a set of exercises for
   further work. Each of these programs demonstrates a particular set
   of features, and together they illustrate an appropriate style for
   programming in Scheme.

10. Bibliography

11. Answers

12. Formal syntax

13. A concise summary of Scheme syntactic forms and procedures

14. Index
*** The Scheme Programming Language Fourth Edition 2009
https://www.scheme.com/tspl4/

*** The Little Schemer
Daniel P. Friedman and Matthias Felleisen. The Little Schemer, fourth
edition. MIT Press, 1996.

*** Simply Scheme---Introducing Computer Science 2nd Ed
- https://people.eecs.berkeley.edu/~bh/ss-toc2.html

*** PVTS
- http://davidpilo.com/pvts/


Visualize lists, pointers  and function calls in your code.  PVTS is a
visual interpreter for the Scheme functional programming languages.

*** Scheme-FAQ
- http://community.schemewiki.org/?scheme-faq

*** Structure and Interpretation of Computer Programs---SICP
- https://mitpress.mit.edu/sites/default/files/sicp/index.html

** Scheme Implementations
[[http://www.r6rs.org/implementations.html][R6RS Implementations]]

http://community.schemewiki.org/?category-implementations

*** List of Known Scheme Implementations
    :PROPERTIES:
    :last-modified: 2020-08-09 10:23:38
    :END:
- [[http://community.schemewiki.org/?scheme-faq-standards#implementations][What Scheme implementations are there?]]

  This  page holds  a list  of  known Scheme  implementations, in  alphabetical
  order.

*** Quick and Dirty List of Scheme Implementations
- [[http://community.schemewiki.org/?category-implementations][Here is a quick-and-dirty list of a very select number of Scheme implementations.]]


- Bigloo ::
  Compiles Scheme to C, JVM and .NET.
- Chez ::
  A very fast cross-platform native code compiler (commercial) along with a
  free interpreter.
- Chibi ::
  A very small library intended for use as an extension and scripting language
  in C programs.
- Chicken ::
  A Scheme->C compiler with a good FFI?.
- Cyclone ::
  A brand-new Scheme-to-C compiler that allows practical application
  development using R7RS Scheme.
- Elk ::
  A Scheme based extension language kit.
- Gambit ::
  Scheme->C compiler. Also compiles to Javascript and working on an universal
  backend (PHP, Python, Ruby, Asm).
- Gauche ::
  This wiki runs on it. A scripting language scheme interpreter with good
  Unicode support.
- Guile ::
  The GNU Scheme interpreter, designed to have good integration with C
  programs. A nice extension language.
- Ikarus ::
  R6RS Scheme incremental compiler to i32 and i64 native code.
- IronScheme ::
  R6RS Scheme for the .NET Framework.
- kali-scheme-revival ::
  A variant of Scheme48 for distributed computation.
- Kawa ::
  Runs on the JVM
- Larceny ::
  Is a simple and efficient R6RS runtime for scheme.
- LispMe ::
  R4RS Scheme, but for Palm Os
- Ocs ::
  An R5RS Scheme interpreter in OCaml.
- Pika-Scheme ::
  A new implementation currently in prerelease stage.
- PLT-Scheme ::
  PLT Scheme is an umbrella name for a family of implementations of the Scheme
  language - DrScheme, MzScheme, MrEd.
- Pocket-Scheme ::
  A scheme for WinCE based handhelds.
- RScheme ::
  Compiles to C, has Dylan-like OO features.
- Scheme48 ::
  The primary design goal was clarity and good design.
- Schoca ::
  A Scheme interpreter in Objective Caml.
- SCM ::
  Small and portable R5RS implementation. SLIB, by the same author, is nicelly
  integrated with SCM.
- SCSH ::
  The SCheme SHell, based on Scheme48. This adds a lot of very interesting
  facilities for POSIX system interfacing.
- SISC ::
  A Scheme interpreter in Java, making the whole Java library available to
  Scheme, and still being very fast (for an interpreter)
- SISCWeb ::
  The framework for creating web applications using the SISC interpreter.
- Stalin ::
  Scheme to C compiler
- STKlos ::
  A Scheme System with an Object System and TK integration
- T ::
  Is the name for an implementation and dialect of scheme
  - [[http://mumble.net/~jar/tproject/][T Project Web Site]]
  - [[http://web.archive.org/web/20070103020434/http://mumble.net/~campbell/t/t.html][T Revival Website]] (Last Updated Friday, 7th April, 2006)
  - T is a dialect of Scheme and its implementation. T originated from Yale. It
    is not compatible with R5RS.
- TinyScheme ::
  A lightweight Scheme interpreter
- Unlikely-Scheme ::
  An embeddable C++ implementation
- Ypsilon ::
  R6RS interpreter

*** Chez Scheme
 http://cisco.github.io/ChezScheme/

 Chez Scheme is both a programming language and an implementation of
 that language, with supporting tools and documentation. As a superset
 of the language described in the Revised6 Report on the Algorithmic
 Language Scheme (R6RS), Chez Scheme supports all standard features of
 Scheme, including first-class procedures, proper treatment of tail
 calls, continuations, user-defined records, libraries, exceptions, and
 hygienic macro expansion. Chez Scheme also includes extensive support
 for interfacing with C and other languages, support for multiple
 threads possibly running on multiple cores, non-blocking I/O, and many
 other features.

**** Chez Scheme User's Manual
 http://cisco.github.io/ChezScheme/csug9.5/csug.html

 Chez Scheme's additional language, run-time system, and programming
 environment features are described in the Chez Scheme User's Guide.

**** Open Source
 https://github.com/cisco/chezscheme
*** Guile Scheme
[[https://www.gnu.org/software/guile/][Guile]]

"Guile is  designed to  help programmers create  flexible applications
that  can be  extended by  users or  other programmers  with plug-ins,
modules, or scripts."

*** Chicken Scheme
- [[http://www.call-cc.org][Chicken Home]]
- [[http://wiki.call-cc.org/][Chicken Wiki]]
- [[http://api.call-cc.org/4/doc/][Search Chicken documentation]]

CHICKEN  Scheme  combines  an  optimising   compiler  with  a  reasonably  fast
interpreter.  It supports  almost  all of  R7RS and  the  important SRFIs.  The
compiler generates  portable C code  that supports tail  recursion, first-class
continuations  and  lightweight  threads,  and  the interface  to  and  from  C
libraries is  flexible, efficient,  and easy to  use. It runs  on Linux,  OS X,
Windows, many Unix flavours

CHICKEN is a compiler that translates Scheme source files into C, which in turn
can be fed to a C compiler  to generate a standalone executable. An interpreter
is also  available and can  be used as a  scripting environment or  for testing
programs  before  compilation. The  interpreter  allows  interactive use,  fast
prototyping, debugging, and scripting.

To invoke the CHICKEN interpreter, you use the ~csi~ command.

To run a script, add the following command header to the script file:
: #! /usr/local/bin/csi -script

The parameter ~command-line-arguments~ is set to  a list of the parameters that
were  passed to  the  Scheme  script. Scripts  can  be  compiled to  standalone
executables.

*** Gambit Scheme
- [[http://dynamo.iro.umontreal.ca/wiki/index.php/Main_Page][Gambit Home]]
- https://wiki.c2.com/?SchemeLanguage
- https://github.com/gambit/gambit/blob/master/INSTALL.txt

The  Gambit Scheme  system  is  a complete,  portable,  efficient and  reliable
implementation of the Scheme programming language.

*** MIT/GNU Scheme
- http://groups.csail.mit.edu/mac/projects/scheme/
- https://www.gnu.org/software/mit-scheme/
- [[https://www.gnu.org/software/mit-scheme/documentation/stable/mit-scheme-user/index.html][MIT/GNU Scheme 10.1.11]]
- [[http://www.cs.cmu.edu/afs/cs.cmu.edu/project/ai-repository/ai/lang/scheme/0.html][CMU Scheme Repository]]


MIT/GNU Scheme is a complete programming environment that runs on many unix
platforms and Windows.  It features a:

- interpreter
- native-code compiler
- rich runtime library
- powerful source-level debugger
- integrated Emacs-like editor

*** Kawa Scheme
[[https://www.gnu.org/software/kawa/][The Kawa Scheme Language]]
[[https://www.gnu.org/software/kawa/tutorial/index.html][Kawa Scheme Tutorial]]
[[https://gitlab.com/kashell/Kawa][Kawa on GitLab]]

Kawa is a general-purpose programming language that runs on the Java
platform.

- Runs on the Java platform, with no native code needed
- Extends the Scheme language, following the R7RS specification from 2013
- Programs run fast - roughly as fast as Java programs, and much faster than
  other “scripting languages”.
- Full, convenient, and efficient access to the huge set of Java libraries; you
  can access objects, methods, fields, and classes without run-time overhead.
- Start-up times are fast.
- Scripts are simple Kawa source files that can run as an application or
  command.
- You can embed Kawa as a scripting language for Java applications.
- Deployment is easy and flexible. You just need the Kawa jar file.
- Kawa provides the usual read-eval-print loop
- Kawa has builtin pretty-printer support, and fancy formatting.
- Kawa supports class-definition facilities, and separately-compiled modules.
- You can allocate  and initialize objects with a compact  “builder” syntax. It
  works out-of-the-box (with no run-time overhead)
- JavaFX programming is simpler.
- Flexible shell-like functionality, including process literals.
- Web page  scripts are  easy to  write and  install with  self-configuring web
  servers, optionally using servlets and XML literals.
- Arrays and sequences have a lot of flexibility
- Many useful features for mathematics and numerics
  - infinite-precision rational numbers and complex numbers.
  - Compile-time optimization of arithmetic with the use of type declarations
    and inference.
  - A quantity is a real number with a unit, such as 3cm.
  - Quaternions are a 4-dimensional generalization of complex numbers.
  - Unsigned primitive integer types (ubyte, ushort, uint, ulong) are
    implemented efficiently without object allocation.
- A lazy value wraps an expression which is evaluated only when it is needed.
- Kawa provides a framework for implementing other programming languages,
  - comes with incomplete support for CommonLisp, Emacs Lisp, and EcmaScript,
    and XQuery.

**** Installing Kawa Scheme
These instructions install the pre-compiled binary distribution. The
pre-compiled release is at:

- ftp://ftp.gnu.org/pub/gnu/kawa/kawa-3.1.1.zip


The binary release  comes as a ~.zip~  archive that includes Kawa  itself (as a
~.jar~  file  ~$KAWA_HOME/lib/kawa.jar~),  some third-party  helper  libraries,
~kawa~ command scripts (for GNU/Linux/Unix/MacOS or Windows), and documentation
(basically  this  manual).  The  ~.zip~  file unzips  into  a  directory  named
~kawa-3.1.1~ with ~lib~, ~bin~, and ~doc~ sub-directories. Place this directory
somewhere  suitable  and name  the  location  =KAWA_HOME=. The  binary  release
requires  Java 8  or later.  If you  want to  use Kawa  as part  of some  other
application, you just need the =$KAWA_HOME/lib/kawa.jar=.

**** Running Kawa Scheme
To  run a  Kawa  script file  or  the Kawa  read-eval-print-loop  run the  Kawa
application. There are various way to do  so. The recommended way is to execute
the $KAWA_HOME/bin/kawa  Bash shell  script. The script  assumes that  either a
suitable ~java~  program is in  your PATH;  or the =JAVA=  environment variable
names  a   suitable  ~java~   executable;  or  that   =JAVA_HOME=  is   set  so
=$JAVA_HOME/bin/java= is suitable.

Add the following to a startup script:
: export KAWA_HOME='/usr/local/kawa/kawa-3.1.1'
: alias kawaj='java -jar $KAWA_HOME/lib/kawa.jar'

The alias ~kawaj~ runs the ~kawa.jar~ directly, producing a repl.

Add the kawa ~bin~ directory to your =PATH= variable:
: export $KAWA_HOME/bin

To open the documentation manual as an html file, type:
: kawa --brownse-manual

**** Running Kawa Command Scripts
Use the following header command in your scripts:
: #!/usr/bin/env kawa

then make the program executable with:
: chmod +x <script>

and run it with:
: ./<script> <args...>

**** Sending Options to Kawa in a Command Script
If you need to  specify extra arguments to ~kawa~, you  can run arbitrary shell
commands inside Scheme block comments.

#+begin_src sh
#!/bin/sh
#|
exec kawa out:base=16 out:radix=yes "$0" "$*"
|#
(format #t "The command-line is:~{ ~w~}.~%" (command-line))
(display "It has ")
(display (apply + (map string-length (command-line))))
(display " characters.")
(newline)
#+end_src

The trick is to hide the shell code from Kawa inside a =#|...|#= block-comment.
The start of the block comment is a  line starting with a =#=, so it is treated
as a comment by  the shell. You can then invoke ~kawa~  (or ~java~ directly) as
you prefer,  setting up  class-path and  jars as  needed, and  passing whatever
arguments you want. You need to make  sure the shell finishes before it reaches
the end of the block comment or the Scheme code, which would confuse it.

Using comments this way  has the advantage that you have  the option of running
the script “manually” if you prefer:

#+begin_example
$ kawa /tmp/scm-echo out:base=8 "x y"
The command-line is: "/tmp/scm-echo" "out:base=8" "x y".
It has 26 characters.
#+end_example

**** Kawa Implementation of Asymmetric Encryption Keys Via KeyPairGenerator
- http://rdsathene.org/scheme/docs/kawa-example-exec-1.html


=AsymmetricKeyMaker=  is an  excellent example  for  several reasons.  It is  a
command line  program takes user  input and returns  a result. It  utilizes the
Java exception  system and gives us  an opportunity to deal  with both abstract
and concrete classes.

- Asymmetric Encryption Keys With the KeyPairGenerator
  - January 16, 2004
  - 'Core Java Technologies Tech Tips' article
  - https://www.java-tips.org/java-se-tips-100019/39-javax-crypto/915-asymmetric-encryption-keys-with-the-keypairgenerator.html


Example of standalone  executable program duplicating the  functionality of the
January  16,  2004  'Core  Java Technologies  Tech  Tips'  article  'Asymmetric
Encryption Keys With the KeyPairGenerator'. This example assumes the reader has
obtained their  own copy of  that document and will  reference it and  the Java
source for our  purpose of reproducing the functionality. It  is not reproduced
here due  to the  lengthy and confusing  amount of copyright  and terms  of use
information  Sun uses  on  all  their documentation.  The  Sun  source for  the
=AsymmetricKeyMaker= program  is 25 lines, so  we can reference things  by line
number.

#+begin_src lisp
; -*-scheme-*- Copyright © Robert D. Skeels 02/07/2004 <athene@earthlink.net>

(module-name <AsymmetricKeyMaker>)

(define-namespace key-pair-generator "class:java.security.KeyPairGenerator")

(define gen-keys
  (lambda (algorithm)
    (let* ((our-kpg (key-pair-generator:getInstance algorithm))
           (our-key-pair (invoke our-kpg 'generateKeyPair))
           (writeln (lambda (args) (display args) (newline))))
           (writeln (invoke our-key-pair 'getPublic))
           (writeln (invoke our-key-pair 'getPrivate)))))

(define try-gen-keys
  (lambda (algorithm)
    (try-catch (gen-keys algorithm)
        (ex <java.security.NoSuchAlgorithmException>
          (begin
          (display  "usage: java AsymmetricKeyMaker <RSA | DSA>")
          (newline))))))

(if (> (vector-length command-line-arguments) 0)
  (try-gen-keys (vector-ref command-line-arguments 0)))
#+end_src

#+begin_src java
KeyPairGenerator generator =
                 KeyPairGenerator.getInstance("RSA");
 generator.initialize(1024);
 KeyPair keyPair = generator.generateKeyPair();

import java.security.KeyPairGenerator;
 import java.security.NoSuchAlgorithmException;
 import java.security.KeyPair;

 public class AsymmetricKeyMaker {

    public static void main(String[] args) {
      String algorithm = "";
      if (args.length == 1) algorithm = args[0];

      try {
        KeyPair keyPair = KeyPairGenerator
                             .getInstance(algorithm)
                             .generateKeyPair();

        System.out.println(keyPair.getPublic());
        System.out.println(keyPair.getPrivate());

      } catch (NoSuchAlgorithmException e) {
        System.err.println(
          "usage: java AsymmetricKeyMaker <RSA | DSA>");
      }

    }
 }
#+end_src

**** JEmacs---The Java/Scheme-based Emacs
- [[http://jemacs.sourceforge.net][JEmacs Home]]
- http://jemacs.sourceforge.net/JEmacs-FSM.html
- Per Bothner


JEmacs is  a re-implementation  of the  Emacs programmable  text editor.  It is
written in Java,  and currently uses the  Swing GUI toolkit. Emacs  is based on
the extension language Emacs Lisp (Elisp), which is a dynamically-scoped member
of the Lisp family. JEmacs supports Elisp, as well as the use of Scheme, a more
modern  statically-scoped Lisp  dialect. Both  languages get  compiled to  Java
bytecodes,  either  in  advance  or  on-the-fly,  using  the  Kawa  compilation
framework.

*** SCM Scheme
- [[http://people.csail.mit.edu/jaffer/SCM.html][The SCM Implementation of Scheme]] ::

  latest release scm-5f3 2020-02-15 by Aubrey Jaffer


SCM is  a Scheme implementation  conforming to Revised5 Report  on the
Algorithmic Language Scheme and the  IEEE P1178 specification*. Scm is
written in C and runs under Amiga, Atari-ST, GNU/Linux, MacOS, MS-DOS,
MS-Vista,  MS-Windows, OS/2,  NOS/VE,  Unicos, VMS,  Unix and  similar
systems.

SCM includes  Hobbit, the  Scheme-to-C compiler originally  written by
Tanel  Tammet.  Hobbit  generates  C   files  whose  binaries  can  be
dynamically or statically  linked with a SCM  executable. SCM includes
linkable  modules   for  sequence-comparison,  arrays,   records,  and
byte-number  conversions;  and  modules  for POSIX  system  calls  and
network-sockets, readline, ncurses, and Xlib.

SCM requires the [[http://people.csail.mit.edu/jaffer/SLIB][SLIB Scheme Library]].

*** Scheme 48
- https://www.s48.org


Scheme 48 is an implementation of Scheme written by Richard Kelsey and
Jonathan Rees. It is based on  a byte-code interpreter and is designed
to be used  as a testbed for experiments  in implementation techniques
and as an expository tool.
*** Scsh
- https://scsh.net


Scsh is an  open-source Unix shell embedded within  Scheme, running on
all major  Unix platforms including  AIX, Cygwin, Linux,  FreeBSD, GNU
Hurd, HP-UX, Irix, Mac OS X, Solaris, and some others.

Scsh is  a variant  of Scheme  48 (an  R5RS compliant  new-tech Scheme
system)  Scsh  is  designed  for  writing  real-life  standalone  Unix
programs and  shell scripts. Scsh  spans a wide range  of application,
from “script”  applications usually handled  with perl or sh,  to more
standard systems applications usually written in C.

Scsh has two main components:  a process notation for running programs
and  setting up  pipelines and  redirections, and  a complete  syscall
library for low-level  access to the operating system,  i.e. to POSIX,
the least common  denominator of more or less all  Unices, plus widely
supported extensions such as symbolic links and BSD sockets. Moreover,
scsh provides  an awk  facility for pattern-directed  computation over
streams of  records, a  rich facility for  matching regular-expression
patterns  in  strings,   event-based  interrupt  handling,  user-level
threads, a  futuristic module system, and  an interactive environment.
Scsh  comes with  extensive documentation  describing these  and other
features.
*** STk
- http://kaolin.unice.fr/STk/


STk  is  a free  R4RS  Scheme  interpreter  which  can access  the  Tk
graphical  package. Concretely,  it can  be  seen as  the standard  Tk
package  where Tcl  has been  replaced  by a  Scheme interpreter.  STk
embeds  also an  efficient CLOS  like object  oriented system,  called
STklos, which provides:

- multiple inheritance,
- generic functions,
- multi-methods,
- a MOP (Meta Object Protocol)

** Scheme Programs
*** SLIB
- http://people.csail.mit.edu/jaffer/SLIB


The SLIB Portable Scheme Library.

SLIB is  a portable  library for the  programming language  Scheme. It
provides a platform independent framework for using packages of Scheme
procedures and  syntax. As distributed, SLIB  contains useful packages
for  all R4RS  and R5RS  Scheme  implementations. Its  catalog can  be
transparently  extended  to  accomodate   packages,  both  source  and
compiled, specific to a site, implementation, user, or directory.

*** SLIB-PSD Portable Scheme Debugger
- https://github.com/perttikellomaki/psd

*** Color-Scheme
- http://people.csail.mit.edu/jaffer/Color/Color-Scheme


SLIB's  color  package  provides  methods  to  specify,  compute,  and
transform colors in the color spaces...

*** BRL - the Beautiful Report Language
- http://brl.sourceforge.net


a framework for building server-side web applications.

*** The Festival Speech Synthesis System
- http://www.cstr.ed.ac.uk/projects/festival/


A general multi-lingual speech synthesis system with a Scheme-based command interpreter.

*** GIMP
- https://www.gimp.org

*** GnoTime
- http://gttr.sourceforge.net


GTT is  a to-do list/diary/journal tool  that can track the  amount of
time spent on projects, and,  among other things, generate reports and
invoices based on that time.

*** GNUCash
- https://www.gnucash.org

*** Guile
- https://www.gnu.org/software/guile/guile.html

*** Impromptu
- http://impromptu.moso.com.au

*** JACAL
- http://people.csail.mit.edu/jaffer/JACAL.html


JACAL is an interactive symbolic mathematics program.

** Scheme Libraries
*** The SLIB Portable Scheme Library
- http://people.csail.mit.edu/jaffer/SLIB.html
- [[http://groups.csail.mit.edu/mac/ftpdir/scm/slib-3b6.zip][SLIB ZIP Source]]
- Released 2020-02-16


SLIB is a portable Scheme library providing compatibiliy and utility functions
for all standard Scheme implementations.

SLIB supports
- Bigloo,
- Chez,
- ELK-3.0,
- Gambit-4.0,
- Gauche-0.9,
- Guile,
- JScheme,
- MacScheme,
- MITScheme,
- Pocket-Scheme,
- RScheme,
- S7,
- scheme->C,
- Scheme48,
- SCM,
- SCM-Mac,
- scsh,
- SISC,
- Stk,
- T3.1,
- umb-scheme, and
- VSCM.


SLIB-PSD is a portable debugger for Scheme (requires emacs editor):
- [[http://groups.csail.mit.edu/mac/ftpdir/scm/slib-psd1-3.tar.gz][SLIB-PSD SOURCE]]
- [[https://github.com/perttikellomaki/psd][SLIB on GitHub]]

**** SLIB Installation
- http://people.csail.mit.edu/jaffer/slib/Installation.html

**** SLIB Documentation
- http://people.csail.mit.edu/jaffer/slib/

** Scheme on Emacs

On Emacs, there are a couple of major modes designed for Scheme:

#+texinfo: @heading Work with Different Implementations of Scheme

- ~cmuscheme-mode~ :: Inferior Scheme mode---Major mode for interacting with an
  inferior  Scheme   process.  This   is  an  old   major  mode   extension  of
  ~scheme-mode~; adds functions  for code execution directly  from within Emacs
  buffers;  this package  implements interactive  work with  interactive Scheme
  interpreters. This interactive work is  implemented via the ~comint~ package,
  included into Emacs distribution.

  - [[https://github.com/typester/emacs/blob/master/lisp/cmuscheme.el][~cmuscheme.el~ source]]

  - Installation ::  put into your  initialization file the following  lines of
    code, and the package will be loaded when you call ~run-scheme~.

    #+begin_src lisp
      (autoload 'run-scheme "cmuscheme" "Run an inferior Scheme" t)
      (setq scheme-program-name "<scheme>")
    #+end_src

    All settings  for this  package are available  via the  customization group
    named =cmuscheme=.

- ~quack~ :: [[http://community.schemewiki.org/?Quack][Quack]] is a package  for Emacs by neil-van-dyke that enhances Emacs
  support for Scheme. It is  layered atop the standard packages ~cmuscheme.el~,
  by Olin Shivers, and ~scheme.el~, by Bill Rozas and Dave Love.

- [[http://www.nongnu.org/geiser/][~geiser~]]  :: Geiser  is a  collection  of Emacs  major and  minor modes  that
  conspire with one or more Scheme interpreters to keep the Lisp Machine Spirit
  alive. It draws inspiration (and a bit more) from environments such as Common
  Lisp’s Slime,  Factor’s FUEL, Squeak  or Emacs itself,  and does its  best to
  make Scheme hacking inside Emacs (even more) fun.


#+texinfo: @heading Work with Concrete Implementations of Scheme

- ~xscheme~ ::   Scheme  Interaction Mode---major mode for  interacting with an
  inferior MIT Scheme process; it is used to run (only) MIT Scheme under Emacs.

  : (require 'xscheme)
  : M-x run-scheme

- ~gds~ ::

- ~bee-mode~ ::

- ~gambit~ ::

*** Scheme Mode

~scheme-mode~ is a  major mode for editing Scheme code;  it is distributed with
Emacs and is a modified form  of ~lisp-mode~ (whose parent mode is ~prog-mode~)
and uses the same source-code editing commands as ~lisp-mode~.

~scheme-mode~  is started  with  the  command =M-x  scheme-mode=;  it runs  the
~scheme-mode-hook~ during initialization.

Using the  command =M-x run-scheme=  will start  an inferior Scheme  process in
~inferior-scheme-mode~ in a dedicated  buffer (usually called =*scheme*=) using
the general  ~cmuscheme~ package. When  an inferior Scheme process  is running,
some  additional  commands will  be  defined,  for evaluating  expressions  and
controlling the interpreter, and the state  of the process will be displayed in
the mode line of all Scheme buffers.

~scheme-mode~ provides the following functionality:
  - syntax highlighting
  - works with language expressions
  - indents source code
  - highlights paired brackets


~scheme-mode~ is enabled automatically for  all files with standard extensions
  of Scheme source code:
  - ~.scm~
  - ~.ss~


To enable ~scheme-mode~ for other file extensions:
  : (add-to-list 'auto-mode-alist '("\\.<ext>$" . scheme-mode))


 - To switch to that mode, put something like this into your ~.emacs~ file:

   #+begin_src elisp
   (autoload 'scheme-mode "cmuscheme" "Major mode for Scheme." t)
   (autoload 'run-scheme "cmuscheme" "Switch to interactive Scheme buffer." t)
   (setq scheme-program-name "name-of-your-scheme-program")
   (add-hook 'scheme-mode-hook 'turn-on-font-lock)
   #+end_src

   The  major mode  does syntax-highlighting  and indentation.  The minor  mode,
   invoked  with =M-x  run-scheme=, executes  a Scheme  interpreter in  an Emacs
   buffer. You can evaluate sections of a  program in the buffer or type into it
   directly.

*** CMU Scheme Mode
For  more advanced  syntax-highlighting and  indenting, check  out the  various
extensions to the ~cmuscheme~ mode at

- http://www.cs.indiana.edu/proglang/scheme/iucs.html.

*** MIT Scheme Mode
MIT Scheme includes a specialized  mode (~mit-scheme.el~) that understands some
of MIT's extensions and provides a closer integration with the REPL.

*** Quack
=Quack= (http://www.neilvandyke.org/quack/)  provides numerous  enhancements to
Emacs support, works with numerous  Scheme implementations, and is a no-brainer
install  (unless you  are using  a rare  Scheme implementation  for which  even
better REPL integration exists).

*** Support for Scheme on Emacs
You can find descriptions of these modes,  as well as some other Emacs packages
that provide support for Scheme [[http://alexott.net/en/writings/emacs-devenv/EmacsScheme.html][here]].

* Racket
- https://racket-lang.org


Racket is a general-purpose programming language as well as the
world’s first ecosystem for language-oriented programming. Make your
dream language, or use one of the dozens already available.

Racket started life as a Scheme implementation, but then grew into new
areas.

** Command-Line Tools
Racket provides as part of its standard distribution a number of
command-line tools.

*** Racket Command
- =raco= :: provides a command-line interface to many additional tools
  for compiling Racket programs and maintaining a Racket installation.
  The =raco= program supports various Racket tasks from a command line.

  See https://docs.racket-lang.org/raco/index.html

- =raco help= :: to get a complete list of available commands for your
  installation.

- =raco make= :: compiles Racket source to bytecode

- =raco exe= :: create stand-alone executables

- =raco setup= :: manages a Racket installation, including manually
  installed packages.

- =raco pkg= :: manages packages that can be installed through the
  Racket package manager.

- =raco test= :: run tests

- =raco doc= :: documentation search

- =raco scribble= :: building documentation

- =raco read= :: reading and pretty-printing

** Racket and Emacs

*** Racket Mode
[[https://github.com/greghendershott/racket-mode][Racket mode]] provides thorough syntax highlighting and DrRacket-style
REPL and buffer execution support for Emacs.

- Racket Mode Guide :: https://www.racket-mode.com

- Scheme Mode :: as a major mode, plus Quack and Geiser minor modes
* Clojure
 https://clojure.org

 "Clojure is a robust, practical, and fast programming language with a
 set of useful features that together form a simple, coherent, and
 powerful tool. Clojure provides easy access to the Java frameworks,
 with optional type hints and type inference, to ensure that calls to
 Java can avoid reflection."

Clojure is a dialect of Lisp, and shares with Lisp the code-as-data
philosophy and a powerful macro system. Clojure is predominantly a
functional programming language, and features a rich set of immutable,
persistent data structures. When mutable state is needed, Clojure
offers a software transactional memory system and reactive Agent
system that ensure clean, correct, multithreaded designs.

** Clojure Reference

*** Getting Started
https://clojure.org/guides/getting_started

*** The Reader
https://clojure.org/reference/reader

*** API
https://clojure.org/api/api
* Build Tools
:PROPERTIES:
:appendix: t
:custom_id: build-tools
:org-template-version: 0.6.29
:END:
** Makefile					:dependencies:env_vars:perl:
:PROPERTIES:
:appendix: t
:dependency1: make
:dependency2.0: AWS User account at https://aws.amazon.com
:dependency2.1: AWS cli v2 in PATH https://docs.aws.amazon.com/cli/index.html
:dependency2.2: See how to Install AWS CLI v2 at https://docs.aws.amazon.com/cli/latest/userguide/install-cliv2-mac.html
:dependency2.3: aws credentials: access token and secret access token stored in ~/.aws/credentials
:dependency2.4: AWS S3 buckets set up for serving a static web page
:dependency3: GitHub Account with personal access token stored in GITHUB_TOKEN
:dependency4: texinfo @6.7._
:dependency5: Emacs, Org-mode, Babel language 'shell' enabled
:env_var1: SYNC_ORG_TEMPLATE: holds the full path to this Template.org file
:env_var2: GITHUB_TOKEN: holds the GitHub personal access token
:env_var3: EDITOR: must hold a reference to a working emacsclient server
:env_var4: COLORS
:org-template-version: 0.6.29
:END:

#+name:Makefile
#+header: :tangle Makefile
#+begin_src makefile

  ###############################################################################
  ### USER-DEPENDENT VARIABLES
  ### USE ENVIRONMENT VARIABLES WHENEVER POSSIBLE

  # NOTE: All environment variables need to be exported PRIOR to starting the
  # Emacs server as EDITOR in your shell startup files; otherwise, they will not
  # be available to Emacs.
  # When I moved from using Bash to Zsh, I inadvertently changed the order of
  # import, and started the Emacs server before importing, and caused a horrible
  # bug which caused the program to work on one computer but fail on another.

  # The absolute path to this Template file
  TEMPLATE := $(SYNC_ORG_TEMPLATE)


  ### TOOLS & RESOURCES
  # tools is a directory holding tangled scripts, such as cmprpl
  # resources is a directory holding static resources for the project
  # images is a directory holding jpg and png image files
  TOOLS	:= tools
  CMPRPL	:= $(TOOLS)/cmprpl
  RESOURCES := resources
  IMAGES  := $(RESOURCES)/images

  # Use emacsclient as $EDITOR; make sure it is set in a shell startup file and
  # the server has been started.
  EMACS	  := $(EMACS)
  EDITOR	  := $(EDITOR)

  # User’s personal GitHub token for authentication to GitHub
  # DO NOT HARD-CODE THIS VALUE
  GITHUB_TOKEN := $(GITHUB_TOKEN)

  # The AWS Command Line Interface (AWS CLI) is an open source tool
  # that enables you to interact with AWS services using commands in
  # your command-line shell.  It must be present on your system.  Run the 'make'
  # command 'install-aws-cli' to install it if you do not have it.  Be sure to
  # run 'aws configure' after installing it.  This will place your AWS
  # credentials into ~/.aws/credentials.
  AWS := aws
  S3  := $(AWS) s3

  # The AWS region of choice; this can also be in .aws/config
  REGION := --region us-west-2

  ### END OF USER-DEPENDENT VARIABLES
  ###############################################################################
  ### MAKE-GENERATED VARIABLES

  ### PROJ AND ORG
  # ORG is the name of this Org file with extension .org
  # PROJ is the project name---the Org file name without extension.

  ### NOTE: there can be only one Org file in the project directory;
  # so far this has not been a problem, but it might be.

  PWD  := $(shell pwd)
  ORG  := $(shell ls *.org)
  PROJ := $(basename $(ORG))

  ### NOTE: S is needed only for the Template file because of the way it is nested
  # one level deep in the Templates GitHub repo, which uses the plural form
  # of Templates, whereas this file uses the singular form, Template.  So when
  # the homepage link is updated, the curl command must be told to use the plural
  # form.	 This is obviously a hack only for my own use and can be removed once
  # I clean up this anomaly.

  ifeq ($(PROJ),$(basename $(notdir $(TEMPLATE))))
  S := s
  endif

  # The AWS S3 bucket to use to store the html source file; it is found at the
  # key #+bucket towards the beginning of the file and should include the appropriate
  # suffix (.com, .net, .org, etc)
  BUCKET       := $(shell $(EDITOR) --eval \
		 '(with-current-buffer (find-file-noselect "$(ORG)") \
		    (save-excursion \
		      (goto-char (point-min)) \
		      (re-search-forward "^\#[+]bucket:\\(.*\\)$$" nil t) \
		      (match-string-no-properties 1)))')
  S3_BUCKET    := s3://$(BUCKET)
  HTTPS_BUCKET := https://$(BUCKET)

  ### DIR, SRC
  # DIR is the .info name found at '#+texinfo_filename:<DIR>.info' (at
  # the bottom of this file in the export configuration settings)
  # without its extension, used as the INFO filename and the name of the
  # HTML export directory; this code uses the lowercased PROJ name if
  # there is no '#+texinfo_filename'.
  # SRC is HTML directory based upon the DIR name

  #DIR := $(shell $(EDITOR) --eval \
  #	'(with-current-buffer (find-file-noselect "$(ORG)") \
  #		(save-excursion \
  #		(goto-char (point-min)) \
  #		(re-search-forward "^\#[+]\\(?:texinfo_filename\\|TEXINFO_FILENAME\\):\\(.*\\).info$$" nil t) \
  #		(match-string-no-properties 1)))')

  DIR := $(shell sed -E -n "/^\#\+texinfo_filename/s/^.*:(.*)\.info$$/\1/p" $(ORG))
  ifeq ($(DIR),$(EMPTY))
	  DIR := $(shell echo $(PROJ) | tr "[:upper:]" "[:lower:]")
  endif

  SRC := $(DIR)/

  ### VERS: v1.2.34/
  # VERS is the version number of this Org document.
  # When sync is run after the version number has been updated, then VERS
  # picks up the newly-changed value.  VERS used to be staticly imbedded
  # when the Makefile was tangled, but it needs to be dynamic for
  # development.

  # QUERY: should this number be formatted like this, or should it be just the numbers?
  # The reason it includes them is the S3PROJ obtains the name from the S3 bucket, and
  # it includes them.  But it only includes them because I have made it so.  Not a good
  # reason just by itself.  The ending slash is not actually a part of the version, but
  # comes from the way the 'aws2 ls' command returns its values.	So VERS should probably
  # not include the trailing slash, although it doesn’t hurt anything.

  VERS := v$(shell $(EDITOR) --eval \
	  '(with-current-buffer (find-file-noselect "$(ORG)") \
		  (save-excursion \
		    (goto-char (point-min)) \
		    (re-search-forward "^\#[+]\\(?:macro\\|MACRO\\):version Version \\(\\(?:[[:digit:]]+[.]?\\)\\{3\\}\\)") \
		    (match-string-no-properties 1)))')/

  ### AWS
  # PROJ_LIST contains the list of projects currently uploaded to
  # the S3 bucket; each item contains the name of the project and its
  # current version.

  # Created function using elisp instead of the shell.
  # This variable contains an elisp list of strings of the form '("proj1-v1.2.3/" "proj2-v4.5.6/" ...)'
  # However, when it prints to the shell, the quotes are lost.
  # Need to make sure elisp's variable 'exec-path contains the proper $PATH instead of adding to 'exec-path.

  PROJ_LIST := $(shell $(EDITOR) --eval \
	  "(progn \
		  (require (quote seq)) (add-to-list (quote exec-path) (quote \"/usr/local/bin\")) \
		  (seq-map (lambda (s) (replace-regexp-in-string \"^\s+PRE \" \"\" s)) \
			  (seq-filter (lambda (s) (string-match-p (regexp-quote \" PRE \") s)) \
			  (process-lines \"$(AWS)\" \"s3\" \"ls\" \"$(S3_BUCKET)\"))))")

  ### S3PROJ
  # The name of the current project as obtained from S3: 'proj-v1.2.34/'
  # If there is no current project in the S3 bucket, then assign a value equal to
  # the Org project and version instead.  It is set to the project if found, and
  # NO if not found, then updated in the ifeq block below.
  S3PROJ := $(shell $(EDITOR) --eval \
		  '(let ((proj (seq-find (lambda (s) (string-match-p "$(DIR)" s)) (quote $(PROJ_LIST))))) \
		     (or proj (quote NO)))')

  ### PROJINS3
  # is used by make sync; this allows the index.html file to be generated the first
  # time the project is synced.  It is set to NO if this project is not currently in an
  # S3 bucket, and it is set to YES if it is.
  PROJINS3 :=

  ### S3VERS
  # The version of this project currently installed in the S3 bucket: 'v1.2.34/'
  # If there is no current version in the S3 bucket, then assign the version from
  # this Org file instead.
  S3VERS   :=

  # Update S3PROJ, S3VERS, and PROJINS3
  ifeq ($(S3PROJ), NO)
	  S3PROJ := $(DIR)-$(VERS)
	  S3VERS := $(VERS)
	  PROJINS3 := NO
  else
	  S3VERS := $(subst $(DIR)-,,$(S3PROJ))
	  PROJINS3 := YES
  endif

  ### GITHUB
  # USER is the current user's GitHub login name.

  # The user name used to be statically embedded into the Makefile
  # during tangle, but in an effort to make the Makefile dynamically
  # indepedent, dynamic code has replaced the static code.  The code
  # that placed the static name in the Makefile was a 'node' script that
  # ran in a separate Org process during tangle.	An unfortunate fact of
  # 'make' is that 'make' strips the quote marks from the string
  # obtained from the 'curl' command when the 'make shell' command
  # returns the string.	 This makes the string malformed JSON and
  # unparsable by most JSON parsers, including 'node’.	However,
  # 'perl'’s core module JSON::PP (but not JSON::XS) has facilities to
  # parse very malformed JSON strings.	Therefore, this dynamic code
  # uses 'perl' and the core module JSON::PP to parse the 'curl' string
  # into a 'perl' JSON object which can return the login name.	This
  # code should work with any version of 'perl' without having to
  # install any modules.

  USER := $(shell \
	    curl -sH "Authorization: token $(GITHUB_TOKEN)" https://api.github.com/user \
	    | \
	    perl -MJSON::PP -e \
		'$$/ = ""; \
		 my $$json = JSON::PP->new->loose->allow_barekey->decode(<STDIN>); \
		 print $$json->{login};' \
	    )
  SAVE	:= resources

  ### TEXINFO
  TEXI	:= $(PROJ).texi
  INFO	:= $(DIR).info
  INFOTN	:= $(shell $(EDITOR) --eval "(file-truename \"$(INFO)\")")
  PDF	:= $(PROJ).pdf
  INDEX	:= index.html
  HTML	:= $(DIR)/$(INDEX)
  DIR_OLD	:= $(DIR)-old

  ### AWS S3
  DST_OLD	:= $(S3_BUCKET)/$(S3PROJ)
  DST_NEW	:= $(S3_BUCKET)/$(DIR)-$(VERS)
  EXCL_INCL   := --exclude "*" --include "*.html"
  INCL_IMAGES := --exclude "*" --include "*.jpg" --include "*.png"
  GRANTS	:= --grants read=uri=http://acs.amazonaws.com/groups/global/AllUsers
  S3SYNC	:= $(S3) sync --delete $(EXCL_INCL) $(SRC) $(DST_OLD) $(REGION) $(GRANTS)
  S3MOVE	:= $(S3) mv --recursive $(DST_OLD) $(DST_NEW) $(REGION) $(GRANTS)
  S3COPY	:= $(S3) cp $(INDEX) $(S3_BUCKET) $(REGION) $(GRANTS)
  S3REMOVE:= $(S3) rm $(S3_BUCKET)/$(S3PROJ) --recursive
  S3IMAGESYNC := $(S3) sync $(INCL_IMAGES) $(IMAGES) $(S3_BUCKET)/$(IMAGES) $(REGIONS) $(GRANTS)

  ###############################################################################

  default: check texi info html pdf

  PHONY: default all check values boot \
	    texi info html pdf \
	    open-org open-texi open-html open-pdf \
	    clean dist-clean wiped-clean \
	    help sync update delete-proj \
	    install-aws-cli \
	    index-html upload-index-html

  values: check
	    @printf "$${BLUE}Values...$${CLEAR}\n"
	    @echo TEMPLATE:	$(TEMPLATE)
	    @echo EDITOR:	$(EDITOR)
	    @echo USER:		$(USER)
	    @echo PWD:		$(PWD)
	    @echo ORG:		$(ORG)
	    @echo TEXI:		$(TEXI)
	    @echo INFO:		$(INFO)
	    @ECHO INFOTN:	$(INFOTN)
	    @echo BUCKET:	$(BUCKET)
	    @echo PROJ:		$(PROJ) $S
	    @echo S3_BUCKET:	$(S3_BUCKET)
	    @echo HTTPS_BUCKET:	$(HTTPS_BUCKET)
	    @echo VERS:		$(VERS)
	    @echo S3PROJ:	$(S3PROJ)
	    @echo S3VERS:	$(S3VERS)
	    @echo DIR:		$(DIR)
	    @echo DIR_OLD:	$(DIR_OLD)
	    @echo SRC:		$(SRC)
	    @echo DST_OLD:	$(DST_OLD)
	    @echo DST_NEW:	$(DST_NEW)
	    @echo PROJ_LIST:	"$(PROJ_LIST)"
	    @echo PROJINS3:	$(PROJINS3)

  check:
	    @printf "$${BLUE}Checking dependencies...$${CLEAR}\n"

	    @[[ -z $(BUCKET) ]] && \
	       { printf "$${RED}$(BUCKET) $${CYAN}must be set.$${CLEAR}\n"; exit 1; } || \
	       printf "$${CYAN}BUCKET: $${GREEN}$(BUCKET)$${CLEAR}\n";

	    @[[ -z $${GITHUB_TOKEN} ]] && \
	       { printf "$${RED}GITHUB_TOKEN $${CYAN}must be set.$${CLEAR}\n"; exit 1; } || \
	       printf "$${CYAN}GITHUB_TOKEN: $${GREEN}SET$${CLEAR}\n";

	    @[[ (-d ~/.aws) && (-f ~/.aws/credentials) && (-f ~/.aws/config) ]] && \
	       printf "$${CYAN}AWS credentials and config: $${GREEN}SET$${CLEAR}\n" || \
	       { printf "$${RED}~/.aws 'credentials' and 'config' must be set.$${CLEAR}\n"; exit 1; }

	    @[[ "$(shell $(EDITOR) --eval '(member (quote texinfo) org-export-backends)')" = "(texinfo)" ]] && \
		  printf "$${CYAN}Texinfo backend: $${GREEN}INSTALLED.$${CLEAR}\n" || \
		  { printf "$${YELLOW}Texinfo backend:$${CLEAR} $${RED}NOT INSTALLED; it must be installed.$${CLEAR}\n"; exit 1; }

	    @[[ $(shell $(EDITOR) --eval '(symbol-value org-confirm-babel-evaluate)') == "t" ]] && \
		  { printf "$${YELLOW}org-confirm-babel-evaluate:$${CLEAR} $${RED}T; set to NIL.$${CLEAR}\n"; exit 1; } || \
		  printf "$${CYAN}org-confirm-babel-evaluate: $${GREEN}OFF.$${CLEAR}\n\n"

  open-org: $(ORG)
	    @$(EDITOR) -n $(ORG)
  $(ORG):
	    @echo 'THERE IS NO $(ORG) FILE!!!'
	    exit 1

  texi: $(TEXI)
  $(TEXI): $(ORG)
	   @echo Making TEXI...
	   @$(EDITOR) -u --eval \
		  "(with-current-buffer (find-file-noselect \"$(ORG)\" t) \
			  (save-excursion \
			  (org-texinfo-export-to-texinfo)))"
	   @echo Done making TEXI.
  open-texi: texi
	   @$(EDITOR) -n $(TEXI)

  info: $(INFO)
  $(INFO): $(TEXI)
	   @echo Making INFO...
	   @makeinfo -o $(INFO) $(TEXI)
	   @$(EDITOR) -u -eval \
		  "(when (get-buffer \"$(INFO)\") \
			  (with-current-buffer (get-buffer \"$(INFO)\") \
				  (revert-buffer t t t)))"
	   @echo Done making INFO.

  open-info: info
	   @$(EDITOR) -u -eval \
		  "(if (get-buffer \"*info*\") \
			  (with-current-buffer (get-buffer \"*info*\") \
				(when (not (string= \"(symbol-value (quote Info-current-file))\" \"$(INFOTN)\")) \
					(info \"$(INFOTN)\")) \
				(revert-buffer t t t)) \
		      (info \"$(INFOTN)\"))"

  html: $(HTML)
  $(HTML): $(TEXI)
	   @echo Making HTML INFO..
	   @makeinfo --html -o $(DIR) $(TEXI)
	   @echo Done making HTML.
	   $(CMPRPL) $(DIR) $(DIR_OLD)
  open-html: html
	   @open $(HTML)

  # If pdftexi2dvi produces an error, it may still produce a viable PDF;
  # therefore, use --tidy.  If it produces an error, try to link the PDF;
  # if it does not produce an error, the PDF will be added to the top dir
  # and there will be no attempt to link.
  pdf:	$(PDF)
  $(PDF): $(TEXI)
	  @echo Making PDF INFO...
	  @-pdftexi2dvi --quiet --build=tidy $(TEXI) || ln -s $(PROJ).t2d/pdf/build/$(PDF) $(PDF)
	  @echo Done making PDF.
  open-pdf:pdf
	   @open $(PDF)

  sync:   $(HTML)
	  @echo Syncing version $(VERS) onto $(S3VERS)...
	  $(S3SYNC)
	  $(S3IMAGESYNC)
	  @echo Done syncing.
	  [[ $(VERS) != $(S3VERS) ]] && { echo Moving...; $(S3MOVE); echo Done moving.;  make homepage; } || :
	  [[ $(PROJINS3) = "NO" ]] && make homepage || :

  # This is a target-specific variable for updating the “description”
  # key on the GitHub repo page with the current version number.  It
  # first makes a curl call to the GitHub project repo, finds the
  # “description” line, pulls out the description only (leaving the old
  # version) and then prints the value with the current version number.
  # This value is used by the “homepage:” target in the PATCH call.
  # This method is arguably harder to code but faster to run than using
  # Perl with the JSON::PP module.

  homepage: description = $(shell \
	  curl -s \
		  -H "Authorization: token $(GITHUB_TOKEN)" \
		  https://api.github.com/repos/$(USER)/$(PROJ)$S | \
		  (perl -ne 'if (/^\s*\"description\":\s*\"(.*): v(?:(?:[[:digit:]]+[.]?){3})/) {print $$1}'))

  ### NOTE the use of the S variable at the end of PROJ; this is to handle
  # the singular case of the GitHub repo using the plural form, Templates
  # whereas the the Template.org file uses the singular form.
  homepage: $(ORG) upload-index-html
	    @echo Updating homepage...
	    @echo DESCRIPTION: $(description)
	    @echo VERS: $(VERS)
	    @curl -i \
		  -H "Authorization: token $(GITHUB_TOKEN)" \
		  -H "Content-Type: application/json" \
		  -X PATCH \
		  -d "{\"homepage\":\"$(HTTPS_BUCKET)/$(DIR)-$(VERS)\",\
		       \"description\":\"$(description): $(VERS)\"}" \
		  https://api.github.com/repos/$(USER)/$(PROJ)$S
	    @echo Done updating homepage.

  delete-proj:
	  @echo Deleting project $(PROJ)...
	  @curl -i \
		  -H "Authorization: token $(GITHUB_TOKEN)" \
		  -H "Accept: application/vnd.github.v3+json" \
		  -X DELETE \
		  https://api.github.com/repos/$(USER)/$(PROJ)$S
	  @$(S3REMOVE)
	  @make dist-clean
	  @make upload-index-html
	  @$(EDITOR) -u --eval "(kill-buffer \"$(ORG)\")"
	  @rm -rf "../$(PROJ)"
	  @echo Done deleting project.

  index-html: $(INDEX)
  $(INDEX): $(ORG)
	  @echo making index.html...
	  $(EDITOR) --eval \
	  "(with-current-buffer (find-file-noselect \"$(ORG)\") \
		  (save-excursion \
		    (org-link-search \"#project-index-title\") \
		    (org-export-to-file (quote html) \"index.html\" nil t)))"
	  @echo Done making index.html.

  upload-index-html: $(INDEX)
	   @echo Uploading index.html...
	   $(S3COPY)
	   @echo Done uploading index.html

  install-aws-cli:
	    curl "https://awscli.amazonaws.com/AWSCLIV2.pkg" -o "AWSCLIV2.pkg" && \
	    sudo installer -pkg AWSCLIV2.pkg -target / && \
	    which aws && aws --version
	    rm -rf AWSCLIV2.pkg

  clean:
	  @echo Cleaning...
	    -@rm *~ 2>/dev/null
	    -@for file in *.??*; \
	    do \
		    ext=$${file#$(PROJ).}; \
		    [[ ! $${ext} =~ org|texi|info|pdf|html ]] && rm -rv $${file}; \
	    done

  dist-clean: clean
	  @echo Dist Cleaning...
	    @${EDITOR} -u --eval \
	      "(kill-buffer \"$(ORG)\")"
	    -@rm -rf *.{texi*,info*,html*,pdf*} $(DIR) $(TOOLS)
	    -@for dir in *; \
		do \
		    [ -d $$dir -a $$dir != "$(DIR_OLD)" -a $$dir != $(SAVE) ] && \
		    rm -vr $$dir; \
		done

  wipe-clean: dist-clean
	  @echo Wipe Clean...
	    -@rm -rf Makefile Readme.md $(DIR_OLD)
	    @git checkout Makefile README.md

  git-ready: dist-clean
	    git checkout Makefile
	    git checkout README.md
	    git status

  help:
	    @echo '"make boot" tangles all of the files in Template'
	    @echo '"make default" makes the .texi file, the .info file, \
	    the html files, and the .pdf file.'
	    @echo

	    @echo '"make check" checks for prerequistes'
	    @echo '"make values" runs check and prints variable values'
	    @echo

	    @echo '"make texi" makes the .texi file'
	    @echo '"make info" makes the .info file'
	    @echo '"make html" makes the html distribution in a subdirectory'
	    @echo '"make pdf" makes the .pdf file'
	    @echo

	    @echo '"make open-org" opens the ORG program using emacsclient for editing'
	    @echo '"make open-texi" opens the .texi file using emacsclient for review'
	    @echo '"make open-html" opens the distribution index.html file \
	    in the default web browser'
	    @echo '"make open-pdf" opens the .pdf file'
	    @echo

	    @echo '"make sync" syncs the html files in the AWS S3 bucket BUCKET; \
	    you must have your AWS S3 bucket name in the env var AWS_S3_BUCKET; \
	    You must have your AWS credentials installed in ~/.aws/credentials'
	    @echo

	    @echo '"make install-aws-cli" installs the "aws cli v2" command-line tools'
	    @echo 'You also need to run "aws configure" and supply your Access Key and Secret Access Key'
	    @echo

	    @echo '"make clean" removes the .texi, .info, and backup files ("*~")'
	    @echo '"make dist-clean" cleans, removes the html distribution, \
	    and removes the build directory'
	    @echo '"make wipe-clean" wipes clean the directory, including old directories'
	    @echo

	    @echo '"make delete-proj" deletes the project from the file system, GitHub and AWS'

#+end_src

*** TODO Next
1. The CloudFront configuration needs to be updated recognize the new version
   directory that is created as part of the ~sync~ operation.

2. Update the GitHub HOME website link for each new sync operation.

3. Store on GitHub a version of each other format upon a sync operation (i.e.,
   the INFO and PDF versions)

** Compare Replace

#+begin_comment
The following source  code tangles all files during an  export operation.  This
is  to make  sure the  ~cmprpl~ source  code exists  in the  ~tools/~ directory
before  running the  Makefile target  =html=.  It  also makes  sure there  is a
Makefile on an initial export. The following code is not exported.
#+end_comment

#+name:tangle-org-file
#+header: :exports results :eval yes :results silent
#+begin_src emacs-lisp
(org-babel-tangle-file (buffer-file-name))
#+end_src

The  AWS ~sync~  command  relies  upon time  stamps  to  determine whether  two
programs are identical or not, as  well as content.  If two otherwise identical
files have  different time stamps,  ~sync~ will  assume they are  different and
will  process the  newer.   However, the  ~texinfo~  ~makeinfo --html~  command
produces all  new files even  if some files  (or most files)  remain unchanged.
This  means that  all files  will be  uploaded to  the AWS  S3 bucket  on every
iteration, even though the majority of the files are actually unchanged.

The ~cmprpl~  source code attempts to  resolve the issue of  identical exported
code having different  time stamps, thus defeating the benefit  provided by the
~aws2 s3 sync~ command uploading only changed files.

This program makes sure that a generated HTML directory exists: =$DIR_NEW=.  If
it doesn’t, then it is in an improper state and the program stops with an error
message.

The  program then  checks  if  an old  directory  exists,  =$DIR_OLD=.  If  one
doesn’t,  then one  is  created by  copying the  current  new directory.   This
provides a baseline  for comparisons going forward.  The program  exits at that
point. It is very important that  the =$DIR_OLD= directory not be deleted going
forward.

Given  that =$DIR_OLD=  exists, the  program then  loops through  all files  in
=$DIR_NEW= and  compares them  to the  files in =$DIR_OLD=.   If the  files are
identical, the =$DIR_OLD= file replaces the =$DIR_NEW= file while retaining the
old time stamp (using the ~-p~ option of ~cp~. If a file is different, then the
=$DIR_NEW= file  replaces the =$DIR_OLD=  file, thus giving it  updated content
and  an updated  time stamp.   If the  file does  not exist  in the  =$DIR_OLD=
directory, then it is added.

The  program then  loops through  all of  the files  in the  old directory  and
deletes  any that  do not  exist in  the new  directory.  Now  both directories
should be in sync.

#+caption:Compare Replace program
#+name:cmprpl
#+header: :mkdirp t
#+header: :shebang "#!/usr/bin/env bash"
#+begin_src sh :tangle tools/cmprpl
  [[ $# -eq 2 ]] || { echo "ERROR: Incorrect command line arguments"; exit 1; }
  DIR_NEW=$1
  DIR_OLD=$2

  [[ -d $DIR_NEW ]] || { echo "ERROR: $DIR_NEW does not exist"; exit 1; }
  [[ -d $DIR_OLD ]] || { echo "CREATING: $DIR_OLD does not exist"; cp -a $DIR_NEW $DIR_OLD; exit 0; }

  for newfile in $DIR_NEW/*
  do
      oldfile=$DIR_OLD/$(basename $newfile)
      if [[ -e $oldfile ]]
      then
	 if cmp -s $newfile $oldfile
	 then
	     printf "${GREEN}copying OLD to NEW${CLEAR}: "
	     cp -vp $oldfile $newfile
	 else
	     printf "${PURPLE}copying NEW to OLD${CLEAR}: "
	     cp -vp $newfile $oldfile
	 fi
      else
	  printf "${BLUE}creating NEW in OLD${CLEAR}: "
	  cp -vp $newfile $oldfile
      fi
  done

  for oldfile in $DIR_OLD/*
  do
      newfile=$DIR_NEW/$(basename $oldfile)
      if [[ ! -e $newfile ]]
      then
	  printf "${RED}removing OLD${CLEAR}: "
	  rm -v $oldfile
      fi
  done
#+end_src


** Update Utility Commands
*** Get Parsed Org Tree
This function looks for an Org file in the present working directory, and if it
finds one returns  a parsed tree using  ~org-element-parse-buffer~.  It returns
=nil= if there is no Org file or if the found file is not in ~org-mode~.

#+name:get-parsed-org-tree
#+header: :results silent
#+begin_src emacs-lisp
(defun get-parsed-org-tree (&optional org-dir)
  "This function takes an optional directory name, changes to
that directory if given, otherwise uses the pwd, and finds an Org
file and returns its parsed tree, or nil if none found."
  (when org-dir
      (cd (file-name-as-directory org-dir)))
  (let ((buf (car-safe (find-file-noselect "*.org" nil nil t))))
    (if buf
	(with-current-buffer buf (org-element-parse-buffer))
      nil)))
#+end_src

*** Check for CID
This code  checks whether an  Org file contains  a =custom_id= of  a particular
value.  It accepts  a ~cid-value~ and an optional directory.   If the directory
is not given, then it defaults to the current directory.  If throws an error if
the directory does not exist.  It returns =nil= if the given directory does not
contain an Org file.   It returns =t= if the Org file  contains a node property
of   =custom_id=  and   value  ~cid-value~,   or   =nil=  if   not.   It   uses
~get-parsed-org-tree~.

#+name:org-tree-cid-p
#+header: :results silent
#+begin_src emacs-lisp
(defun org-tree-cid-p (cid-value &optional org-dir)
  "Check whether an org file contains a custom_id of CID"
  (let ((tree (get-parsed-org-tree org-dir)))
    (car (org-element-map tree 'property-drawer
	   (lambda (pd) (org-element-map (org-element-contents pd) 'node-property
			  (lambda (np)
			    (and
			     (string= "custom_id" (org-element-property :key np))
			     (string= cid-value (org-element-property :value np))))))
	   nil t))))
#+end_src

#+name:run-org-tree-cid-p
#+header: :var cid="build-tools"
#+header: :var dir="/usr/local/dev/programming/MasteringEmacs"
#+header: :var gpot=get-parsed-org-tree()
#+header: :var otcp=org-tree-cid-p()
#+header: :results value
#+header: :eval never-export
#+begin_src emacs-lisp
(org-tree-cid-p cid dir)
#+end_src

#+call: run-org-tree-cid-p(dir="/usr/local/dev/programming/MasteringEmacs")

** Bucket Index HTML
The bucket should contain a master ~index.html~  file that links to each of the
individual project  ~index.html~ files.  The  master ~index.html~ file  will be
placed at the root of  the bucket, ~https://<bucket-name>.com/~, and the bucket
must be set up to serve this ~index.html~ when the user hits the root.

*** Get Bucket Name
 This  code searches  for  the keyword-value  pair =bucket:<BUCKET-NAME>=  that
 should be  located towards the  beginning of the  file, and returns  the value
 =BUCKET-NAME= or nil if not found.

#+name: get-bucket-name
#+header: :results value
#+begin_src emacs-lisp
   (save-excursion
     (goto-char (point-min))
     (re-search-forward "^#\\+bucket:\\s*?\\(.*\\)$" nil t)
     (match-string-no-properties 1))
#+end_src

For some reason, ~get-bucket-name~ does not  work when called from the headline
[[#project-index-links][=Links for  bucket=]] below  when creating  =index.html=, even  if it  returns as
~(prin1 ...)~ and is  set up to ~:return output~; the  call receives =nil=. The
following code from ~bucket-name~, however, works. I don't know why.

#+name: bucket-name
#+header: :results output
#+header: :var bucket-name=get-bucket-name()
#+begin_src emacs-lisp
(prin1 bucket-name)
#+end_src

*** Bucket HTTPS URL
This  code calls  ~get-bucket-name~ and  returns the  value returned  as a  URL
string or nil.

#+name: bucket-https-url
#+header: :results value
#+header: :var b=get-bucket-name()
#+begin_src emacs-lisp
(concat "https://" b)
#+end_src

*** S3 Bucket URL
This code calls ~get-bucket-name~ and returns the AWS S3 bucket url.

#+name: s3-bucket-url
#+header: :results value
#+header: :var b=get-bucket-name()
#+begin_src emacs-lisp
(concat "s3://" b)
#+end_src

*** Bucket Projects List
This code uses the ~s3-bucket-url~ result to obtain the list of projects in the
bucket.  It does  this by calling the  AWS S3 high-level command  ~ls~ and then
removing the  =PRE= string in  each result.  The result  that is returned  is a
single  string that  can be  separated into  individual links  by breaking  the
string on spaces.

#+name: bucket-projects-list
#+header: :results output
#+header: :var bucket=s3-bucket-url()
#+begin_src sh
/usr/local/bin/aws s3 ls ${bucket} | sed -ne 's/^.*PRE //p'
#+end_src

*** Bucket Project Links
This code  uses the result  from ~bucket-projects-list~ to create  an unordered
list of  links written to  bucket projects, written  in Org-mode syntax.  It is
executed by a =#+call:= in [[*Bucket Index][*Bucket  Index]] during an HTML export of that subtree
to a file called =index.html=.

#+name: bucket-project-links
#+header: :var b-url=bucket-https-url()
#+header: :var projects=bucket-projects-list()
#+header: :results output raw
#+begin_src emacs-lisp
(seq-do (lambda (u) (princ (format "- [[%s/%sindex.html][~%s~]]
" b-url u u))) (split-string projects))
#+end_src

*** Bucket Index
    :PROPERTIES:
    :custom_id: project-index-title
    :export_file_name: index.html
    :export_subtitle: {{{version}}} created {{{upload-date}}}
    :END:
#+html_doctype: html5
#+options: toc:nil html5-fancy:t

#+html: <hr>

**** Links for bucket call_bucket-name()
     :PROPERTIES:
     :unnumbered: t
     :custom_id: project-index-links
     :END:

#+call: bucket-project-links()
** Project Readme
This adds the README.md template to a project. It should be customized uniquely
for the project.

#+name:project-readme
#+header: :tangle README.md
#+begin_src markdown
# TITLE
## Subtitle
## Author
## Date
## Version
# ABSTRACT
This is the Org Template file.	It is the parent of all other Org Info blogs,
and provides the source code for processing them in various different ways.
# INTRODUCTION
# CHAPTER
## Section
### Subsection
#+end_src

** Boot Template
:PROPERTIES:
:dependency1: EMACS:=:/Applications/MacPorts/Emacs.app/Contents/MacOS/Emacs or similar
:dependency2: EDITOR:=:emacsclient
:dependency3: =SYNC_ORG_TEMPLATE= defined as $DEV/Templates/Org/Template.org
:END:
Although running the command ~org-babel-tangle~ (=C-c C-v t=) from within Emacs
will install  everything, it would  be nice to have  a simple Makefile  that is
downloaded with this  file that could be  invoked to do the  same thing without
starting Emacs and Org-mode and keying in the ~org-babel-tangle~ command.  This
little Makefile should be stored on  GitHub along with the ~Template.org~ file.
When  the source  is extracted  to a  directory, then  running this  Makefile's
default rule  as simply ~make~  will extract the ~preprocess.el~  script, which
updates  =DEV= and  then  extracts the  full Makefile.   Because  this file  is
tangled along with the full Makefile, it simply gets tacked onto the end of the
big Makefile as an additional rule.   Now, running ~make~ runs the default rule
from the  main Makefile, which is  to extract everything, then  export to TEXI,
INFO, HTML, and PDF forms.

It is assumed that an Emacs server is running, and that the $EDITOR environment
variable is set to use ~emacsclient~.

#+name:boot-template
#+header: :tangle Makefile
#+begin_src makefile
boot:
	$(EDITOR) -u --eval \
		"(with-current-buffer (car (find-file-noselect \"./*.org\" nil nil t)) \
			(goto-char (point-min)) \
			(re-search-forward \"^#[+]name:preprocess.el$$\") \
			(org-babel-tangle (quote (4))) \
                        (save-buffer) \
			(kill-buffer))"
	./tools/preprocess.el
#+end_src

** Preprocess Env Vars
The environment variable DEV can be  in different locations and will be spelled
differently based  on how the  local machine is set  up.  For instance,  on one
system,  it will  be at  ~$HOME/Dev~  while in  another  system it  will be  at
~/usr/local/dev~.  However, the =:tangle= keyword  does not expand variables in
the form ~${DEV}~,  but rather requires absolute  paths, like ~/usr/local/dev~.
Therefore, this program works like a preprocessor for environment variables set
up  as part  of  =:tangle= lines,  changing them  to  their system  environment
variable values prior to tangling.  It lives in the ~tools~ directory.

#+name:preprocess.el
#+header: :mkdirp t
#+header: :tangle tools/preprocess.el
#+header: :shebang "#!/opt/local/bin/emacs -Q --script"
#+begin_src emacs-lisp
  (with-current-buffer (car (find-file-noselect "./*.org" nil nil t))
    (save-excursion
    (goto-char (point-min))
    (let ((re-search-str "\\(?::tangle\\|load-file \\(?:[\\]*\\)?[\"]\\)\s*\\(.*?/[dD]ev\\)/")
          (dev (getenv "DEV")))
      (while
              (re-search-forward re-search-str nil t)
              (replace-match dev t nil nil 1)))
    (save-buffer)
    (require 'org)
    (org-babel-tangle)))
#+end_src

** Samples
#+begin_comment
(cd "~/Dev/Emacs/MasteringEmacs/")
"/Users/pine/Dev/Emacs/MasteringEmacs/"

(defun add-bucket (org bucket)
  "Add a bucket keyword BUCKET to the org file ORG."
  (interactive "fFile: \nsBUCKET: ")
  (with-current-buffer (find-file-noselect org)
    (let* ((tree (org-element-parse-buffer))
	   (ins (car (org-element-map tree (quote section)
		 (lambda (s)
		   (org-element-map s (quote keyword)
		     (lambda (kw) (when (equal "MACRO" (org-element-property :key kw)) (1- (org-element-property :end kw))))
		     nil nil :keyword))
		 nil t nil nil))))
      (goto-char ins)
      (insert (format "#+bucket:%s\n" bucket))
      ())))

(add-bucket "MasteringEmacs.org" "pinecone-forest")
nil

(defun hl-region (raw-hl)
  "Obtain the begin and end positions for a headline."
  (with-current-buffer (find-file-noselect (getenv "SYNC_ORG_TEMPLATE"))
    (let* ((tree (get-parsed-tree))
	   (hl (car-safe (org-element-map tree 'headline
			   (lambda (hl) (when
					    (string= raw-hl
						     (org-element-property :raw-value hl))
					  (org-element-context)))
			   nil nil t))))
      (cons
       (org-element-property :begin hl)
       (org-element-property :end hl))
      )))

(hl-region "Build Tools")

(4888 . 29646)

(defun get-hl-with-prop (org-dir hl-prop)
  "Given a directory containing an Org template file and a custom_id property name, return the headline containing that custom_id, or nil if none."
  (progn
    (cd org-dir)
    (let ((org-buf (car-safe (find-file-noselect "*.org" nil nil t))))
      (if org-buf
	  (with-current-buffer org-buf
	    (let ((tree (org-element-parse-buffer)))
	      (org-element-map tree 'headline
		(lambda (hl)
		  (let ((cid (org-element-property :CUSTOM_ID hl)))
		    (when (string= hl-prop cid)
		      (and
		       (message (format "Found the headline %s containing property %s." (org-element-property :raw-value hl) hl-prop))
		       hl))))
		nil t)))
	(and
	 (message (format "The directory %s does not contain an Org file." org-dir))
	 nil)))))

(get-hl-with-prop "~/Dev/Templates/Org" "build-tools")

(headline (:raw-value "Build Tools" :begin 4888 :end 29646 :pre-blank 0 :contents-begin 4902 :contents-end 29645 :level 1 :priority nil :tags nil :todo-keyword nil :todo-type nil :post-blank 1 :footnote-section-p nil :archivedp nil :commentedp nil :post-affiliated 4888 :FROM-FILE "Template" :CUSTOM_ID "build-tools" :APPENDIX "t" :title "Build Tools"))









;;; Add a keyword named 'bucket' just after the version macro.
;;; This function should be run from within the directory containing the Org file.
(defun add-bucket (org-file s3-bucket)
  "Add the name of the associated AWS S3 bucket to an Org templated file."
  (with-current-buffer (find-file-noselect org-file)
    (goto-char (point-min))
    (let* ((tree (org-element-parse-buffer))
	   ;; find the beginning position of the first headline to act as a limit
	   (hl1 (org-element-map tree (quote headline) (lambda (hl) (org-element-property :begin hl)) nil t)))
      ;; Check for the presence of a bucket keyword before the first headline
      (unless (re-search-forward "^#\\+bucket:" hl1 t)
	;; If no bucket keyword is found, search for a keyword MACRO with the value 'version'
	(org-element-map tree (quote keyword)
	  (lambda (kw) (when (and (string= "MACRO" (org-element-property :key kw))
				  (string-match-p "version" (org-element-property :value kw)))
			 ;; return the end position of the MACRO; subtract an empty line if there is one
			 (goto-char (- (org-element-property :end kw) (org-element-property :post-blank kw)))
			 (insert "#+bucket:" s3-bucket)
			 (newline)
			 (basic-save-buffer)
			 (message (format "Added bucket %s" s3-bucket))))
	  nil t)))))

(add-bucket "MasteringEmacs.org" "pinecone-forest.com")
nil

"Added bucket pinecone-forest.com"









(keyword (:key "MACRO" :value "version Version 0.0.108" :begin 148 :end 181 :post-blank 1 :post-affiliated 148 ...))
("TITLE" "SUBTITLE" "AUTHOR" "DATE" "MACRO" "TEXINFO" "TEXINFO" "CINDEX" "CINDEX" "CINDEX" "CINDEX" "CINDEX" ...)







((keyword (:key "MACRO" :value "version Version 0.0.107" :begin 148 :end 181 :post-blank 1 :post-affiliated 148 ...)))
#+end_comment

* List of Programs
:PROPERTIES:
:appendix: t
:END:
#+texinfo:@listoffloats Listing

* List of Examples
:PROPERTIES:
:appendix: t
:END:
#+texinfo:@listoffloats Example

* Copying
:PROPERTIES:
:copying:  t
:END:

Copyright \copy 2020 by {{{author}}}


* Concept Index
:PROPERTIES:
:index: cp
:END:

* Program Index
:PROPERTIES:
:index: pg
:END:

* Function Index
:PROPERTIES:
:index: fn
:END:

* Variable Index
:PROPERTIES:
:index: vr
:END:


* Configuration							   :noexport:
#+todo: SOMEDAY(s@) TODO(t@) INPROGRESS(i@) WAIT(w@) | CANCEL(c@) DONE(d!)

#+options: H:4

#+texinfo_class: info
#+texinfo_header:
#+texinfo_post_header:
#+texinfo_dir_category:<DIR CATEGORY>
#+texinfo_dir_title:<DIR TITLE>
#+texinfo_dir_desc:<DIR DESCRIPTION>
#+texinfo_printed_title:LispLang---The Universe Known as LISP


* Footnotes

[fn:1] Runtime Compilation: https://wiki.c2.com/?RuntimeCompilation

[fn:2] MetaObjectProtocol: https://wiki.c2.com/?MetaObjectProtocol

[fn:3]Recursive Functions of Symbolic Expressions and Their Computation by
Machine, Part I, by John McCarthy, April 1960 @
http://www-formal.stanford.edu/jmc/recursive/recursive.html.
Note: Part II never appeared.

[fn:4]The  name "Steel  Bank Common  Lisp" is  a reference  to Carnegie  Mellon
University Common Lisp from which SBCL forked: Andrew Carnegie made his fortune
in the steel industry and Andrew Mellon was a successful banker.

[fn:5]The libraries were last updated on July 15, 2020.

[fn:6]*namestring*:  a  string that  represents  a  filename using  either  the
standardized    notation    for    naming    logical    pathnames    or    some
implementation-defined notation for naming a physical pathname.

[fn:7]A stream  on which it  makes sense  to perform interactive  querying. The
general intent of having some streams be classified as /interactive/ streams is
to allow them to be distinguished  from streams containing batch (or background
or command-file) input. Output to batch streams is typically discarded or saved
for later  viewing, so interactive queries  to such streams might  not have the
expected effect.

[fn:8]In the browser, add =index.text= to the end of the URL to see the source.

[fn:9]Markdown requires the standard Perl library module Digest::MD5.

* Local Variables						   :noexport:
# Local Variables:
# fill-column: 79
# eval: (auto-fill-mode)
# time-stamp-pattern: "8/^\\#\\+date:%:y-%02m-%02d %02H:%02M$"
# End:
